<!doctypehtml><html amp lang="en"><meta charset="utf-8"><title>Fat vs. Skinny Design</title><link rel="canonical"href="https://www.yegor256.com/2020/02/19/fat-skinny-design.html"><link rel="icon"type="image/png"href="/favicon.ico"><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><script type="application/ld+json">{
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2020/02/19/fat-skinny-design.html"
        },
        "headline": "Fat vs. Skinny Design",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2020/02/owning-mahowny.jpg",
          "height": 720,
          "width": 1280
        },
        "datePublished": "2020-02-19",
        "dateModified": "2020-02-19",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Type hierarchies may be designed in two extreme
approaches, making them either very extendable and
reusable, or not.
",
        "keywords": ["oop design", "class vs interface", "fat design", "skinny design", "type hierarchy"]
      }</script><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript><link rel="stylesheet"href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500"><style amp-custom="amp-custom">@font-face{font-family:Cambria;src:url(https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf)}body{font-family:Cambria,'Times New Roman',serif;padding:.5em;font-size:1.2em}article{width:600px;max-width:100%;margin-left:auto;margin-right:auto}code,pre{font-family:'Source Code Pro','Courier New',monospace;font-size:.8em}code{padding:0 .3em;background-color:#d3d3d3}a,a:hover,a:visited{color:inherit}.intro{color:red;font-size:.75em}.photo{border-radius:50%}pre{overflow-x:scroll}</style><script async src="https://cdn.ampproject.org/v0.js"></script><article><p class="intro">This is a mobile version, full one is <a href="https://www.yegor256.com/2020/02/19/fat-skinny-design.html">here</a>.<p><amp-img src="/images/face-256x256.jpg"width="80"height="80"alt="Yegor Bugayenko"class="photo"></amp-img><p>Yegor Bugayenko<br>19 February 2020<h1>Fat vs. Skinny Design</h1><p>It seems that type/class hierarchies in OOP may be designed in two extreme ways: either with full encapsulation of data in mind; or with just a few interfaces making raw data visible, and letting classes deal with it, parse it, and turn it into smaller data elements. You may be surprised, but I’m suggesting the second option is more elegant. It seems to me that we don’t lose object orientation, but rather gain a lot of flexibility, reusability, testability, and so on.</p><amp-img src="/images/2020/02/owning-mahowny.jpg"alt="Owning Mahowny (2003) by Richard Kwietniowski"height="720"width="1280"layout="responsive"></amp-img><p>Take a look at this (let’s call it <em>fat</em> and I will explain why later):<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Article</span> <span class="o">{</span>
  <span class="nc">Head</span> <span class="nf">head</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">Head</span> <span class="o">{</span>
  <span class="nc">Author</span> <span class="nf">author</span><span class="o">();</span>
  <span class="nc">String</span> <span class="nf">title</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">Author</span> <span class="o">{</span>
  <span class="nc">String</span> <span class="nf">name</span><span class="o">();</span>
  <span class="nc">String</span> <span class="nf">email</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>To obtain the name of the author we do:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// It is stored in PostgreSQL (that's why the Pg</span>
<span class="c1">// prefix) and retrieves everything using SQL</span>
<span class="nc">Article</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PgArticle</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">head</span><span class="o">().</span><span class="na">author</span><span class="o">().</span><span class="na">name</span><span class="o">();</span>
</code></pre></div></div><p>Visually, this design may look like this (in UML):<p><object data="/uml/b9cc42a8e5ed92f94f4362cfd328fb0d.svg"type="image/svg+xml"class="plantuml"></object><p>Now, let’s compare it with an alternative design (which is much less <em>fat</em> than the previous one, I would even call it <em>skinny</em>):<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Article</span> <span class="o">{</span>
  <span class="nc">String</span> <span class="nf">head</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">TxtHead</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Article</span> <span class="n">article</span><span class="o">;</span>
  <span class="nc">String</span> <span class="nf">author</span><span class="o">();</span>
  <span class="nc">String</span> <span class="nf">title</span><span class="o">();</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">TxtAuthor</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Head</span> <span class="n">head</span><span class="o">;</span>
  <span class="nc">String</span> <span class="nf">name</span><span class="o">();</span>
  <span class="nc">String</span> <span class="nf">email</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>Here, in order to obtain the name of the author we have to extract the head as a <code class="language-plaintext highlighter-rouge">String</code>, extract the author as a <code class="language-plaintext highlighter-rouge">String</code>, and then extract the name as a <code class="language-plaintext highlighter-rouge">String</code>:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Article</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PgArticle</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">head</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="na">head</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">author</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TxtHead</span><span class="o">(</span><span class="n">head</span><span class="o">).</span><span class="na">author</span><span class="o">();</span>
<span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TxtAuthor</span><span class="o">(</span><span class="n">author</span><span class="o">).</span><span class="na">name</span><span class="o">();</span>
</code></pre></div></div><p>Visually in UML, it looks like this:<p><object data="/uml/930f06f36724929287c1ee82fd95c77b.svg"type="image/svg+xml"class="plantuml"></object><p>There were three interfaces in the first design, while the second one has only one interface and two classes. I call the first one “fat” because it returns interfaces, which already implement the functionality we are looking for, and we don’t need to cover them with additional decorators or adapters. Its hierarchy of <em>three</em> interfaces is rich enough to give us everything we need. That’s why it’s fat. The second one, on other hand is pretty <em>skinny</em>, there is only one interface, which returns us plain text data, which we have to parse on our own. We need to <em>dress it up</em>.<p>It seems that the skinny design is better, for a number of reasons:<ul><li><p><strong>Extendability</strong>. The skinny design is definitely easier to extend. In order to extract some new information from the author we just need to add a new method to the class <code class="language-plaintext highlighter-rouge">TxtAuthor</code>. We don’t need to re-design the entire hierarchy of interfaces and to modify all their implementations. We deal with pure data, which is managed and parsed later, in decorators, adapters, and other supplementary <a href="/2016/04/26/why-inputstream-design-is-wrong.html">smart</a> classes.<li><p><strong>Cohesion</strong>. The skinny design is definitely more cohesive, since everything that is related to the management of PostgreSQL data stays in one class <code class="language-plaintext highlighter-rouge">SqlArticle</code>. To the contrary, the fat design spreads the functionality among many classes and, thanks to that, makes the entire class-set more difficult to maintain.<li><p><strong>Reusability</strong>. Class <code class="language-plaintext highlighter-rouge">TxtAuthor</code> can definitely be used in any other place, where parsing of an author’s information is required, while class <code class="language-plaintext highlighter-rouge">PgAuthor</code> is only suitable for one particular case: fetching and parsing PostgreSQL-related data.<li><p><strong>Testability</strong>. Obviously, the skinny design is much easier to test, because mocking a single interface is a much simpler task than mocking the entire hierarchy. To test the class <code class="language-plaintext highlighter-rouge">TxtAuthor</code> we just pass some fake text to its constructor and check how it works. To test the class <code class="language-plaintext highlighter-rouge">PgAuthor</code> we would need to do much more, including running a fake instance of a PostgreSQL server.</ul><p>Everything said above is true for both 1) from-PostgreSQL data retrievals and 2) to-PostgreSQL data manipulations. Of course, manipulations may require many methods to exist in <code class="language-plaintext highlighter-rouge">SqlArticle</code>, which will make the skinny design look ugly, and it will become obvious that some of these methods have to be moved to lower-level classes/interfaces. This only demonstrates that it’s not always possible to make skinny design with a single interface, like in the example above. Sometimes we simply <em>have</em> to make it more fat.<p>However, there is one serious concern related to the skinny design: it lets the raw <a href="/2016/11/21/naked-data.html">naked</a> data jump out of <code class="language-plaintext highlighter-rouge">SqlArticle</code>, which is against the very idea of object-oriented programming, as <a href="/2016/11/21/naked-data.html">we know</a>. Indeed, if we let <code class="language-plaintext highlighter-rouge">TxtHead</code> do the parsing, we may lose some interesting PostgreSQL-related context, which is available only inside <code class="language-plaintext highlighter-rouge">SqlArticle</code>. We don’t want complex data parsing to happen far away from the place where the data is born. We want everything data-related to happen where the data lives: inside <code class="language-plaintext highlighter-rouge">SqlArticle</code>.<p>This is a valid concern, but letting PostgreSQL-related information (like connection settings) move from <code class="language-plaintext highlighter-rouge">PgArticle</code> to <code class="language-plaintext highlighter-rouge">PgHead</code> and then to <code class="language-plaintext highlighter-rouge">PgAuthor</code> is an even larger violation of the data encapsulation principle.<p>In real-life situations, of course, it’s not possible to imagine pure one-interface skinny designs. They will all be fat to some extent. My suggestion, though, is to try to make designs less fat, letting interface users dress them up however they like. This suggestion is very close to what I said earlier about <a href="/2016/04/26/why-inputstream-design-is-wrong.html">smart classes</a>, but this time the principle is broader.</article>