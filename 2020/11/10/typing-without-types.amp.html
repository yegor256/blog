<!DOCTYPE html>
<html amp lang="en">
  <head>

    <meta charset="utf-8">
    <title>Strong Typing without Types</title>
    <link rel="canonical" href="https://www.yegor256.com/2020/11/10/typing-without-types.html">
    <link rel="icon" type="image/png" href="/favicon.ico">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2020/11/10/typing-without-types.html"
        },
        "headline": "Strong Typing without Types",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2020/11/redirected.jpg",
          "height": 1068,
          "width": 2546
        },
        "datePublished": "2020-11-10",
        "dateModified": "2020-11-10",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Strong typing is a powerful instrument to prevent
type errors in OOP, but do we really need explicitly
defined types to enable it?
",
        "keywords": ["types", "typing", "strong typing", "strong vs weak typing", "type system oop"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500">
    <style amp-custom="amp-custom">
      @font-face {
        font-family: 'Cambria';
        src: url('https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf');
      }
      body { font-family: 'Cambria', 'Times New Roman', serif; padding: .5em; font-size: 1.2em; }
      article { width: 600px; max-width: 100%; margin-left: auto; margin-right: auto; }
      pre, code { font-family: 'Source Code Pro', 'Courier New', monospace; font-size: .8em; }
      code { padding: 0 .3em; background-color: lightgray; }
      a, a:hover, a:visited { color: inherit; }
      .intro { color: red; font-size: .75em; }
      .photo { border-radius: 50%; }
      pre { overflow-x:scroll; }
    </style>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <article>
      <p class="intro">
        This is a mobile version, full one is
        <a href="https://www.yegor256.com/2020/11/10/typing-without-types.html">here</a>.
      </p>
      <p>
        <amp-img src="/images/face-256x256.jpg" width="80" height="80" alt="Yegor Bugayenko" class="photo"></amp-img>
      </p>
      <p>Yegor Bugayenko<br>10 November 2020</p>
      <h1>Strong Typing without Types</h1>
      <p>In 1974, Liskov and Zilles <a href="https://dl.acm.org/doi/abs/10.1145/942572.807045">defined</a>
a <a href="https://en.wikipedia.org/wiki/Strong_and_weak_typing">strongly-typed</a>
language as one in which “whenever an object is passed from
a calling function to a called function, its type must be
compatible with the type declared in the called function.”
Strong <a href="https://en.wikipedia.org/wiki/Type_system">type checking</a>,
without doubt, decreases the amount of
<a href="https://en.wikipedia.org/wiki/Type_system#Type_errors">type errors</a>,
which leads to higher quality. However, the question is:
do we really need types in order to strongly enforce typing?</p>



<amp-img src="/images/2020/11/redirected.jpg" alt="Redirected (2014) by Emilis Velyvis" height="1068" width="2546" layout="responsive"></amp-img>

<p>For example, this is a place where we expect an instance of
Java <a href="https://docs.oracle.com/javase/tutorial/java/concepts/interface.html">interface</a>
<code class="highlighter-rouge">Book</code> to arrive:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">Book</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span>
    <span class="s">"The ISBN is: %s%n"</span><span class="o">,</span> <span class="n">b</span><span class="o">.</span><span class="na">isbn</span><span class="o">()</span>
  <span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The type <code class="highlighter-rouge">Book</code> may look like this:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Book</span> <span class="o">{</span>
  <span class="nc">String</span> <span class="nf">isbn</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>If an object that doesn’t <code class="highlighter-rouge">implement</code> the interface <code class="highlighter-rouge">Book</code> is passed
to the method <code class="highlighter-rouge">print()</code>, the compiler will complain
with the “type mismatch” error. It will be hard for a programmer to make
a mistake and pass an object of type, say, <code class="highlighter-rouge">Car</code> to the method <code class="highlighter-rouge">print()</code>.
However, it will still be possible, via dynamic type casting:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Car</span> <span class="n">car</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Car</span><span class="o">(</span><span class="s">"Mercedes-Benz G63"</span><span class="o">);</span>
<span class="n">print</span><span class="o">(</span><span class="nc">Book</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">cast</span><span class="o">(</span><span class="n">car</span><span class="o">));</span> <span class="c1">// Here!</span>
</code></pre></div></div>

<p>This code will compile without issues, but at runtime the
<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/ClassCastException.html"><code class="highlighter-rouge">ClassCastException</code></a>
will be thrown, since it won’t be
possible to cast <code class="highlighter-rouge">Car</code> to <code class="highlighter-rouge">Book</code>.</p>

<p>The beauty of strong typing is that it prevents errors. However, it increases
the complexity of code: you need to create types first, you need to declare them
in all your functions, you need type casting, which is hard to debug, and so on.
Weak typing <a href="https://softwareengineering.stackexchange.com/questions/38002">proponents</a>
complain about this a lot and create languages like Ruby,
which don’t have types at all, for example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
  <span class="nb">puts</span><span class="p">(</span><span class="nb">format</span><span class="p">(</span><span class="s2">"This is ISBN: %s"</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="nf">isbn</span><span class="p">))</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Here, the function <code class="highlighter-rouge">print()</code> doesn’t expect <code class="highlighter-rouge">b</code> to be of any
particular type. Whatever comes in—is fine. Later, when it’s
time to call <code class="highlighter-rouge">.isbn</code> the runtime checks whether the
incoming <code class="highlighter-rouge">b</code> has such a method. If it does, everything works just fine,
if it doesn’t, a runtime error <a href="https://ruby-doc.org/core-2.5.0/NoMethodError.html"><code class="highlighter-rouge">NoMethodError</code></a>
is raised.</p>

<p>So far so good.</p>

<p>However, here is the idea: what if we combine the simplicity and brevity
of dynamic typing with the safety of strong typing by getting
rid of types all together and letting the compiler infer type
information from the code that works with the objects? Here is our
code again:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">print</span><span class="o">(</span><span class="nc">Book</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span>
    <span class="s">"The ISBN is: %s%n"</span><span class="o">,</span> <span class="n">b</span><span class="o">.</span><span class="na">isbn</span><span class="o">()</span>
  <span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Think about this: at compile time it’s already obvious that <code class="highlighter-rouge">b</code> must have
<em>at least</em> one method <code class="highlighter-rouge">isbn()</code>. No need to force programmers to define
the type <code class="highlighter-rouge">Book</code> explicitly and mention in the signature of the method <code class="highlighter-rouge">print()</code>
that only books are welcome: this knowledge can easily be inferred from
the body of the method <code class="highlighter-rouge">print()</code>! The compiler may look at all statements
in the method <code class="highlighter-rouge">print()</code> and clearly <em>understand</em> what exactly will be done
with the object <code class="highlighter-rouge">b</code>. This information should be enough to visualize
the “type” of the incoming object. No need to ask the programmer to
do this explicitly and spend another five lines of code in a new file
to declare the type <code class="highlighter-rouge">Book</code>. The compiler can do this job for us.</p>

<p>Of course, to make this work we must prohibit
<a href="/2015/04/02/class-casting-is-anti-pattern.html">type casting</a>
of any kind, which is not possible in Java, C++, C# and other
pseudo-object-oriented languages. But it is possible in
<a href="https://www.eolang.org">EO</a>!</p>

<p>WDYT?</p>

    </article>
  </body>
</html>
