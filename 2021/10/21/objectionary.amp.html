<!DOCTYPE html>
<html amp lang="en">
  <head>

    <meta charset="utf-8">
    <title>Objectionary: Dictionary and Factory for EO Objects</title>
    <link rel="canonical" href="https://www.yegor256.com/2021/10/21/objectionary.html">
    <link rel="icon" type="image/png" href="/favicon.ico">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2021/10/21/objectionary.html"
        },
        "headline": "Objectionary: Dictionary and Factory for EO Objects",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2021/10/maend-and-hons.jpg",
          "height": 1214,
          "width": 1821
        },
        "datePublished": "2021-10-21",
        "dateModified": "2021-10-21",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "It is a platform-independent object repository, which
hosts source code and validates its consistency on each
modification.
",
        "keywords": ["oop", "object-oriented programming", "oop repository", "object repository", "storage of objects"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500">
    <style amp-custom="amp-custom">
      @font-face {
        font-family: 'Cambria';
        src: url('https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf');
      }
      body { font-family: 'Cambria', 'Times New Roman', serif; padding: .5em; font-size: 1.2em; }
      article { width: 600px; max-width: 100%; margin-left: auto; margin-right: auto; }
      pre, code { font-family: 'Source Code Pro', 'Courier New', monospace; font-size: .8em; }
      code { padding: 0 .3em; background-color: lightgray; }
      a, a:hover, a:visited { color: inherit; }
      .intro { color: red; font-size: .75em; }
      .photo { border-radius: 50%; }
      pre { overflow-x:scroll; }
    </style>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <article>
      <p class="intro">
        This is a mobile version, full one is
        <a href="https://www.yegor256.com/2021/10/21/objectionary.html">here</a>.
      </p>
      <p>
        <amp-img src="/images/face-256x256.jpg" width="80" height="80" alt="Yegor Bugayenko" class="photo"></amp-img>
      </p>
      <p>Yegor Bugayenko<br>21 October 2021</p>
      <h1>Objectionary: Dictionary and Factory for EO Objects</h1>
      

<p>Since the time of Kernighan and Ritchie we share binary code in
libraries. You need to print some text with <a href="https://en.wikipedia.org/wiki/Printf_format_string"><code class="language-plaintext highlighter-rouge">printf()</code></a> in C++?
You get <a href="https://en.wikipedia.org/wiki/Glibc">libc</a> library with
<a href="https://stackoverflow.com/a/33188344/187141">700+</a> other functions inside.
You need to copy a Java stream?
You get <a href="https://commons.apache.org/proper/commons-io/">Apache Commons IO</a> with
<a href="https://commons.apache.org/proper/commons-io/apidocs/org/apache/commons/io/IOUtils.html#copy-java.io.InputStream-java.io.OutputStream-"><code class="language-plaintext highlighter-rouge">copy()</code></a> and
<a href="https://commons.apache.org/proper/commons-io/apidocs/index.html">140+</a>
other methods and classes.
The same happens in all languages I‚Äôm aware of, like Ruby, Python, JavaScript, PHP:
you need an object, or a class, or a function, or a method‚Äîyou have to add
the entire library to your build.
Wouldn‚Äôt it be more elegant to deal with individual objects instead?</p>



<amp-img src="/images/2021/10/maend-and-hons.jpg" alt="M√¶nd &amp;amp; h√∏ns (2015) by Anders Thomas Jensen" height="1214" width="1821" layout="responsive"></amp-img>

<p>The idea is not new and not mine.
I got it from the book <a href="https://amzn.to/266oJr4">Object Thinking</a>
by David West, where he suggested creating an <em>Objectionary</em> (page 306),
a ‚Äúcombination of dictionary and object factory,‚Äù with the following properties:</p>

<ul>
  <li>The total number of objects is less than 2000;</li>
  <li>Each object is an autonomous executable entity;</li>
  <li>Every object has a unique ID and a unique ‚Äúaddress‚Äù;</li>
  <li>Objects are nothing more than collections of objects;</li>
  <li>Objects require hardware-specific VMs for execution.</li>
</ul>



<p>Seventeen years later (the book was published in 2004), we implemented the idea
on top of <a href="https://www.eolang.org">EO</a>, our new programming language.
The language is intentionally much simpler than Java or C++.
You can read its more or less formal description
<a href="https://arxiv.org/abs/2111.13384">here</a>.</p>

<p>To turn an EO program into an executable entity and release it to
the <a href="https://www.objectionary.com">Objectionary</a>,
one has to go through the following mandatory steps,
assuming the JVM is used as a target platform
(the steps marked with üåµ are implemented by our
<a href="https://github.com/cqfn/eo">eo-maven-plugin</a>):</p>

<ul>
  <li>
<strong>Assemble</strong>üåµ:
    <ul>
      <li>
<strong>Parse</strong>üåµ: <code class="language-plaintext highlighter-rouge">.eo</code> ‚ûú <code class="language-plaintext highlighter-rouge">.xmir</code>
</li>
      <li>
<strong>Optimize</strong>üåµ: <code class="language-plaintext highlighter-rouge">.xmir</code> ‚ûú better <code class="language-plaintext highlighter-rouge">.xmir</code>
</li>
      <li>
<strong>Discover</strong>üåµ: find all foreign aliases</li>
      <li>
<strong>Pull</strong>üåµ: <a href="https://github.com/yegor256/objectionary">download</a> foreign <code class="language-plaintext highlighter-rouge">.eo</code> objects</li>
      <li>
<strong>Resolve</strong>üåµ: <a href="https://search.maven.org/">download</a> and unpack <code class="language-plaintext highlighter-rouge">.jar</code> artifacts</li>
      <li>
<strong>Place</strong>üåµ: move artifact <code class="language-plaintext highlighter-rouge">.class</code> files to <code class="language-plaintext highlighter-rouge">target/classes/</code>
</li>
      <li>
<strong>Mark</strong>üåµ: mark <code class="language-plaintext highlighter-rouge">.eo</code> sources found in <code class="language-plaintext highlighter-rouge">.jar</code> as foreign</li>
      <li>‚Üë Go back to <strong>Parse</strong> if some <code class="language-plaintext highlighter-rouge">.eo</code> files are still not parsed</li>
    </ul>
  </li>
  <li>
<strong>Transpile</strong>üåµ: <code class="language-plaintext highlighter-rouge">.xmir</code> ‚ûú <code class="language-plaintext highlighter-rouge">.java</code>
</li>
  <li>
<strong>Assemble</strong>üåµ: same as above, but for tests</li>
  <li>
<strong>Compile</strong>: <code class="language-plaintext highlighter-rouge">.java</code> ‚ûú <code class="language-plaintext highlighter-rouge">.class</code>
</li>
  <li>
<strong>Test</strong>: run all unit tests</li>
  <li>
<strong>Unplace</strong>üåµ: remove artifact <code class="language-plaintext highlighter-rouge">.class</code> files</li>
  <li>
<strong>Unspile</strong>üåµ: remove auto-generated <code class="language-plaintext highlighter-rouge">.java</code> files</li>
  <li>
<strong>Copy</strong>üåµ: copy <code class="language-plaintext highlighter-rouge">.eo</code> files to <code class="language-plaintext highlighter-rouge">EO-SOURCES/</code> inside <code class="language-plaintext highlighter-rouge">.jar</code>
</li>
  <li>
<strong>Deploy</strong>: package <code class="language-plaintext highlighter-rouge">.jar</code> artifact and put it into Maven Central</li>
  <li>
<strong>Push</strong>: send a pull request to <a href="https://github.com/yegor256/objectionary">yegor256/objectionary</a>
</li>
  <li>
<strong>Merge</strong>: we test and merge the pull request</li>
</ul>

<p>It is an iterative process, which loops over and over
again until all required <code class="language-plaintext highlighter-rouge">.eo</code> objects are parsed and their atoms are present
as <code class="language-plaintext highlighter-rouge">.class</code> files.
Then, all <code class="language-plaintext highlighter-rouge">.xmir</code> files are transpiled to <code class="language-plaintext highlighter-rouge">.java</code> and then compiled
to <code class="language-plaintext highlighter-rouge">.class</code> binaries. Then, tested, packaged, and deployed to Maven Central. Then,
merged to the <code class="language-plaintext highlighter-rouge">master</code> branch of <a href="https://www.objectionary.com">Objectionary</a>,
via a pull request.</p>

<p>The first part of the algorithm can be automated with
<a href="https://github.com/cqfn/eo">our Maven plugin</a>, simply by placing <code class="language-plaintext highlighter-rouge">.eo</code> sources
in <code class="language-plaintext highlighter-rouge">src/main/eo/</code> and adding this to <code class="language-plaintext highlighter-rouge">pom.xml</code>:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;project&gt;</span>
  <span class="nt">&lt;build&gt;</span>
    <span class="nt">&lt;plugins&gt;</span>
      <span class="nt">&lt;plugin&gt;</span>
        <span class="nt">&lt;groupId&gt;</span>org.eolang<span class="nt">&lt;/groupId&gt;</span>
        <span class="nt">&lt;artifactId&gt;</span>eo-maven-plugin<span class="nt">&lt;/artifactId&gt;</span>
        <span class="nt">&lt;version&gt;</span><span class="c">&lt;!-- Take it from Maven Central --&gt;</span><span class="nt">&lt;/version&gt;</span>
        <span class="nt">&lt;executions&gt;</span>
          <span class="nt">&lt;execution&gt;</span>
            <span class="nt">&lt;goals&gt;</span>
              <span class="nt">&lt;goal&gt;</span>register<span class="nt">&lt;/goal&gt;</span>
              <span class="nt">&lt;goal&gt;</span>assemble<span class="nt">&lt;/goal&gt;</span>
              <span class="nt">&lt;goal&gt;</span>transpile<span class="nt">&lt;/goal&gt;</span>
              <span class="nt">&lt;goal&gt;</span>copy<span class="nt">&lt;/goal&gt;</span>
              <span class="nt">&lt;goal&gt;</span>unplace<span class="nt">&lt;/goal&gt;</span>
              <span class="nt">&lt;goal&gt;</span>unspile<span class="nt">&lt;/goal&gt;</span>
            <span class="nt">&lt;/goals&gt;</span>
          <span class="nt">&lt;/execution&gt;</span>
        <span class="nt">&lt;/executions&gt;</span>
      <span class="nt">&lt;/plugin&gt;</span>
    <span class="nt">&lt;/plugins&gt;</span>
    [...]
  <span class="nt">&lt;/build&gt;</span>
  [...]
<span class="nt">&lt;/project&gt;</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">register</code> goal will scan the <code class="language-plaintext highlighter-rouge">src/main/eo/</code> directory, find all
<code class="language-plaintext highlighter-rouge">.eo</code> sources, and ‚Äúregister‚Äù them in a special CSV catalog at
<code class="language-plaintext highlighter-rouge">target/eo-foreigns.csv</code>. Next, the <code class="language-plaintext highlighter-rouge">assemble</code> goal will call
the following goals: <code class="language-plaintext highlighter-rouge">parse</code>, <code class="language-plaintext highlighter-rouge">optimize</code>, <code class="language-plaintext highlighter-rouge">discover</code>, <code class="language-plaintext highlighter-rouge">pull</code>, and
<code class="language-plaintext highlighter-rouge">resolve</code>. All these goals use the CSV catalog when they parse, optimize,
pull and so on.</p>

<p>When all of them are done, <code class="language-plaintext highlighter-rouge">assemble</code> checks the catalog:
do any <code class="language-plaintext highlighter-rouge">.eo</code> files still require parsing? If they do, another
cycle starts, again with parsing. When all <code class="language-plaintext highlighter-rouge">.eo</code> files are parsed,
the goal <code class="language-plaintext highlighter-rouge">transpile</code> is executed, which turns <code class="language-plaintext highlighter-rouge">.xmir</code> files into <code class="language-plaintext highlighter-rouge">.java</code>
and places them into <code class="language-plaintext highlighter-rouge">target/generated-sources</code>. The rest is done by the
standard <a href="https://maven.apache.org/plugins/maven-compiler-plugin/"><code class="language-plaintext highlighter-rouge">maven-compiler-plugin</code></a>.</p>

<p>Let‚Äôs discuss each step in detail.</p>

<h2 id="parse-">Parse üåµ</h2>

<p>Say, this is the <code class="language-plaintext highlighter-rouge">.eo</code> source code at <code class="language-plaintext highlighter-rouge">src/main/eo/hello.eo</code>:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+alias org.eolang.io.stdout
[] &gt; hello
  "Jeff" &gt; user
  stdout &gt; @
    "Hello, %s!"
    user
</code></pre></div></div>

<p>It will be parsed to this XMIR (XML Intermediate Representation):</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;program&gt;</span>
  <span class="nt">&lt;o</span> <span class="na">name=</span><span class="s">"hello"</span> <span class="na">line=</span><span class="s">"1"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;o</span> <span class="na">name=</span><span class="s">"user"</span> <span class="na">data=</span><span class="s">"string"</span> <span class="na">line=</span><span class="s">"2"</span><span class="nt">&gt;</span>Jeff<span class="nt">&lt;/o&gt;</span>
    <span class="nt">&lt;o</span> <span class="na">name=</span><span class="s">"@"</span> <span class="na">base=</span><span class="s">"stdout"</span> <span class="na">line=</span><span class="s">"3"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;o</span> <span class="na">data=</span><span class="s">"string"</span> <span class="na">line=</span><span class="s">"4"</span><span class="nt">&gt;</span>Hello, %s!<span class="nt">&lt;/o&gt;</span>
      <span class="nt">&lt;o</span> <span class="na">base=</span><span class="s">"user"</span> <span class="na">line=</span><span class="s">"5"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/o&gt;</span>
  <span class="nt">&lt;/o&gt;</span>
<span class="nt">&lt;/program&gt;</span>
</code></pre></div></div>

<p>If you wonder what this XML means, read
<a href="https://arxiv.org/abs/2111.13384">this document</a>:
there is a section about XMIR.</p>

<h2 id="optimize-">Optimize üåµ</h2>

<p>At this step the XMIR produced by the parser goes through
many XSL transformations, sometimes getting additional elements and attributes.
Our example XMIR may get a new attribute <code class="language-plaintext highlighter-rouge">@ref</code>, pointing the reference to the
object <code class="language-plaintext highlighter-rouge">user</code> to the line where the object was defined:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;program&gt;</span>
  <span class="nt">&lt;o</span> <span class="na">name=</span><span class="s">"hello"</span> <span class="na">line=</span><span class="s">"1"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;o</span> <span class="na">name=</span><span class="s">"user"</span> <span class="na">data=</span><span class="s">"string"</span> <span class="na">line=</span><span class="s">"2"</span><span class="nt">&gt;</span>Jeff<span class="nt">&lt;/o&gt;</span>
    <span class="nt">&lt;o</span> <span class="na">name=</span><span class="s">"@"</span> <span class="na">base=</span><span class="s">"stdout"</span> <span class="na">line=</span><span class="s">"3"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;o</span> <span class="na">data=</span><span class="s">"string"</span> <span class="na">line=</span><span class="s">"4"</span><span class="nt">&gt;</span>Hello, %s!<span class="nt">&lt;/o&gt;</span>
      <span class="nt">&lt;o</span> <span class="na">base=</span><span class="s">"user"</span> <span class="na">line=</span><span class="s">"5"</span> <span class="na">ref=</span><span class="s">"2"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/o&gt;</span>
  <span class="nt">&lt;/o&gt;</span>
<span class="nt">&lt;/program&gt;</span>
</code></pre></div></div>

<p>Some XSL transformation may check for grammar or semantic errors and
add a new element <code class="language-plaintext highlighter-rouge">&lt;errors/&gt;</code> if something wrong is found. Thus, if parsing
didn‚Äôt find any syntax errors, all other errors will be visible inside
the XMIR document, for example, like this:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;program&gt;</span>
  <span class="nt">&lt;errors&gt;</span>
    <span class="nt">&lt;error</span> <span class="na">line=</span><span class="err">&gt;</span><span class="s">The</span> <span class="err">program</span> <span class="err">has</span> <span class="err">no</span> <span class="err">package&lt;/error</span><span class="nt">&gt;</span>
  <span class="nt">&lt;/errors&gt;</span>
  <span class="nt">&lt;o</span> <span class="na">name=</span><span class="s">"hello"</span> <span class="na">line=</span><span class="s">"1"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;o</span> <span class="na">name=</span><span class="s">"user"</span> <span class="na">data=</span><span class="s">"string"</span> <span class="na">line=</span><span class="s">"2"</span><span class="nt">&gt;</span>Jeff<span class="nt">&lt;/o&gt;</span>
    <span class="nt">&lt;o</span> <span class="na">name=</span><span class="s">"@"</span> <span class="na">base=</span><span class="s">"stdout"</span> <span class="na">line=</span><span class="s">"3"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;o</span> <span class="na">data=</span><span class="s">"string"</span> <span class="na">line=</span><span class="s">"4"</span><span class="nt">&gt;</span>Hello, %s!<span class="nt">&lt;/o&gt;</span>
      <span class="nt">&lt;o</span> <span class="na">base=</span><span class="s">"user"</span> <span class="na">line=</span><span class="s">"5"</span> <span class="na">ref=</span><span class="s">"2"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/o&gt;</span>
  <span class="nt">&lt;/o&gt;</span>
<span class="nt">&lt;/program&gt;</span>
</code></pre></div></div>

<p>By the way, this is not a real error, I just made it up.</p>

<h2 id="discover-">Discover üåµ</h2>

<p>At this step we find out which objects are ‚Äúforeign‚Äù. In our example,
the object <code class="language-plaintext highlighter-rouge">user</code> is not foreign, since it‚Äôs defined in the code we
have in front of us, while the object <code class="language-plaintext highlighter-rouge">stdout</code> is not defined here and
that‚Äôs why is a foreign one.</p>

<p>Going through all <code class="language-plaintext highlighter-rouge">.xmir</code> files we can easily judge which object is foreign just
by looking at their names. Once we see the reference to <code class="language-plaintext highlighter-rouge">org.eolang.io.stdout</code>,
we check the presence of the file <code class="language-plaintext highlighter-rouge">org/eolang/io/stdout.eo</code> in the directory
with all <code class="language-plaintext highlighter-rouge">.eo</code> sources. If the file is absent, we put the object name
into the CSV catalog and claim it to be foreign.</p>

<h2 id="pull">Pull</h2>

<p>Here we simply try to find source code <code class="language-plaintext highlighter-rouge">.eo</code> files for all foreign
objects in Objectionary, by looking at its
<a href="https://github.com/yegor256/objectionary">GitHub repository</a>.
For example, this is where we would find
<a href="https://github.com/yegor256/objectionary/blob/master/objects/org/eolang/io/stdout.eo"><code class="language-plaintext highlighter-rouge">stdout.eo</code></a>.
We find them there and pull to the local disc.</p>

<p>Pay attention, we pull the sources. Not binaries or compiled XMIR
documents, but the sources in <code class="language-plaintext highlighter-rouge">.eo</code> format.</p>

<h2 id="resolve-">Resolve üåµ</h2>

<p>This is what <a href="https://github.com/yegor256/objectionary/blob/master/objects/org/eolang/io/stdout.eo"><code class="language-plaintext highlighter-rouge">stdout.eo</code></a>
may look like, after the pull:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+package org.eolang.io
+rt jvm org.eolang:eo-runtime:0.10.2
[text] &gt; stdout /bool
</code></pre></div></div>

<p>The object is an <em>atom</em>. This means that even though we have its source code,
it‚Äôs not complete without a piece of platform-specific binary code.
An atom is an object implemented by the runtime
platform, where the EO program is executed (also known
as <a href="https://en.wikipedia.org/wiki/Foreign_function_interface">FFI mechanism</a>).
The line that starts with <code class="language-plaintext highlighter-rouge">+rt</code> (runtime) explains where to get the
runtime code. The <code class="language-plaintext highlighter-rouge">jvm</code> part is the name of the runtime.</p>

<p>We go to <a href="https://search.maven.org/">Maven Central</a>, find there the artifact
<a href="https://search.maven.org/artifact/org.eolang/eo-runtime"><code class="language-plaintext highlighter-rouge">org.eolang:eo-runtime:0.10.2</code></a>,
and unpack it (it‚Äôs a zip archive with <code class="language-plaintext highlighter-rouge">.class</code> files after all).</p>

<p>By the way, a program may contain a number of <code class="language-plaintext highlighter-rouge">+rt</code> meta instructions, for example:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+package org.eolang.io
+rt jvm org.eolang:eo-runtime:0.10.2
+rt ruby eo-core:0.5.8
+rt python eo-basics:0.0.3
[text] &gt; stdout /bool
</code></pre></div></div>

<p>Here, three runtime platforms will know where to get the missing code
for the <code class="language-plaintext highlighter-rouge">stdout</code> atom:
EO‚ûùJava will go to <a href="https://search.maven.org/">Maven Central</a> for the JAR artifact,
EO‚ûùRuby will go to <a href="https://rubygems.org/">RubyGems</a>
trying to find the gem by the name <code class="language-plaintext highlighter-rouge">eo-core</code> and version <code class="language-plaintext highlighter-rouge">0.5.8</code>,
while EO‚ûùPython will go to <a href="https://pypi.org/">PyPi</a>
trying to find <code class="language-plaintext highlighter-rouge">eo-basics</code> package with the version <code class="language-plaintext highlighter-rouge">0.0.3</code>.</p>

<h2 id="place-">Place üåµ</h2>

<p>Next we place all <code class="language-plaintext highlighter-rouge">.class</code> files found in the unpacked JAR,
into the <code class="language-plaintext highlighter-rouge">target/classes</code> directory. We do this in order
to help Maven Compiler Plugin find them in classpath.</p>

<h2 id="mark-">Mark üåµ</h2>

<p>In each JAR file that arrives we can find <code class="language-plaintext highlighter-rouge">.eo</code> sources. They are the programs
this JAR file has had in classpath while it was built. We consider them
as foreign objects too and add to the CSV catalog.</p>

<h2 id="transpile-">Transpile üåµ</h2>

<p>When all foreign objects which are registered in the catalog are downloaded,
compiled, and optimized, we are ready to start
<a href="https://en.wikipedia.org/wiki/Source-to-source_compiler"><em>transpiling</em></a>.
Instead of compiling XMIR directly to Bytecode, we transpile it to <code class="language-plaintext highlighter-rouge">.java</code>
and let Java compiler do the job of generating Bytecode.</p>

<p>We believe that there are a few benefits of transpiling to Java vs. compilation to Bytecode:</p>

<ul>
  <li>Output code is easier to read and debug,</li>
  <li>Optimization power of existing compilers is reused,</li>
  <li>Complexity of a transpiler is lower than of a compiler,</li>
  <li>Portability of the output code is higher.</li>
</ul>

<p>We already have two EO‚ûùJava transpilers:
<a href="https://github.com/cqfn/eo">canonical one</a> and
<a href="https://github.com/polystat/hse-transpiler">the one</a> made by <a href="https://www.hse.ru/en/">HSE University</a>.
We also have EO‚ûùPython experimental <a href="https://github.com/polystat/eo2py">transpiler</a>
made by students of <a href="https://innopolis.university/en/">Innopolis University</a>.
Most probably, when you read this article, there will be more transpilers available.</p>

<p>Even though we believe in transpiling, it‚Äôs still possible to create
EO‚ûùBytecode, EO‚ûùLLVM, or EO‚ûùx86 compilers.
You are more than welcome to try!</p>

<h2 id="compile">Compile</h2>

<p>At this step, the standard <a href="https://maven.apache.org/plugins/maven-compiler-plugin/">Maven Compiler Plugin</a>
finds auto-generated <code class="language-plaintext highlighter-rouge">.java</code> files in <code class="language-plaintext highlighter-rouge">target/generated-sources</code>
and turns them into <code class="language-plaintext highlighter-rouge">.class</code> files.</p>

<h2 id="unplace-">Unplace üåµ</h2>

<p>Here, we remove all <code class="language-plaintext highlighter-rouge">.class</code> files unpacked from dependencies. This is
necessary, in order to avoid getting them packaged into the
final JAR.</p>

<p>We do placing and then unplacing simply because Maven Compiler Plugin
<a href="https://stackoverflow.com/questions/3410548">doesn‚Äôt allow</a>
us to extend classpath in runtime. If it would be possible,
we would just download dependencies from Maven Central and add them
to classpath, without unpacking, placing, and then unplacing.</p>

<h2 id="unspile-">Unspile üåµ</h2>

<p>Here, we delete all <code class="language-plaintext highlighter-rouge">.class</code> files from the <code class="language-plaintext highlighter-rouge">target/classes/</code> directory,
which were auto-generated from <code class="language-plaintext highlighter-rouge">.eo</code>. We don‚Äôt want to ship binaries,
which can be generated from <code class="language-plaintext highlighter-rouge">.eo</code> sources. We only want to ship
atoms, which are <code class="language-plaintext highlighter-rouge">.java</code> files originally.</p>

<h2 id="copy-">Copy üåµ</h2>

<p>At this step we take all <code class="language-plaintext highlighter-rouge">.eo</code> sources from <code class="language-plaintext highlighter-rouge">src/main/eo/</code> and copy
them to <code class="language-plaintext highlighter-rouge">target/classes/EO-SOURCES/</code> directory. Later, they will be
packaged together with <code class="language-plaintext highlighter-rouge">.class</code> files into a <code class="language-plaintext highlighter-rouge">.jar</code>, which will be
deployed to Maven Central. While copying, we replace <code class="language-plaintext highlighter-rouge">0.0.0</code> in the
runtime version to the currently deploying version. Take a look
at the file <a href="https://github.com/cqfn/eo/blob/master/eo-runtime/src/main/eo/org/eolang/io/stdout.eo"><code class="language-plaintext highlighter-rouge">stdout.eo</code></a>,
in its source repository:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+package org.eolang.io
+rt jvm org.eolang:eo-runtime:0.0.0
[text] &gt; stdout /bool
</code></pre></div></div>

<p>The version at the <code class="language-plaintext highlighter-rouge">+rt</code> line is <code class="language-plaintext highlighter-rouge">0.0.0</code>. When sources are copied to the
JAR, this text is replaced.</p>

<p>The motivation to ship sources together with binaries is the following.
When atom binaries are compiled from Java to Bytecode, they stay
next to transpiled sources. They are compiled together. Moreover,
unit tests also rely on both atom sources and auto-generated/transpiled
sources. We want future users of the JAR to know what sources we
had in place when the compilation was going on, to maybe let them reproduce
it or at least know what were the surroundings of the binaries they get.</p>

<p>From a more practical standpoint, we need these sources in the JAR
in order to let the <strong>Mark</strong> step understand what objects
are worth pulling next to the atoms resolved.</p>

<h2 id="deploy">Deploy</h2>

<p>Here, we package everything from <code class="language-plaintext highlighter-rouge">target/classes/</code> into a JAR
archive and <a href="/2014/08/19/how-to-release-to-maven-central.html">deploy</a>  it
to Maven Central.</p>

<p>I suggest deploying sources to GitHub Pages too, to let users see
them on the Web. Also, it will be helpful later when we make a pull
request to Objectionary.
Check this <a href="https://github.com/yegor256/eo-files/blob/master/.rultor.yml#L17-L31"><code class="language-plaintext highlighter-rouge">.rultor.yml</code></a>
script in one of my EO libraries, it deploys <code class="language-plaintext highlighter-rouge">.eo</code> sources to GitHub Pages,
substituting <code class="language-plaintext highlighter-rouge">0.0.0</code> version markers in them correctly.</p>

<h2 id="push">Push</h2>

<p>When the deployment is finished and Maven Central updates its CDN servers,
it‚Äôs time to submit a pull request to <a href="https://github.com/yegor256/objectionary">yegor256/objectionary</a>.
The <code class="language-plaintext highlighter-rouge">.eo</code> sources of objects go into <code class="language-plaintext highlighter-rouge">objects/</code> and their unit tests
go into <code class="language-plaintext highlighter-rouge">tests/</code>. Basically, we just copy <code class="language-plaintext highlighter-rouge">src/main/eo/</code> and <code class="language-plaintext highlighter-rouge">src/test/eo</code>
over there. But, stop‚Ä¶ one important detail. In the sources, as was said earlier,
we have <code class="language-plaintext highlighter-rouge">+rt</code> versions set to <code class="language-plaintext highlighter-rouge">0.0.0</code>. Here, when we copy to Objectionary,
versions must be set to real numbers.</p>

<h2 id="merge">Merge</h2>

<p>When the pull request arrives, a GitHub Action pre-configured in the
<a href="https://github.com/yegor256/objectionary">yegor256/objectionary</a> repository
transpiles all <code class="language-plaintext highlighter-rouge">.eo</code> sources to all known platforms and runs all unit tests.
If everything is clean, we review the pull request and decide whether
the objects suggested go along with others already present in the Objectionary.</p>

<p>Once the pull request is merged, the objects become part of the centralized
dictionary of all objects of EO. Take a look at <a href="https://github.com/yegor256/objectionary/pull/2">this pull request</a>,
where a new object was submitted to Objectionary, after its atom was
deployed to Maven Central.</p>

    </article>
  </body>
</html>
