<!DOCTYPE html>
<html amp lang="en">
  <head>

    <meta charset="utf-8">
    <title>Objectionary: Dictionary and Factory for EO Objects</title>
    <link rel="canonical" href="https://www.yegor256.com/2021/10/21/objectionary.html">
    <link rel="icon" type="image/png" href="/favicon.ico">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2021/10/21/objectionary.html"
        },
        "headline": "Objectionary: Dictionary and Factory for EO Objects",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2021/10/maend-and-hons.jpg",
          "height": 1214,
          "width": 1821
        },
        "datePublished": "2021-10-21",
        "dateModified": "2021-10-21",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "It is a platform-independent object repository, which
hosts source code and validates its consistency on each
modification.
",
        "keywords": ["oop", "object-oriented programming", "oop repository", "object repository", "storage of objects"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500">
    <style amp-custom="amp-custom">
      @font-face {
        font-family: 'Cambria';
        src: url('https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf');
      }
      body { font-family: 'Cambria', 'Times New Roman', serif; padding: .5em; font-size: 1.2em; }
      article { width: 600px; max-width: 100%; margin-left: auto; margin-right: auto; }
      pre, code { font-family: 'Source Code Pro', 'Courier New', monospace; font-size: .8em; }
      code { padding: 0 .3em; background-color: lightgray; }
      a, a:hover, a:visited { color: inherit; }
      .intro { color: red; font-size: .75em; }
      .photo { border-radius: 50%; }
      pre { overflow-x:scroll; }
    </style>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <article>
      <p class="intro">
        This is a mobile version, full one is
        <a href="https://www.yegor256.com/2021/10/21/objectionary.html">here</a>.
      </p>
      <p>
        <amp-img src="/images/face-256x256.jpg" width="80" height="80" alt="Yegor Bugayenko" class="photo"></amp-img>
      </p>
      <p>Yegor Bugayenko<br>21 October 2021</p>
      <h1>Objectionary: Dictionary and Factory for EO Objects</h1>
      

<p>Since the time of Kernighan and Ritchie we share binary code in
libraries. You need to print some text with <a href="https://en.wikipedia.org/wiki/Printf_format_string"><code class="highlighter-rouge">printf()</code></a> in C++? 
You get <a href="https://en.wikipedia.org/wiki/Glibc">libc</a> library with
<a href="https://stackoverflow.com/a/33188344/187141">700+</a> other functions inside.
You need to copy a Java stream?
You get <a href="https://commons.apache.org/proper/commons-io/">Apache Commons IO</a> with 
<a href="https://commons.apache.org/proper/commons-io/apidocs/org/apache/commons/io/IOUtils.html#copy-java.io.InputStream-java.io.OutputStream-"><code class="highlighter-rouge">copy()</code></a> and 
<a href="https://commons.apache.org/proper/commons-io/apidocs/index.html">140+</a> 
other methods and classes.
The same happens in all languages I‚Äôm aware of, like Ruby, Python, JavaScript, PHP:
you need an object, or a class, or a function, or a method‚Äîyou have to add
the entire library to your build. 
Wouldn‚Äôt it be more elegant to deal with individual objects instead?</p>



<amp-img src="/images/2021/10/maend-and-hons.jpg" alt="M√¶nd &amp;amp; h√∏ns (2015) by Anders Thomas Jensen" height="1214" width="1821" layout="responsive"></amp-img>

<p>The idea is not new and not mine. 
I got it from the book <a href="http://amzn.to/266oJr4">Object Thinking</a>
by David West, where he suggested creating an <em>Objectionary</em> (page 306), 
a ‚Äúcombination of dictionary and object factory,‚Äù with the following properties:</p>

<ul>
  <li>The total number of objects is less than 2000;</li>
  <li>Each object is an autonomous executable entity;</li>
  <li>Every object has a unique ID and a unique ‚Äúaddress‚Äù;</li>
  <li>Objects are nothing more than collections of objects;</li>
  <li>Objects require hardware-specific VMs for execution.</li>
</ul>



<p>Seventeen years later (the book was published in 2004), we implemented the idea
on top of <a href="https://www.eolang.org">EO</a>, our new programming language.
The language is intentionally much simpler than Java or C++.
You can read its more or less formal description 
<a href="https://arxiv.org/abs/2111.13384">here</a>.</p>

<p>To turn an EO program into an executable entity and release it to 
the <a href="https://www.objectionary.com">Objectionary</a>, 
one has to go through the following mandatory steps,
assuming the JVM is used as a target platform
(the steps marked with üåµ are implemented by our
<a href="https://github.com/cqfn/eo">eo-maven-plugin</a>):</p>

<ul>
  <li>
<strong>Assemble</strong>üåµ:
    <ul>
      <li>
<strong>Parse</strong>üåµ: <code class="highlighter-rouge">.eo</code> ‚ûú <code class="highlighter-rouge">.xmir</code>
</li>
      <li>
<strong>Optimize</strong>üåµ: <code class="highlighter-rouge">.xmir</code> ‚ûú better <code class="highlighter-rouge">.xmir</code>
</li>
      <li>
<strong>Discover</strong>üåµ: find all foreign aliases</li>
      <li>
<strong>Pull</strong>üåµ: <a href="https://github.com/yegor256/objectionary">download</a> foreign <code class="highlighter-rouge">.eo</code> objects</li>
      <li>
<strong>Resolve</strong>üåµ: <a href="https://search.maven.org/">download</a> and unpack <code class="highlighter-rouge">.jar</code> artifacts</li>
      <li>
<strong>Place</strong>üåµ: move artifact <code class="highlighter-rouge">.class</code> files to <code class="highlighter-rouge">target/classes/</code>
</li>
      <li>
<strong>Mark</strong>üåµ: mark <code class="highlighter-rouge">.eo</code> sources found in <code class="highlighter-rouge">.jar</code> as foreign</li>
      <li>‚Üë Go back to <strong>Parse</strong> if some <code class="highlighter-rouge">.eo</code> files are still not parsed</li>
    </ul>
  </li>
  <li>
<strong>Transpile</strong>üåµ: <code class="highlighter-rouge">.xmir</code> ‚ûú <code class="highlighter-rouge">.java</code>
</li>
  <li>
<strong>Assemble</strong>üåµ: same as above, but for tests</li>
  <li>
<strong>Compile</strong>: <code class="highlighter-rouge">.java</code> ‚ûú <code class="highlighter-rouge">.class</code>
</li>
  <li>
<strong>Test</strong>: run all unit tests</li>
  <li>
<strong>Unplace</strong>üåµ: remove artifact <code class="highlighter-rouge">.class</code> files</li>
  <li>
<strong>Unspile</strong>üåµ: remove auto-generated <code class="highlighter-rouge">.java</code> files</li>
  <li>
<strong>Copy</strong>üåµ: copy <code class="highlighter-rouge">.eo</code> files to <code class="highlighter-rouge">EO-SOURCES/</code> inside <code class="highlighter-rouge">.jar</code>
</li>
  <li>
<strong>Deploy</strong>: package <code class="highlighter-rouge">.jar</code> artifact and put it into Maven Central</li>
  <li>
<strong>Push</strong>: send a pull request to <a href="https://github.com/yegor256/objectionary">yegor256/objectionary</a>
</li>
  <li>
<strong>Merge</strong>: we test and merge the pull request</li>
</ul>

<p>It is an iterative process, which loops over and over
again until all required <code class="highlighter-rouge">.eo</code> objects are parsed and their atoms are present
as <code class="highlighter-rouge">.class</code> files. 
Then, all <code class="highlighter-rouge">.xmir</code> files are transpiled to <code class="highlighter-rouge">.java</code> and then compiled
to <code class="highlighter-rouge">.class</code> binaries. Then, tested, packaged, and deployed to Maven Central. Then,
merged to the <code class="highlighter-rouge">master</code> branch of <a href="https://www.objectionary.com">Objectionary</a>, 
via a pull request.</p>

<p>The first part of the algorithm can be automated with 
<a href="https://github.com/cqfn/eo">our Maven plugin</a>, simply by placing <code class="highlighter-rouge">.eo</code> sources
in <code class="highlighter-rouge">src/main/eo/</code> and adding this to <code class="highlighter-rouge">pom.xml</code>:</p>

<pre>&lt;project&gt;
  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.eolang&lt;/groupId&gt;
        &lt;artifactId&gt;eo-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;&lt;!-- Take it from Maven Central --&gt;&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;goals&gt;
              &lt;goal&gt;register&lt;/goal&gt;
              &lt;goal&gt;assemble&lt;/goal&gt;
              &lt;goal&gt;transpile&lt;/goal&gt;
              &lt;goal&gt;copy&lt;/goal&gt;
              &lt;goal&gt;unplace&lt;/goal&gt;
              &lt;goal&gt;unspile&lt;/goal&gt;
            &lt;/goals&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
    [...]
  &lt;/build&gt;
  [...]
&lt;/project&gt;</pre>

<p>The <code class="highlighter-rouge">register</code> goal will scan the <code class="highlighter-rouge">src/main/eo/</code> directory, find all
<code class="highlighter-rouge">.eo</code> sources, and ‚Äúregister‚Äù them in a special CSV catalog at 
<code class="highlighter-rouge">target/eo-foreigns.csv</code>. Next, the <code class="highlighter-rouge">assemble</code> goal will call
the following goals: <code class="highlighter-rouge">parse</code>, <code class="highlighter-rouge">optimize</code>, <code class="highlighter-rouge">discover</code>, <code class="highlighter-rouge">pull</code>, and
<code class="highlighter-rouge">resolve</code>. All these goals use the CSV catalog when they parse, optimize,
pull and so on.</p>

<p>When all of them are done, <code class="highlighter-rouge">assemble</code> checks the catalog: 
do any <code class="highlighter-rouge">.eo</code> files still require parsing? If they do, another
cycle starts, again with parsing. When all <code class="highlighter-rouge">.eo</code> files are parsed,
the goal <code class="highlighter-rouge">transpile</code> is executed, which turns <code class="highlighter-rouge">.xmir</code> files into <code class="highlighter-rouge">.java</code>
and places them into <code class="highlighter-rouge">target/generated-sources</code>. The rest is done by the
standard <a href="https://maven.apache.org/plugins/maven-compiler-plugin/"><code class="highlighter-rouge">maven-compiler-plugin</code></a>.</p>

<p>Let‚Äôs discuss each step in detail.</p>

<h2 id="parse-">Parse üåµ</h2>

<p>Say, this is the <code class="highlighter-rouge">.eo</code> source code at <code class="highlighter-rouge">src/main/eo/hello.eo</code>:</p>

<pre>+alias org.eolang.io.stdout

[] &gt; hello
  "Jeff" &gt; user
  stdout &gt; @
    "Hello, %s!"
    user</pre>

<p>It will be parsed to this XMIR (XML Intermediate Representation):</p>

<pre>&lt;program&gt;
  &lt;o name="hello" line="1"&gt;
    &lt;o name="user" data="string" line="2"&gt;Jeff&lt;/o&gt;
    &lt;o name="@" base="stdout" line="3"&gt;
      &lt;o data="string" line="4"&gt;Hello, %s!&lt;/o&gt;
      &lt;o base="user" line="5"/&gt;
    &lt;/o&gt;
  &lt;/o&gt;
&lt;/program&gt;</pre>

<p>If you wonder what this XML means, read 
<a href="https://arxiv.org/abs/2111.13384">this document</a>:
there is a section about XMIR.</p>

<h2 id="optimize-">Optimize üåµ</h2>

<p>At this step the XMIR produced by the parser goes through 
many XSL transformations, sometimes getting additional elements and attributes.
Our example XMIR may get a new attribute <code class="highlighter-rouge">@ref</code>, pointing the reference to the
object <code class="highlighter-rouge">user</code> to the line where the object was defined:</p>

<pre>&lt;program&gt;
  &lt;o name="hello" line="1"&gt;
    &lt;o name="user" data="string" line="2"&gt;Jeff&lt;/o&gt;
    &lt;o name="@" base="stdout" line="3"&gt;
      &lt;o data="string" line="4"&gt;Hello, %s!&lt;/o&gt;
      &lt;o base="user" line="5" ref="2"/&gt;
    &lt;/o&gt;
  &lt;/o&gt;
&lt;/program&gt;</pre>

<p>Some XSL transformation may check for grammar or semantic errors and
add a new element <code class="highlighter-rouge">&lt;errors/&gt;</code> if something wrong is found. Thus, if parsing
didn‚Äôt find any syntax errors, all other errors will be visible inside
the XMIR document, for example, like this:</p>

<pre>&lt;program&gt;
  &lt;errors&gt;
    &lt;error line=&gt;The program has no package&lt;/error&gt;
  &lt;/errors&gt;
  &lt;o name="hello" line="1"&gt;
    &lt;o name="user" data="string" line="2"&gt;Jeff&lt;/o&gt;
    &lt;o name="@" base="stdout" line="3"&gt;
      &lt;o data="string" line="4"&gt;Hello, %s!&lt;/o&gt;
      &lt;o base="user" line="5" ref="2"/&gt;
    &lt;/o&gt;
  &lt;/o&gt;
&lt;/program&gt;</pre>

<p>By the way, this is not a real error, I just made it up.</p>

<h2 id="discover-">Discover üåµ</h2>

<p>At this step we find out which objects are ‚Äúforeign‚Äù. In our example,
the object <code class="highlighter-rouge">user</code> is not foreign, since it‚Äôs defined in the code we
have in front of us, while the object <code class="highlighter-rouge">stdout</code> is not defined here and
that‚Äôs why is a foreign one.</p>

<p>Going through all <code class="highlighter-rouge">.xmir</code> files we can easily judge which object is foreign just
by looking at their names. Once we see the reference to <code class="highlighter-rouge">org.eolang.io.stdout</code>,
we check the presence of the file <code class="highlighter-rouge">org/eolang/io/stdout.eo</code> in the directory
with all <code class="highlighter-rouge">.eo</code> sources. If the file is absent, we put the object name
into the CSV catalog and claim it to be foreign.</p>

<h2 id="pull">Pull</h2>

<p>Here we simply try to find source code <code class="highlighter-rouge">.eo</code> files for all foreign
objects in Objectionary, by looking at its 
<a href="https://github.com/yegor256/objectionary">GitHub repository</a>. 
For example, this is where we would find
<a href="https://github.com/yegor256/objectionary/blob/master/objects/org/eolang/io/stdout.eo"><code class="highlighter-rouge">stdout.eo</code></a>.
We find them there and pull to the local disc.</p>

<p>Pay attention, we pull the sources. Not binaries or compiled XMIR
documents, but the sources in <code class="highlighter-rouge">.eo</code> format.</p>

<h2 id="resolve-">Resolve üåµ</h2>

<p>This is what <a href="https://github.com/yegor256/objectionary/blob/master/objects/org/eolang/io/stdout.eo"><code class="highlighter-rouge">stdout.eo</code></a>
may look like, after the pull:</p>

<pre>+package org.eolang.io
+rt jvm org.eolang:eo-runtime:0.10.2

[text] &gt; stdout /bool</pre>

<p>The object is an <em>atom</em>. This means that even though we have its source code,
it‚Äôt not complete without a piece of platform-specific binary code.
An atom is an object implemented by the runtime
platform, where the EO program is executed (also known
as <a href="https://en.wikipedia.org/wiki/Foreign_function_interface">FFI mechanism</a>).
The line that starts with <code class="highlighter-rouge">+rt</code> (runtime) explains where to get the
runtime code. The <code class="highlighter-rouge">jvm</code> part is the name of the runtime.</p>

<p>We go to <a href="https://search.maven.org/">Maven Central</a>, find there the artifact 
<a href="https://search.maven.org/artifact/org.eolang/eo-runtime"><code class="highlighter-rouge">org.eolang:eo-runtime:0.10.2</code></a>,
and unpack it (it‚Äôs a zip archive with <code class="highlighter-rouge">.class</code> files after all).</p>

<p>By the way, a program may contain a number of <code class="highlighter-rouge">+rt</code> meta instructions, for example:</p>

<pre>+package org.eolang.io
+rt jvm org.eolang:eo-runtime:0.10.2
+rt ruby eo-core:0.5.8
+rt python eo-basics:0.0.3

[text] &gt; stdout /bool</pre>

<p>Here, three runtime platforms will know where to get the missing code
for the <code class="highlighter-rouge">stdout</code> atom:
EO‚ûùJava will go to <a href="https://search.maven.org/">Maven Central</a> for the JAR artifact,
EO‚ûùRuby will go to <a href="https://rubygems.org/">RubyGems</a> 
trying to find the gem by the name <code class="highlighter-rouge">eo-core</code> and version <code class="highlighter-rouge">0.5.8</code>,
while EO‚ûùPython will go to <a href="https://pypi.org/">PyPi</a> 
trying to find <code class="highlighter-rouge">eo-basics</code> package with the version <code class="highlighter-rouge">0.0.3</code>.</p>

<h2 id="place-">Place üåµ</h2>

<p>Next we place all <code class="highlighter-rouge">.class</code> files found in the unpacked JAR,
into the <code class="highlighter-rouge">target/classes</code> directory. We do this in order 
to help Maven Compiler Plugin find them in classpath.</p>

<h2 id="mark-">Mark üåµ</h2>

<p>In each JAR file that arrives we can find <code class="highlighter-rouge">.eo</code> sources. They are the programs
this JAR file has had in classpath while it was built. We consider them
as foreign objects too and add to the CSV catalog.</p>

<h2 id="transpile-">Transpile üåµ</h2>

<p>When all foreign objects which are registered in the catalog are downloaded,
compiled, and optimized, we are ready to start 
<a href="https://en.wikipedia.org/wiki/Source-to-source_compiler"><em>transpiling</em></a>.
Instead of compiling XMIR directly to Bytecode, we transpile it to <code class="highlighter-rouge">.java</code>
and let Java complier do the job of generating Bytecode.</p>

<p>We believe that there are a few benefits of transpiling to Java vs. compilation to Bytecode:</p>

<ul>
  <li>Output code is easier to read and debug,</li>
  <li>Optimization power of existing compilers is reused,</li>
  <li>Complexity of a transpiler is lower than of a compiler,</li>
  <li>Portability of the output code is higher.</li>
</ul>

<p>We already have two EO‚ûùJava transpilers: 
<a href="https://github.com/cqfn/eo">canonical one</a> and 
<a href="https://github.com/polystat/hse-transpiler">the one</a> made by <a href="https://www.hse.ru/en/">HSE University</a>. 
We also have EO‚ûùPython experimental <a href="https://github.com/polystat/eo2py">transpiler</a> 
made by students of <a href="https://innopolis.university/en/">Innopolis University</a>. 
Most probably, when you read this article, there will be more transpilers available.</p>

<p>Even though we believe in transpiling, it‚Äôs still possible to create 
EO‚ûùBytecode, EO‚ûùLLVM, or EO‚ûùx86 compilers. 
You are more than welcome to try!</p>

<h2 id="compile">Compile</h2>

<p>At this step, the standard <a href="https://maven.apache.org/plugins/maven-compiler-plugin/">Maven Compiler Plugin</a> 
finds auto-generated <code class="highlighter-rouge">.java</code> files in <code class="highlighter-rouge">target/generated-sources</code>
and turns them into <code class="highlighter-rouge">.class</code> files.</p>

<h2 id="unplace-">Unplace üåµ</h2>

<p>Here, we remove all <code class="highlighter-rouge">.class</code> files unpacked from dependencies. This is
necessary, in order to avoid getting them packaged into the 
final JAR.</p>

<p>We do placing and then unplacing simply because Maven Compiler Plugin
<a href="https://stackoverflow.com/questions/3410548">doesn‚Äôt allow</a> 
us to extend classpath in runtime. If it would be possible,
we would just download dependencies from Maven Central and add them
to classpath, without unpacking, placing, and then unplacing.</p>

<h2 id="unspile-">Unspile üåµ</h2>

<p>Here, we delete all <code class="highlighter-rouge">.class</code> files from the <code class="highlighter-rouge">target/classes/</code> directory,
which were auto-generated from <code class="highlighter-rouge">.eo</code>. We don‚Äôt want to ship binaries,
which can be generated from <code class="highlighter-rouge">.eo</code> sources. We only want to ship 
atoms, which are <code class="highlighter-rouge">.java</code> files originally.</p>

<h2 id="copy-">Copy üåµ</h2>

<p>At this step we take all <code class="highlighter-rouge">.eo</code> sources from <code class="highlighter-rouge">src/main/eo/</code> and copy
them to <code class="highlighter-rouge">target/classes/EO-SOURCES/</code> directory. Later, they will be
packaged together with <code class="highlighter-rouge">.class</code> files into a <code class="highlighter-rouge">.jar</code>, which will be
deployed to Maven Central. While copying, we replace <code class="highlighter-rouge">0.0.0</code> in the
runtime version to the currently deploying version. Take a look 
at the file <a href="https://github.com/cqfn/eo/blob/master/eo-runtime/src/main/eo/org/eolang/io/stdout.eo"><code class="highlighter-rouge">stdout.eo</code></a>, 
in its source repository:</p>

<pre>+package org.eolang.io
+rt jvm org.eolang:eo-runtime:0.0.0

[text] &gt; stdout /bool</pre>

<p>The version at the <code class="highlighter-rouge">+rt</code> line is <code class="highlighter-rouge">0.0.0</code>. When sources are copied to the 
JAR, this text is replaced.</p>

<p>The motivation to ship sources together with binaries is the following.
When atom binaries are compiled from Java to Bytecode, they stay
next to transpiled sources. They are compiled together. Moreover,
unit tests also rely on both atom sources and auto-generated/transpiled
sources. We want future users of the JAR to know what sources we
had in place when the compilation was going on, to maybe let them reproduce
it or at least know what were the surroundings of the binaries they get.</p>

<p>From a more practical standpoint, we need these sources in the JAR
in order to let the <strong>Mark</strong> step understand what objects
are worth pulling next to the atoms resolved.</p>

<h2 id="deploy">Deploy</h2>

<p>Here, we package everything from <code class="highlighter-rouge">target/classes/</code> into a JAR
archive and <a href="/2014/08/19/how-to-release-to-maven-central.html">deploy</a>  it
to Maven Central.</p>

<p>I suggest deploying sources to GitHub Pages too, to let users see
them on the Web. Also, it will be helpful later when we make a pull 
request to Objectionary. 
Check this <a href="https://github.com/yegor256/eo-files/blob/master/.rultor.yml#L17-L31"><code class="highlighter-rouge">.rultor.yml</code></a> 
script in one of my EO libraries, it deploys <code class="highlighter-rouge">.eo</code> sources to GitHub Pages,
substituting <code class="highlighter-rouge">0.0.0</code> version markers in them correctly.</p>

<h2 id="push">Push</h2>

<p>When the deployment is finished and Maven Central updates its CDN servers,
it‚Äôs time to submit a pull request to <a href="https://github.com/yegor256/objectionary">yegor256/objectionary</a>.
The <code class="highlighter-rouge">.eo</code> sources of objects go into <code class="highlighter-rouge">objects/</code> and their unit tests
go into <code class="highlighter-rouge">tests/</code>. Basically, we just copy <code class="highlighter-rouge">src/main/eo/</code> and <code class="highlighter-rouge">src/test/eo</code>
over there. But, stop‚Ä¶ one important detail. In the sources, as was said earlier,
we have <code class="highlighter-rouge">+rt</code> versions set to <code class="highlighter-rouge">0.0.0</code>. Here, when we copy to Objectionary,
versions must be set to real numbers.</p>

<h2 id="merge">Merge</h2>

<p>When the pull request arrives, a GitHub Action pre-configured in the
<a href="https://github.com/yegor256/objectionary">yegor256/objectionary</a> repository
transpiles all <code class="highlighter-rouge">.eo</code> sources to all known platforms and runs all unit tests.
If everything is clean, we review the pull request and decide whether
the objects suggested go along with others already present in the Objectionary.</p>

<p>Once the pull request is merged, the objects become part of the centralized
dictionary of all objects of EO. Take a look at <a href="https://github.com/yegor256/objectionary/pull/2">this pull request</a>, 
where a new object was submitted to Objectionary, after its atom was
deployed to Maven Central.</p>


    </article>
  </body>
</html>
