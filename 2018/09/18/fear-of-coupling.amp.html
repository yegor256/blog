<!doctypehtml><html amp lang="en"><meta charset="utf-8"><title>Fear of Decoupling</title><link rel="canonical"href="https://www.yegor256.com/2018/09/18/fear-of-coupling.html"><link rel="icon"type="image/png"href="/favicon.ico"><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><script type="application/ld+json">{
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2018/09/18/fear-of-coupling.html"
        },
        "headline": "Fear of Decoupling",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2018/09/funny-games.jpg",
          "height": 687,
          "width": 1270
        },
        "datePublished": "2018-09-18",
        "dateModified": "2018-09-18",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Most of us are afraid of decoupling objects via interfaces
since it makes their aggregates less predictable and therefore
less stable; it's a mistake.
",
        "keywords": ["interfaces in oop", "loose coupling", "coupling in oop", "coupling in object oriented programming", "coupling vs reliability"]
      }</script><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript><link rel="stylesheet"href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500"><style amp-custom="amp-custom">@font-face{font-family:Cambria;src:url(https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf)}body{font-family:Cambria,'Times New Roman',serif;padding:.5em;font-size:1.2em}article{width:600px;max-width:100%;margin-left:auto;margin-right:auto}code,pre{font-family:'Source Code Pro','Courier New',monospace;font-size:.8em}code{padding:0 .3em;background-color:#d3d3d3}a,a:hover,a:visited{color:inherit}.intro{color:red;font-size:.75em}.photo{border-radius:50%}pre{overflow-x:scroll}</style><script async src="https://cdn.ampproject.org/v0.js"></script><article><p class="intro">This is a mobile version, full one is <a href="https://www.yegor256.com/2018/09/18/fear-of-coupling.html">here</a>.<p><amp-img src="/images/face-256x256.jpg"width="80"height="80"alt="Yegor Bugayenko"class="photo"></amp-img><p>Yegor Bugayenko<br>18 September 2018<h1>Fear of Decoupling</h1><p>Objects talk to each other via their methods. In mainstream programming languages, like Java or C#, an object may have a unique set of methods together with some methods it is forced to have because it <em>implements</em> certain types, also known as <em>interfaces</em>. My experience of speaking with many programmers tells me that most of us are pretty scared of objects that implement too many interface methods. We don’t want to deal with them since they are <em>polymorphic</em> and, because of that, unreliable. It’s a fair fear. Let’s try to analyze where it comes from.</p><amp-img src="/images/2018/09/funny-games.jpg"alt="Funny Games (2007) by Michael Haneke"height="687"width="1270"layout="responsive"></amp-img><p>As usual, let’s start with a simple Java example. Here is an amount of money I’m going to send to a user via, say, the PayPal API:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Money</span> <span class="o">{</span>
  <span class="kt">double</span> <span class="nf">cents</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>Now here I am, the method that sends the money:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">send</span><span class="o">(</span><span class="nc">Money</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
  <span class="kt">double</span> <span class="n">c</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="na">cents</span><span class="o">();</span>
  <span class="c1">// Send them over via the API...</span>
<span class="o">}</span>
</code></pre></div></div><p>These two pieces of code are, as we call it, loosely coupled. The method <code class="language-plaintext highlighter-rouge">send()</code> has no idea which class is provided and how exactly the method <code class="language-plaintext highlighter-rouge">cents()</code> is implemented. Maybe it’s a simple constant object of one dollar:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">OneDollar</span> <span class="kd">implements</span> <span class="nc">Money</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kt">double</span> <span class="nf">cents</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="mf">100.0d</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>Or maybe it’s a way more complex entity that makes a network connection first, in order to fetch the current USD-to-EUR exchange rate, update the database, and then return the result of some calculation:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">EmployeeHourlyRate</span> <span class="kd">implements</span> <span class="nc">Money</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kt">double</span> <span class="nf">cents</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// Fetch the exchange rate;</span>
    <span class="c1">// Update the database;</span>
    <span class="c1">// Calculate the hourly rate;</span>
    <span class="c1">// Return the value.</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>The method <code class="language-plaintext highlighter-rouge">send()</code> doesn’t have the knowledge of what exactly is provided as its first argument. All it can do is hope that the method <code class="language-plaintext highlighter-rouge">cents()</code> will do the work right. What if it doesn’t?<p>If I’m a developer of the method <code class="language-plaintext highlighter-rouge">send()</code> and I’m fully prepared to take the blame for the mistakes my method causes, I do want to know what my collaborators are. And I want to be absolutely sure they work. Not just work, but work exactly how I expect them to. Preferably I would like to write them myself. Ideally I would like to ensure that nobody touches them after I implement them. You get the sarcasm, right?<p>This may sound like a joke, but I have heard this argument many times. They say that “it’s better to be completely sure two pieces work together, instead of relying on the damn polymorphism and then spending hours debugging something I didn’t write.” And they are right, you know. Polymorphism—when a seemingly primitive object of type <code class="language-plaintext highlighter-rouge">Money</code> does whatever it wants, including HTTP requests and SQL <code class="language-plaintext highlighter-rouge">UPDATE</code> queries—doesn’t add reliability to the entire application, does it?<p>No, it doesn’t.<p>Obviously, polymorphism makes the life of the developers of this type <code class="language-plaintext highlighter-rouge">Money</code> and its “ancestors” way simpler, since they don’t have to think about their users much. All they worry about is how to return the <code class="language-plaintext highlighter-rouge">double</code> when <code class="language-plaintext highlighter-rouge">cents()</code> is called. They don’t need to care about speed, potential exceptions, memory usage, and many other things, since the interface doesn’t require that. It only tells them to return the <code class="language-plaintext highlighter-rouge">double</code> and call it a day. Let somebody else worry about everything else. Easy, huh? But that’s a childish and egoistic way of thinking, you may say!<p>Yes, it is.<p>However…<p>You’ve most definitely heard of the <a href="/2015/08/25/fail-fast.html">Fail Fast</a> idea, which, in a nutshell, claims that in order to make an application robust and stable we have to make sure its components are as fragile as possible and as vulnerable as they can be in response to any potential exceptional situation. They have to break whenever they can and let their users deal with the failures. With such a philosophy no object will assume anything good about its counterparts and will always try to escalate problems to higher levels, which eventually will hit the end user who will report them back to the team. The team will fix them all and the entire product will stabilize.<p>If the philosophy is the opposite and every object is trying to deal with problems on its individual micro level, the majority of exceptional situations will never be visible to users, testers, architects and programmers, who are supposed to be dealing with them and finding solutions for them. Thanks to this “careful” mindset of individual objects, the stability and robustness of the entire application will suffer.<p>We can apply the same logic to the “fear of loose coupling.”<p>When we worry about how <code class="language-plaintext highlighter-rouge">Money.cents()</code> works and want to control its behavior, we are doing ourselves and the entire project a big disservice. In the long run we destabilize the product, instead of making it more stable. Some even want to prohibit polymorphism by declaring method <code class="language-plaintext highlighter-rouge">send()</code> this way:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">send</span><span class="o">(</span><span class="nc">EmployeeHourlyRate</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// Now I know that it's not some abstract Money,</span>
  <span class="c1">// but a very specific class EmployeeHourlyRate, which</span>
  <span class="c1">// was implemented by Bobby, a good friend of mine.</span>
<span class="o">}</span>
</code></pre></div></div><p>Here we limit the amount of mistakes our code may have, since we know Bobby, we’ve seen his code, we know how it works and which exceptions to expect. We are safe. Yes, we are. For now. But strategically speaking, by not allowing our software to make all possible mistakes and throw all possible exceptions in all unusual situations, we are seriously limiting its ability to be properly tested and that’s why it’s destabilized.<p>As I <a href="/2017/05/23/unlimited-number-of-bugs.html">mentioned earlier</a>, the only way to increase the quality of software is to find and fix its bugs. The more bugs we fix, the fewer are the bugs that remain hidden and not-fixed-yet. A fear of bugs and our intention to prevent them is only shooting us in the foot.<p>Instead, we should let everybody, not only Bobby, implement <code class="language-plaintext highlighter-rouge">Money</code> and pass those implementations to <code class="language-plaintext highlighter-rouge">send()</code>. Yes, some of them will cause troubles and may even lead to UI-visible failures. But if our management understands the concept of <a href="/2017/12/26/software-quality-formula.html">software quality</a> right, they will <a href="/2014/04/13/bugs-are-welcome.html">not blame</a> us for mistakes. Instead, they will encourage us to find as many of them as possible, reproduce them with automated tests, fix, and re-deploy.<p>Thus, the fear of decoupling is nothing else but Fail Safe.<blockquote class="twitter-tweet"data-lang="en"><p lang="en"dir="ltr">How often do you create interfaces for your classes? <a href="https://twitter.com/hashtag/elegantobjects?src=hash&amp;ref_src=twsrc%5Etfw">#elegantobjects</a> <a href="https://twitter.com/hashtag/oop?src=hash&amp;ref_src=twsrc%5Etfw">#oop</a></p>— Yegor Bugayenko (@yegor256) <a href="https://twitter.com/yegor256/status/1046377815799738368?ref_src=twsrc%5Etfw">September 30, 2018</a></blockquote></article>