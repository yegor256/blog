<!DOCTYPE html>
<html amp lang="en">
  <head>

    <meta charset="utf-8">
    <title>Fluent Interfaces Are Bad for Maintainability</title>
    <link rel="canonical" href="https://www.yegor256.com/2018/03/13/fluent-interfaces.html">
    <link rel="icon" type="image/png" href="/favicon.ico">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2018/03/13/fluent-interfaces.html"
        },
        "headline": "Fluent Interfaces Are Bad for Maintainability",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2018/03/donnie-brasco.jpg",
          "height": 720,
          "width": 1280
        },
        "datePublished": "2018-03-13",
        "dateModified": "2018-03-13",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Fluent interface is a very popular and convenient
design pattern, which, however, makes objects larger
and less maintainable.
",
        "keywords": ["fluent interface", "fluent interface java", "fluent interface is evil", "fluent interfaces are evil", "oop fluent interface"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500">
    <style amp-custom="amp-custom">
      @font-face {
        font-family: 'Cambria';
        src: url('https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf');
      }
      body { font-family: 'Cambria', 'Times New Roman', serif; padding: .5em; font-size: 1.2em; }
      article { width: 600px; max-width: 100%; margin-left: auto; margin-right: auto; }
      pre, code { font-family: 'Source Code Pro', 'Courier New', monospace; font-size: .8em; }
      code { padding: 0 .3em; background-color: lightgray; }
      a, a:hover, a:visited { color: inherit; }
      .intro { color: red; font-size: .75em; }
      .photo { border-radius: 50%; }
      pre { overflow-x:scroll; }
    </style>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <article>
      <p class="intro">
        This is a mobile version, full one is
        <a href="https://www.yegor256.com/2018/03/13/fluent-interfaces.html">here</a>.
      </p>
      <p>
        <amp-img src="/images/face-256x256.jpg" width="80" height="80" alt="Yegor Bugayenko" class="photo"></amp-img>
      </p>
      <p>Yegor Bugayenko<br>13 March 2018</p>
      <h1>Fluent Interfaces Are Bad for Maintainability</h1>
      <p><a href="https://en.wikipedia.org/wiki/Fluent_interface">Fluent interface</a>,
first <a href="https://martinfowler.com/bliki/FluentInterface.html">coined</a>
as a term by Martin Fowler, is a very convenient way of communicating
with objects in OOP. It makes their facades easier to use and understand.
However, it ruins their internal design, making them more difficult
to maintain. A few words were said about that by Marco Pivetta
in his blog post <a href="https://ocramius.github.io/blog/fluent-interfaces-are-evil/">Fluent Interfaces are Evil</a>;
now I will add my few cents.</p>



<amp-img src="/images/2018/03/donnie-brasco.jpg" alt="Donnie Brasco (1997) by Mike Newell" height="720" width="1280" layout="responsive"></amp-img>

<p>Let’s take my own library <a href="https://http.jcabi.com/">jcabi-http</a>,
which I created a few years ago,
when I thought that fluent interfaces were a good thing. Here is how you
use the library to make an HTTP request and validate its output:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">html</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">JdkRequest</span><span class="o">(</span><span class="s">"https://www.google.com"</span><span class="o">)</span>
  <span class="o">.</span><span class="na">method</span><span class="o">(</span><span class="s">"GET"</span><span class="o">)</span>
  <span class="o">.</span><span class="na">fetch</span><span class="o">()</span>
  <span class="o">.</span><span class="na">as</span><span class="o">(</span><span class="nc">RestResponse</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
  <span class="o">.</span><span class="na">assertStatus</span><span class="o">(</span><span class="mi">200</span><span class="o">)</span>
  <span class="o">.</span><span class="na">body</span><span class="o">();</span>
</code></pre></div></div>

<p>This convenient <a href="https://en.wikipedia.org/wiki/Method_chaining">method chaining</a>
makes the code short and obvious, right?
Yes, it does, on the surface. But the <em>internal</em> design of the library’s
classes, including <a href="http://static.javadoc.io/com.jcabi/jcabi-http/1.17.2/com/jcabi/http/request/JdkRequest.html"><code class="language-plaintext highlighter-rouge">JdkRequest</code></a>,
which is the one you see,
is very far from being elegant. The biggest problem is that
they are rather big and it’s <del>difficult</del> impossible
to extend them without making them even bigger.</p>



<p>For example, right now <a href="http://static.javadoc.io/com.jcabi/jcabi-http/1.17.2/com/jcabi/http/request/JdkRequest.html"><code class="language-plaintext highlighter-rouge">JdkRequest</code></a>
has the methods
<a href="http://static.javadoc.io/com.jcabi/jcabi-http/1.17.2/com/jcabi/http/Request.html#method%28java.lang.String%29"><code class="language-plaintext highlighter-rouge">method()</code></a>,
<a href="http://static.javadoc.io/com.jcabi/jcabi-http/1.17.2/com/jcabi/http/Request.html#fetch%28%29"><code class="language-plaintext highlighter-rouge">fetch()</code></a>,
and a few others. What happens when new functionality is required?
The only way to add to it would be to make the class bigger, by adding new methods,
which is how we jeopardize its maintainability.
<a href="https://github.com/jcabi/jcabi-http/pull/142/files">Here</a>,
for example, we added
<a href="http://static.javadoc.io/com.jcabi/jcabi-http/1.17.2/com/jcabi/http/Request.html#multipartBody%28%29"><code class="language-plaintext highlighter-rouge">multipartBody()</code></a>
and <a href="https://github.com/jcabi/jcabi-http/pull/99/files">here</a> we added
<a href="http://static.javadoc.io/com.jcabi/jcabi-http/1.17.2/com/jcabi/http/Request.html#timeout%28int,%20int%29">timeout()</a>.</p>

<p>I always feel scared when I get a new feature request in jcabi-http.
I understand that it most probably means adding new methods to
<a href="http://static.javadoc.io/com.jcabi/jcabi-http/1.17.2/com/jcabi/http/Request.html"><code class="language-plaintext highlighter-rouge">Request</code></a>,
<a href="http://static.javadoc.io/com.jcabi/jcabi-http/1.17.2/com/jcabi/http/Response.html"><code class="language-plaintext highlighter-rouge">Response</code></a>,
and other already bloated interfaces and classes.</p>

<p>I actually tried to do something in the library in order to solve this problem
but it wasn’t easy. Look at this
<a href="http://static.javadoc.io/com.jcabi/jcabi-http/1.17.2/com/jcabi/http/Response.html#as%28java.lang.Class%29"><code class="language-plaintext highlighter-rouge">.as(RestResponse.class)</code></a>
method call. What it does is decorate a <code class="language-plaintext highlighter-rouge">Response</code> with
<a href="http://static.javadoc.io/com.jcabi/jcabi-http/1.17.2/com/jcabi/http/response/RestResponse.html"><code class="language-plaintext highlighter-rouge">RestResponse</code></a>,
in order to make it method-richer. I just didn’t want to make
<a href="http://static.javadoc.io/com.jcabi/jcabi-http/1.17.2/com/jcabi/http/Response.html"><code class="language-plaintext highlighter-rouge">Response</code></a>
contain 50+ methods, like many other libraries do. Here is what it
does (this is pseudo-code):</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Response {
  RestResponse as() {
    return new RestResponse(this);
  }
  // Seven methods
}
class RestResponse implements Response {
  private final Response origin;
  // Original seven methods from Response
  // Additional 14 methods
}
</code></pre></div></div>

<p>As you see, instead of adding all possible methods to <code class="language-plaintext highlighter-rouge">Response</code> I
placed them in supplementary decorators
<a href="http://static.javadoc.io/com.jcabi/jcabi-http/1.17.2/com/jcabi/http/response/RestResponse.html"><code class="language-plaintext highlighter-rouge">RestResponse</code></a>,
<a href="http://static.javadoc.io/com.jcabi/jcabi-http/1.17.2/com/jcabi/http/response/JsonResponse.html"><code class="language-plaintext highlighter-rouge">JsonResponse</code></a>,
<a href="http://static.javadoc.io/com.jcabi/jcabi-http/1.17.2/com/jcabi/http/response/JsonResponse.html"><code class="language-plaintext highlighter-rouge">XmlResponse</code></a>,
and
<a href="http://static.javadoc.io/com.jcabi/jcabi-http/1.17.2/com/jcabi/http/response/package-frame.html">others</a>.
It helps, but in order to write these decorators with the central
object of type <code class="language-plaintext highlighter-rouge">Response</code> we have to use that “ugly” method
<a href="http://static.javadoc.io/com.jcabi/jcabi-http/1.17.2/com/jcabi/http/Response.html#as%28java.lang.Class%29"><code class="language-plaintext highlighter-rouge">as()</code></a>,
which depends heavily on Reflection and
<a href="/2015/04/02/class-casting-is-anti-pattern.html">type casting</a>.</p>



<p>In other words, fluent interfaces mean large classes or some ugly workarounds.
I mentioned this problem earlier, when I <a href="/2017/10/10/streams-vs-decorators.html">wrote</a> about
<a href="https://www.oracle.com/technetwork/articles/java/ma14-java-se-8-streams-2177646.html">Streams API</a>
and the interface
<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream</a>,
which is perfectly fluent. There are 43 methods!</p>

<p>That is the biggest problem with fluent interfaces—they <em>force</em> objects to be huge.</p>

<p>Fluent interfaces are perfect for their users, since all methods
are in one place and the amount of classes is very small.
It is easy to use them, especially with
<a href="https://www.jetbrains.com/help/idea/auto-completing-code.html">code auto-completion</a>
in most IDEs. They also make client code more readable, since “fluent” constructs
look similar to plain English (aka <a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL</a>).</p>

<p>That is all true! However, the damage they cause to object design
is the price, which is too high.</p>

<p>What is the alternative?</p>

<p>I would recommend you use decorators and
<a href="/2016/04/26/why-inputstream-design-is-wrong.html">smart objects</a>
instead. Here is how I would design jcabi-http, if I could do it now:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">html</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BodyOfResponse</span><span class="o">(</span>
  <span class="k">new</span> <span class="nf">ResponseAssertStatus</span><span class="o">(</span>
    <span class="k">new</span> <span class="nf">RequestWithMethod</span><span class="o">(</span>
      <span class="k">new</span> <span class="nf">JdkRequest</span><span class="o">(</span><span class="s">"https://www.google.com"</span><span class="o">),</span>
      <span class="s">"GET"</span>
    <span class="o">),</span>
    <span class="mi">200</span>
  <span class="o">)</span>
<span class="o">).</span><span class="na">toString</span><span class="o">();</span>
</code></pre></div></div>

<p>This is the same code as in the first snippet above, but it is much
more object-oriented. The obvious problem with this code, of course, is that
the IDE won’t be able to auto-complete almost anything. Also, we will
have to remember many of the names of the classes. And the construct looks
rather difficult to read for those who are used to fluent interfaces. In addition,
it’s very far away from the DSL idea.</p>



<p>But here is the list of benefits. First, each object is small, very cohesive and
they are all loosely coupled—which are obvious merits in OOP. Second,
adding new functionality to the library is as easy as creating a new class;
no need to touch existing classes. Third, unit testing is simplified,
since classes are small. Fourth, all classes can be immutable, which is also
an <a href="/2014/06/09/objects-should-be-immutable.html">obvious merit</a> in OOP.</p>

<p>Thus, there seems to be a conflict between usefulness and maintainability.
Fluent interfaces are good for users, but bad for library developers. Small
objects are good for developers, but difficult to understand and use.</p>

<p>It seems to be so, but only if you are used to large classes and procedural
programming. To me, a large amount of small classes seems to be an
<a href="/2017/02/28/too-many-classes.html">advantage</a>,
not a drawback. Libraries that are clear, simple, and readable inside
are much easier to use, even when I don’t know exactly which classes out there
are the most suitable for me. Even without the code-auto-complete I can figure
it out myself, because the code is clean.</p>

<p>Also, I very often find myself interested in extending existing functionality
either inside my code base or via a pull request to the library. I am much more
<a href="/2015/12/22/why-dont-you-contribute-to-open-source.html">interested</a>
to do that if I know that the changes I introduce
are isolated and easy to test.</p>

<p>Thus, no fluent interfaces anymore from me, only objects and decorators.</p>

    </article>
  </body>
</html>
