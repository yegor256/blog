<!doctypehtml><html amp lang="en"><meta charset="utf-8"><title>Nine Steps of Learning by Refactoring</title><link rel="canonical"href="https://www.yegor256.com/2018/04/10/learning-by-refactoring.html"><link rel="icon"type="image/png"href="/favicon.ico"><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><script type="application/ld+json">{
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2018/04/10/learning-by-refactoring.html"
        },
        "headline": "Nine Steps of Learning by Refactoring",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2018/04/dom-hemingway.jpg",
          "height": 544,
          "width": 1280
        },
        "datePublished": "2018-04-10",
        "dateModified": "2018-04-10",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "The best way to learn foreign or legacy code is
to refactor it; here is a list of nine steps I go through
when the Java code is new to me.
",
        "keywords": ["refactoring", "learning by refactoring", "refactoring and learning", "refactoring in java", "refactoring benefits"]
      }</script><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript><link rel="stylesheet"href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500"><style amp-custom="amp-custom">@font-face{font-family:Cambria;src:url(https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf)}body{font-family:Cambria,'Times New Roman',serif;padding:.5em;font-size:1.2em}article{width:600px;max-width:100%;margin-left:auto;margin-right:auto}code,pre{font-family:'Source Code Pro','Courier New',monospace;font-size:.8em}code{padding:0 .3em;background-color:#d3d3d3}a,a:hover,a:visited{color:inherit}.intro{color:red;font-size:.75em}.photo{border-radius:50%}pre{overflow-x:scroll}</style><script async src="https://cdn.ampproject.org/v0.js"></script><article><p class="intro">This is a mobile version, full one is <a href="https://www.yegor256.com/2018/04/10/learning-by-refactoring.html">here</a>.<p><amp-img src="/images/face-256x256.jpg"width="80"height="80"alt="Yegor Bugayenko"class="photo"></amp-img><p>Yegor Bugayenko<br>10 April 2018<h1>Nine Steps of Learning by Refactoring</h1><p>I <a href="https://twitter.com/yegor256/status/977799130100781056">was asked</a> on Twitter recently how is it possible to refactor if one doesn’t understand how the code works. I <a href="https://twitter.com/yegor256/status/977966601227112449">replied</a> that it is “learning by refactoring.” Then I tried to Google it and found <a href='https://www.google.ru/search?q="learning+by+refactoring"'>nothing</a>. I was surprised. To me refactoring seems to be the most effective and obvious way to study the source code. Here is how I usually do it, in nine object-oriented steps.</p><amp-img src="/images/2018/04/dom-hemingway.jpg"alt="Dom Hemingway (2013) by Richard Shepard"height="544"width="1280"layout="responsive"></amp-img><p>According to Wikipedia, <a href="https://en.wikipedia.org/wiki/Code_refactoring">code refactoring</a> is “the process of restructuring existing computer code—changing the factoring—without changing its external behavior.” The goal of refactoring is to make code more readable and suitable for modifications.<p>Martin Fowler in his famous book <a href="https://amzn.to/2E7i17H">Refactoring: Improving the Design of Existing Code</a> suggested a number of refactoring techniques which help making code simpler, more abstract, more readable, etc. Some of them are rather <a href="/2014/09/16/getters-and-setters-are-evil.html">questionable</a> from an object-oriented standpoint—like <a href="https://en.wikipedia.org/wiki/Field_encapsulation">Encapsulate Field</a>, for example—but most of them are valid.<p>Here is what I’m usually doing when I don’t know the code, but need to modify it. The techniques are sorted by the order of complexity, starting with the easiest one.<h2 id="remove-ide-red-spots">Remove IDE Red Spots</h2><p>When I open the source code of <a href="https://www.cactoos.org">Cactoos</a> in IntelliJ IDEA, using my custom <a href="/bin/settings.jar"><code class="language-plaintext highlighter-rouge">settings.jar</code></a>, I see something like this:<p>When I open the source code of, say, <a href="https://github.com/spring-projects/spring-boot">Spring Boot</a>, I see something like this (it’s <a href="https://github.com/spring-projects/spring-boot/blob/v2.0.0.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/ImageBanner.java"><code class="language-plaintext highlighter-rouge">o.s.b.ImageBanner</code></a> randomly picked out of a thousand other classes that look very similar):<p>See the difference?<p>The first thing I do, when I see someone else’s code, is to make it “red spots free” for my IDE. Most of those red spots are easy to remove, while others will take some time to refactor. While doing that I learn a lot about the <del>crap</del> program I have to deal with.<h2 id="remove-empty-lines">Remove Empty Lines</h2><p>I <a href="/2014/11/03/empty-line-code-smell.html">wrote</a> some time ago that empty lines inside method bodies are bad things. They are obvious indicators of redundant complexity. Programmers tend to add them to their methods in order to simplify things.<p>This is a method from the <a href="https://github.com/apache/maven">Apache Maven</a> code base (class <a href="https://github.com/apache/maven/blob/maven-3.5.3/maven-core/src/main/java/org/apache/maven/RepositoryUtils.java"><code class="language-plaintext highlighter-rouge">RepositoryUtils</code></a> picked at random, but almost all other classes are formatted the same way):<p>Aside from being “all red” their code is full of empty lines. Removing them will make code more readable and will also help me understand how it works. Bigger methods will need refactoring, since without empty lines they will become almost completely unreadable. Hence, I compress, understand, and make them smaller mostly by breaking them down into smaller methods.<h2 id="make-names-shorter">Make Names Shorter</h2><p>I’m generally in favor of short one-noun names for variables and one-verb names for methods. I <a href="/2015/01/12/compound-name-is-code-smell.html">believe</a> that longer “compound” names are an indicator of unnecessary code complexity.<p>For example, I found this method <code class="language-plaintext highlighter-rouge">registerServletContainerInitializerToDriveServletContextInitializers</code> (69 characters!) in the <a href="https://github.com/spring-projects/spring-boot/blob/v2.0.0.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/web/embedded/undertow/UndertowServletWebServerFactory.java"><code class="language-plaintext highlighter-rouge">o.s.b.w.e.u.UndertowServletWebServerFactory</code></a> class in Spring Boot. I wonder why the author skipped the <code class="language-plaintext highlighter-rouge">couldYouPlease</code> prefix and the <code class="language-plaintext highlighter-rouge">otherwiseThrowAnException</code> suffix.<p>Jokes aside, such long method names clearly demonstrate that the code is too complex and can’t be explained with a simple <code class="language-plaintext highlighter-rouge">register</code> or even <code class="language-plaintext highlighter-rouge">registerContainer</code>. It seems that there are many different containers, initializers, servlets, and other creatures that need to be registered somehow. When I join a project and see a method with this name I’m getting ready for big trouble.<p>Making names shorter is the mandatory refactoring step I take when starting to work with foreign or legacy code.<h2 id="add-unit-tests">Add Unit Tests</h2><p>Most classes (and methods) come without any documentation, especially if we are talking about closed-source commercial code. We are lucky if the classes have more or less descriptive names and are small and cohesive.<p>However, instead of documentation I prefer to deal with unit tests. They explain the code much better and prove that it works. When I don’t understand how the class works, I try to write a unit test for it. In most cases it’s not possible, for many reasons. In such a case I try to apply everything I learned from <a href="https://amzn.to/1SdcZ8M"><em>Working Effectively With Legacy Code</em></a> by Michael Feathers and <a href="https://amzn.to/1PBpoDT"><em>Growing Object-Oriented Software, Guided by Tests</em></a> by Steve Freeman and Nat Pryce. Both books are pretty much focused on this very problem: what to do when you don’t know what to do, testing-wise.<h2 id="remove-multiple-returns">Remove Multiple Returns</h2><p>I <a href="/2015/08/18/multiple-return-statements-in-oop.html">wrote earlier</a> that the presence of multiple <code class="language-plaintext highlighter-rouge">return</code> statements in a single method is not something object-oriented programming should encourage. Instead, a method must always have a single exit point, just like those functions in functional programming.<p>Look at this method from the <a href="https://github.com/spring-projects/spring-boot/blob/v2.0.0.RELEASE/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/context/properties/bind/Binder.java"><code class="language-plaintext highlighter-rouge">o.s.b.c.p.b.Binder</code></a> class from Spring Boot (there are many similar examples there, I picked this one randomly):<p>There are five <code class="language-plaintext highlighter-rouge">return</code> statements in such a small method. For object-oriented code that’s too much. It’s OK for procedural code, which I also write sometimes. For example, this Groovy script has five <code class="language-plaintext highlighter-rouge">return</code> keywords too:<p>But this is Groovy and it’s not a class. It’s just a procedure, a script.<p>Refactoring and removing multiple <code class="language-plaintext highlighter-rouge">return</code> statements definitely helps make code cleaner. Mostly because without them it’s necessary to use deeper nesting of <code class="language-plaintext highlighter-rouge">if/then/else</code> statements and then the code starts to look ugly, unless you break it down into smaller pieces.<h2 id="get-rid-of-nulls">Get Rid of NULLs</h2><p>NULLs <a href="/2014/05/13/why-null-is-bad.html">are evil</a>, it’s a well-known fact. However, they are still everywhere. For example, there are 4,100 Java files in Spring Boot v2.0.0.RELEASE and 243K LoC, which include the <code class="language-plaintext highlighter-rouge">null</code> keyword 7,055 times. This means approximately one <code class="language-plaintext highlighter-rouge">null</code> for every 35 lines.<p>To the contrary, <a href="https://www.takes.org">Takes Framework</a>, which I founded a few years ago, has 771 Java files, 154K LoC, and 58 <code class="language-plaintext highlighter-rouge">null</code> keywords. Which is roughly one <code class="language-plaintext highlighter-rouge">null</code> per 2,700 lines. See the difference?<p>The code gets cleaner when you remove NULLs, but it’s not so easy to do. Sometimes it’s even impossible. That’s why we still have those 58 cases of <code class="language-plaintext highlighter-rouge">null</code> in Takes. We simply can’t remove them, because they are coming from the JDK.<h2 id="make-objects-immutable">Make Objects Immutable</h2><p>As I <a href="/2014/11/07/how-immutability-helps.html">demonstrated</a> some time ago, <a href="/2014/06/09/objects-should-be-immutable.html">immutability</a> helps keep objects smaller. Most classes that I see in the foreign code I deal with are mutable. And large.<p>If you look at any artifact analyzed by <a href="https://www.jpeek.org">jpeek</a>, you will see that in most of them approximately 80% of classes are mutable. Moving from mutability to immutability is a big challenge in object-oriented programming, which, if resolved, leads to better code.<p>This refactoring step of make things immutable is purely profitable.<h2 id="remove-static">Remove Static</h2><p>Static methods and attributes are convenient, if you are a procedural programmer. If your code is object-oriented, they <a href="/2014/05/05/oop-alternative-to-utility-classes.html">must go away</a>. In Spring Boot there are 7,482 <code class="language-plaintext highlighter-rouge">static</code> keywords, which means one for every 32 lines of code. To the contrary, in Takes we have 310 <code class="language-plaintext highlighter-rouge">static</code>-s, which is one every 496 lines.<p>Compare these numbers with the statistics about NULL and you will see that getting rid of <code class="language-plaintext highlighter-rouge">static</code> is a more complex task.<h2 id="apply-static-analysis">Apply Static Analysis</h2><p>This is the final step and the most complex one. It’s complex because I configure static analyzers to their maximum potential or even more. I’m using <a href="https://www.qulice.com">Qulice</a>, which is an aggregator of <a href="http://checkstyle.sourceforge.net/">Checkstyle</a>, <a href="http://pmd.sourceforge.net/">PMD</a>, and <a href="http://findbugs.sourceforge.net/">FindBugs</a>. Those guys are strong by themselves, but Qulice makes them <a href="/2014/08/13/strict-code-quality-control.html">even stronger</a>, adding a few dozen custom-made checks.<p>The principle I use for static analysis is 0/100. This means that either the entire code base is clean and there are no Qulice complaints, or it’s dirty. There is nothing in the middle. This is not a very typical way of looking at static analysis. Most programmers are using those tools just to collect “opinions” about their code. I’m using them as guides for refactoring.<p>Check out this video, which demonstrates the amount of complaints Qulice gives for the <code class="language-plaintext highlighter-rouge">spring-boot-project/spring-boot</code> sub-module in Spring Boot (the video has no end, since I lost my patience in waiting):<p>When Qulice says that everything is clean, I consider the code base fully ready for maintenance and modifications. At this point the refactoring is done.</article>