<!doctypehtml><html amp lang="en"><meta charset="utf-8"><title>The Educational Aspect of Static Analysis</title><link rel="canonical"href="https://www.yegor256.com/2018/01/16/educational-aspect-of-static-analysis.html"><link rel="icon"type="image/png"href="/favicon.ico"><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><script type="application/ld+json">{
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2018/01/16/educational-aspect-of-static-analysis.html"
        },
        "headline": "The Educational Aspect of Static Analysis",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2018/01/blind-fury.jpg",
          "height": 709,
          "width": 1280
        },
        "datePublished": "2018-01-16",
        "dateModified": "2018-01-16",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Static analysis, if done manually, may seriously improve
programmer's skills; auto-formatting tools are lacking
that aspect and don't help us on the long run.
",
        "keywords": ["static analysis", "teaching by static analysis", "code auto-formatting", "auto-formatting", "java static analysis"]
      }</script><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript><link rel="stylesheet"href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500"><style amp-custom="amp-custom">@font-face{font-family:Cambria;src:url(https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf)}body{font-family:Cambria,'Times New Roman',serif;padding:.5em;font-size:1.2em}article{width:600px;max-width:100%;margin-left:auto;margin-right:auto}code,pre{font-family:'Source Code Pro','Courier New',monospace;font-size:.8em}code{padding:0 .3em;background-color:#d3d3d3}a,a:hover,a:visited{color:inherit}.intro{color:red;font-size:.75em}.photo{border-radius:50%}pre{overflow-x:scroll}</style><script async src="https://cdn.ampproject.org/v0.js"></script><article><p class="intro">This is a mobile version, full one is <a href="https://www.yegor256.com/2018/01/16/educational-aspect-of-static-analysis.html">here</a>.<p><amp-img src="/images/face-256x256.jpg"width="80"height="80"alt="Yegor Bugayenko"class="photo"></amp-img><p>Yegor Bugayenko<br>16 January 2018<h1>The Educational Aspect of Static Analysis</h1><p><a href="https://github.com/yegor256/cactoos/issues/544">Very often</a> new programmers who join our projects ask us whether we have auto-formatting instruments to make Java code look exactly the way <a href="/2014/08/13/strict-code-quality-control.html">Qulice</a> expects. (Qulice is the static analyzer we use.) I always reply that having such an automated code polisher would only be harmful and wouldn’t help the project and its members improve and grow. Here is why I think so.</p><amp-img src="/images/2018/01/blind-fury.jpg"alt="Blind Fury (1989) by Phillip Noyce"height="709"width="1280"layout="responsive"></amp-img><p>Static analysis, the way we do it in combination with <a href="/2014/07/21/read-only-master-branch.html">read-only master branch</a>, is a fully automated uncompromising review of your pull request, mostly intended to spot code formatting mistakes. Say we want Java code in our entire repository to look like this:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="nc">Doc</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">File</span> <span class="n">file</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">file</span><span class="o">.</span><span class="na">exists</span><span class="o">())</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">file</span><span class="o">.</span><span class="na">delete</span><span class="o">();</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>However, you refactor it as part of a bigger task, and submit a pull request like this:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Doc</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">File</span> <span class="n">f</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">()</span>
  <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="na">exists</span><span class="o">())</span>
      <span class="n">f</span><span class="o">.</span><span class="na">delete</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>For some of you this may not seem like a big difference, since both code snippets compile without issues and work exactly the same way. However, for us, the repository maintainers, it is a big deal. We do want our classes to always be <code class="language-plaintext highlighter-rouge">final</code>, we do want them to be immutable (so all attributes should also be <code class="language-plaintext highlighter-rouge">final</code>), we want to prefix all attribute references with <code class="language-plaintext highlighter-rouge">this.</code>, and we want the code to be formatted the same way, since we believe that the uniformity of the code seriously increases its maintainability.<p>Of course, we could create a tool which you could then use to re-format the code, to make it look the way we want. But in that case you would never <em>learn</em> what the project wants from you and <em>why</em>.<p>You will not know the reasoning behind our rules. You will never think about them. You will not really care about them. But they are not only about the formatting of spaces and brackets. There are <a href="/2014/07/21/read-only-master-branch.html">over 900</a> of them in <a href="https://www.qulice.com">Qulice</a> and some of them were designed especially for the object-oriented philosophy <a href="https://www.elegantobjects.org">we</a> are preaching.<p>Thus, simply put, we don’t want you to go through the static analysis phase easily. We want you to suffer in order to learn.</article>