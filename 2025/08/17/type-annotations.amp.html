<!doctypehtml><html amp lang="en"><meta charset="utf-8"><title>The End of Type Annotations</title><link rel="canonical"href="https://www.yegor256.com/2025/08/17/type-annotations.html"><link rel="icon"type="image/png"href="/favicon.ico"><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><script type="application/ld+json">{
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2025/08/17/type-annotations.html"
        },
        "headline": "The End of Type Annotations",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2025/08/swingers.jpg",
          "height": 688,
          "width": 1280
        },
        "datePublished": "2025-08-17",
        "dateModified": "2025-08-17",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Type annotations are a workaround for compiler limitations,
not a feature—a well-designed language should infer all types automatically,
forcing programmers to write smaller, cleaner modules.
",
        "keywords": ["types in oop", "types in object-oriented programming", "oop abstract types", "type inference", "infer types"]
      }</script><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript><link rel="stylesheet"href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500"><style amp-custom="amp-custom">@font-face{font-family:Cambria;src:url(https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf)}body{font-family:Cambria,'Times New Roman',serif;padding:.5em;font-size:1.2em}article{width:600px;max-width:100%;margin-left:auto;margin-right:auto}code,pre{font-family:'Source Code Pro','Courier New',monospace;font-size:.8em}code{padding:0 .3em;background-color:#d3d3d3}a,a:hover,a:visited{color:inherit}.intro{color:red;font-size:.75em}.photo{border-radius:50%}pre{overflow-x:scroll}</style><script async src="https://cdn.ampproject.org/v0.js"></script><article><p class="intro">This is a mobile version, full one is <a href="https://www.yegor256.com/2025/08/17/type-annotations.html">here</a>.<p><amp-img src="/images/face-256x256.jpg"width="80"height="80"alt="Yegor Bugayenko"class="photo"></amp-img><p>Yegor Bugayenko<br>17 August 2025<h1>The End of Type Annotations</h1><p>Type annotations are what make statically typed object-oriented languages like Java run <strong>faster</strong> and <strong>safer</strong>. Without annotations, every variable would effectively collapse to <code class="language-plaintext highlighter-rouge">Object</code>, forcing runtime casts. The code would work, but slower and with more runtime errors. Some type annotations may be inferred instead of being explicitly specified by a programmer. Not all though. In Java, for example, a number of hard-to-resolve challenges prevent us from inferring types of all objects. This is not a fundamental limitation of OOP itself. It’s a result of design trade-offs in Java and similar languages. In a perfect object-oriented language, all variable types would be inferrable.</p><amp-img src="/images/2025/08/swingers.jpg"alt="Swingers (1996) by Doug Liman"height="688"width="1280"layout="responsive"></amp-img><p>Imagine a simple Java method:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Price priceOfDelivery(Book book, City city) {
  Price price = book.price();
  Delivery delivery = new Delivery(price, city);
  return delivery.price();
}
</code></pre></div></div><p>Two reasons justify the usage of <code class="language-plaintext highlighter-rouge">Book</code>, <code class="language-plaintext highlighter-rouge">City</code>, <code class="language-plaintext highlighter-rouge">Price</code>, and <code class="language-plaintext highlighter-rouge">Delivery</code> type annotations: Compilers and programmers need help.<h2 id="type-annotations-are-helpful">Type Annotations Are Helpful</h2><p>First, we help the compiler eliminate some <strong>dynamic dispatches</strong> in favor of static calls. If the <code class="language-plaintext highlighter-rouge">Book</code> is a class, not an interface, the <code class="language-plaintext highlighter-rouge">book.price()</code> call may be compiled into a jump to an absolute address. Without information about the <code class="language-plaintext highlighter-rouge">book</code>’s class, <code class="language-plaintext highlighter-rouge">.price()</code> goes to a virtual table first, finds the address, and only then jumps. The second scenario is more expensive. The type annotation attached to <code class="language-plaintext highlighter-rouge">book</code> helps avoid it.<p>Second, we help ourselves write safe code, avoiding “Method not found” <strong>runtime errors</strong>. If <code class="language-plaintext highlighter-rouge">book</code> is not annotated as <code class="language-plaintext highlighter-rouge">Book</code>, we may mistakenly pass <code class="language-plaintext highlighter-rouge">Integer</code>, meaning the book’s ID in the database. At compile time, that would lead to no errors. Later, at runtime, we get an error when <code class="language-plaintext highlighter-rouge">.price()</code> is not found in the virtual table of the <code class="language-plaintext highlighter-rouge">Integer</code> class.<p>However, both compilers and programmers can improve.<h2 id="compilers-can-do-better">Compilers Can Do Better</h2><p>Sometimes, a compiler can infer the type of a variable, without an explicit annotation. For example, this code compiles in Java, starting from version 10:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Price priceOfDelivery(Book book, City city) {
  var price = book.price();
  var delivery = new Delivery(price, city);
  return delivery.price();
}
</code></pre></div></div><p>The type annotation used in earlier Java versions is replaced with the <code class="language-plaintext highlighter-rouge">var</code> keyword.<p>In a small piece of code such as this one, the compiler can <strong>infer</strong> types. However, it may fall short with the <code class="language-plaintext highlighter-rouge">book</code> and <code class="language-plaintext highlighter-rouge">city</code> parameters. In the general case, type inference is not decidable for Java programs. Because of generics, method overloading, reflection, and … complexity.<p>The complexity is the technical obstacle. The compiler can’t infer types for all variables because it would be too expensive to analyze the whole program. Instead, it compiles file by file. Even if the compiler had the whole program, inference in Java would still hit undecidability in the general case. File-by-file compilation makes this even more restrictive.<p>All other barriers, such as generics, the compiler can’t overcome:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void print(List&lt;?&gt; items) {
  var x = items.get(0); // What is the type?
}
</code></pre></div></div><p>No matter how hard the compiler tries, in the general case, this question doesn’t have an answer.<h2 id="programmers-can-do-better">Programmers Can Do Better</h2><p>We, programmers, can help the compiler infer types.<p>For example, we can stop using generics. Instead of <code class="language-plaintext highlighter-rouge">List&lt;Book&gt;</code> we can have a <code class="language-plaintext highlighter-rouge">Library</code> and instead of <code class="language-plaintext highlighter-rouge">Map&lt;User, Phone&gt;</code> we can have a <code class="language-plaintext highlighter-rouge">PhoneBook</code>. It’s easier to infer the type of the object taken from a <code class="language-plaintext highlighter-rouge">Library</code> versus the object taken from a generic <code class="language-plaintext highlighter-rouge">List</code>.<p>We can also stop using method overloading. Instead of <code class="language-plaintext highlighter-rouge">print(String x)</code> and <code class="language-plaintext highlighter-rouge">print(Integer x)</code> we can create <code class="language-plaintext highlighter-rouge">printString(x)</code> and <code class="language-plaintext highlighter-rouge">printInteger(x)</code>. Types of parameters are easier to infer in more specialized methods.<p>We can also stop using reflection.<p>Java programmers may not be ready for such a <strong>radical move</strong>. However, if they were, they would not only help the compiler but themselves too. Eliminating type annotations makes code shorter and, because of that, cleaner. This is why <code class="language-plaintext highlighter-rouge">var</code> syntax was introduced in Java 10.<p>In the code above, variable names are nouns. In well-written code, nouns as names are sufficient to disambiguate variables. No need to call it <code class="language-plaintext highlighter-rouge">cityOfDelivery</code> or <code class="language-plaintext highlighter-rouge">bookToDeliver</code>. Just <code class="language-plaintext highlighter-rouge">book</code> and <code class="language-plaintext highlighter-rouge">city</code> are enough.<p>We also named variables by their types: a <code class="language-plaintext highlighter-rouge">book</code> is of type <code class="language-plaintext highlighter-rouge">Book</code>, and so on. By looking at the name of the variable we can tell its type. The <code class="language-plaintext highlighter-rouge">Book</code> type annotation looks like a syntactical redundancy. It only leads to lower code readability, by making it longer. It’s reasonable to expect type inference to free our programs from this redundancy.<p>Thus, better type inference means better <strong>readability</strong> of the code.<h2 id="languages-can-do-better">Languages Can Do Better</h2><p>Languages like Haskell and the ML family prove that full type inference is achievable. However, they still need annotations for edge cases. Rust takes a middle ground. It infers local variable types but enforces explicit annotations at public interfaces. Go, until recently, avoided generics, operator overloading, and heavy reflection, making inference straightforward. However, it forces programmers to annotate all public boundaries—function signatures, struct fields, and interfaces.<p>I suggest taking one step forward and designing a language that doesn’t have any type annotations. Such a language should not have generics, method overloading, reflection, and everything else that prevents 100% type inference. Then, we must design a compiler for this language that compiles the entire program, not single files.<p>The language may be as strict as this: If the type of a variable can’t be inferred, compilation fails.<p>This is how the book price snippet would look in such a language:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>priceOfDelivery(book, city) {
  p = book.price();
  d = new Delivery(p, city);
  return d.price();
}
</code></pre></div></div><p>To me, this seems to be much more readable than the original code in Java.<p>Compilation time remains a limitation though. We turn this issue into an opportunity. Programmers are forced, by the timing limitations of the compiler, to write smaller modules. When they need larger programs, they break them into modules that communicate via <a href="https://en.wikipedia.org/wiki/Inter-process_communication">IPC</a> instead of staying in a monolithic binary.<p>We’re experimenting with this approach in <a href="https://www.eolang.org">EOLANG</a>, a language designed to maximize inference by eliminating features that make it undecidable.</article>