<!doctypehtml><html amp lang="en"><meta charset="utf-8"><title>Programmers, Don't Use Windows!</title><link rel="canonical"href="https://www.yegor256.com/2025/10/05/windows-vs-macos.html"><link rel="icon"type="image/png"href="/favicon.ico"><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><script type="application/ld+json">{
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2025/10/05/windows-vs-macos.html"
        },
        "headline": "Programmers, Don't Use Windows!",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2025/10/das-experiment.jpg",
          "height": 1040,
          "width": 1920
        },
        "datePublished": "2025-10-05",
        "dateModified": "2025-10-05",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Windows turns programmers into mouse operators.
macOS, built on Unix, keeps the command line alive—where everything is a file,
tools connect through pipelines, and real programmers stay in control.
",
        "keywords": ["windows vs macOS", "windows vs MacBook", "macOS vs ubuntu", "windows vs ubuntu", "macOS vs windows"]
      }</script><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript><link rel="stylesheet"href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500"><style amp-custom="amp-custom">@font-face{font-family:Cambria;src:url(https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf)}body{font-family:Cambria,'Times New Roman',serif;padding:.5em;font-size:1.2em}article{width:600px;max-width:100%;margin-left:auto;margin-right:auto}code,pre{font-family:'Source Code Pro','Courier New',monospace;font-size:.8em}code{padding:0 .3em;background-color:#d3d3d3}a,a:hover,a:visited{color:inherit}.intro{color:red;font-size:.75em}.photo{border-radius:50%}pre{overflow-x:scroll}</style><script async src="https://cdn.ampproject.org/v0.js"></script><article><p class="intro">This is a mobile version, full one is <a href="https://www.yegor256.com/2025/10/05/windows-vs-macos.html">here</a>.<p><amp-img src="/images/face-256x256.jpg"width="80"height="80"alt="Yegor Bugayenko"class="photo"></amp-img><p>Yegor Bugayenko<br>5 October 2025<h1>Programmers, Don't Use Windows!</h1><p>In 2020, in the <a href="/junior-objects.html">Junior Objects</a> book I wrote this: “<em>Windows is not suitable for programmers. If you meet anyone who will tell you otherwise, you must know that you deal with a bad programmer, or a poor one, which are the same things. Your computer has to be MacBook.</em>” Now, five years later, I still hold the same opinion. This blog post is supposed to be less opinionated and, because of this, more convincing. The point is still the same: you either use Windows or you are a professional programmer.</p><amp-img src="/images/2025/10/das-experiment.jpg"alt="Das Experiment (2001) by Oliver Hirschbiegel"height="1040"width="1920"layout="responsive"></amp-img><p>First things first. This is what ChatGPT <a href="https://chatgpt.com/share/68e2770a-79d8-8007-96d1-3722d4d3cfcd">thinks</a> about macOS vs. Windows (I toned it down a bit and sorted by importance, keeping what matters most at the top):<ul><li>It’s <a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a>-compliant<li>Tools like <code class="language-plaintext highlighter-rouge">grep</code>, <code class="language-plaintext highlighter-rouge">awk</code>, <code class="language-plaintext highlighter-rouge">sed</code>, <code class="language-plaintext highlighter-rouge">ssh</code>, and <code class="language-plaintext highlighter-rouge">make</code> work natively<li>Proper compiler toolchain: Clang, LLVM, make, <a href="https://git-scm.com/">git</a><li>Install everything with <a href="https://brew.sh/">HomeBrew</a>, one command away<li>Node, Python, Ruby, Go, Java—just work without PATH hell<li>The <a href="https://iterm2.com/">iTerm2</a> doesn’t look like it was built in 1998<li><a href="https://www.docker.com/">Docker</a> runs faster and cleaner than on Windows<li>SSH keys integrate smoothly with the system keychain<li><a href="https://git-scm.com/">Git</a> behaves predictably; no <a href="https://stackoverflow.com/questions/1552749/difference-between-cr-lf-lf-and-cr-line-break-types">CRLF vs LF nightmares</a></ul><p>I can hear you saying: What do I need it to be POSIX-compliant, and what is POSIX? Why do I need <code class="language-plaintext highlighter-rouge">grep</code>, <code class="language-plaintext highlighter-rouge">sed</code>, and <code class="language-plaintext highlighter-rouge">awk</code>? Am I a 60 years old Unix admin? Why would I ever need <code class="language-plaintext highlighter-rouge">git</code> and <code class="language-plaintext highlighter-rouge">make</code> in the command line? I don’t use command line at all. I stay in the <a href="https://code.visualstudio.com/">VS Code</a> that works like a charm and helps me make a living.<p>I hear you. I do.<p>Now, hear me out. You are not a programmer. You look like one. You walk like one. You click the same buttons programmers click. You even make the same salary they make. But you are not one of them. Yet. Now, read on.<h2 id="what-is-unix">What Is Unix?</h2><p>Programmers are the masters of computers. They tell machines what to do. To simplify the task of managing a complex hardware, programmers invented a few layers of abstractions. The first layer is an operating system. Instead of dealing with the hard drive and the pixels on the screen directly, programmers invented files and stdout.<p>They did it in the <a href="https://en.wikipedia.org/wiki/Bell_Labs">Bell Labs</a>, during the late 1960s and early 1970s. Earlier operating systems, like <a href="https://en.wikipedia.org/wiki/Compatible_Time-Sharing_System">CTSS</a> and <a href="https://en.wikipedia.org/wiki/OS/360_and_successors">OS/360</a>, gave them a good start. Unix was the first OS to say that <em>everything is a file</em>, including devices, directories, sockets, and processes. They also invented <em>pipelines</em> and the philosophy: “Write programs that do one thing well, and work together.” They also invented <em>processes</em> and their forking mechanism.<p>Their names were <a href="https://en.wikipedia.org/wiki/Ken_Thompson">Ken Thompson</a> and <a href="https://en.wikipedia.org/wiki/Dennis_Ritchie">Dennis Ritchie</a>.<h2 id="what-is-windows">What Is Windows?</h2><p>Five years later, another operating system was created, with different abstractions. Not everything was a file anymore, processes were not parallel, and there were no pipelines. The name of the system was <a href="https://en.wikipedia.org/wiki/CP/M">CP/M</a> and the name of the inventor was <a href="https://en.wikipedia.org/wiki/Gary_Kildall">Gary Kildall</a>. Then, five years later, 24-year-old <a href="https://en.wikipedia.org/wiki/Tim_Paterson">Tim Paterson</a> has made a copy of CP/M and called it <a href="https://en.wikipedia.org/wiki/86-DOS">86-DOS</a>. <a href="https://www.microsoft.com/">Microsoft</a> purchased a non-exclusive license, rebranded it <a href="https://en.wikipedia.org/wiki/MS-DOS">MS-DOS</a>, and sold it to IBM. That’s how Windows was born, in 1981.<p>Why were there no proper files, no processes, and no pipelines? Because they weren’t trying to build a “real” operating system. CP/M and MS-DOS were designed for tiny, single-user, single-task microcomputers, not multi-user minicomputers or mainframes. Unix came out of Bell Labs—researchers, not hobbyists. CP/M and MS-DOS were made for personal computers: offices and home users. In other words, <em>MS-DOS never meant to be a proper OS</em>. It was something that can boot up a small machine and run a single program.<p>Then, in 1985, <a href="https://en.wikipedia.org/wiki/Windows_1.0">Windows 1.0</a> was built. It was a fancy <a href="https://en.wikipedia.org/wiki/Graphical_user_interface">GUI</a> on top of MS-DOS, not a new OS. Later, in 1995, Microsoft introduced 32-bit APIs (<a href="https://en.wikipedia.org/wiki/Windows_API">Win32</a>) and preemptive multitasking. However, the DOS subsystem was still lurking underneath. Windows 95 looked modern but was still a half-DOS zombie.<p>At the same time, in 1993, the team of <a href="https://en.wikipedia.org/wiki/Dave_Cutler">Dave Cutler</a> has built <a href="https://en.wikipedia.org/wiki/Windows_NT">Windows NT</a> that was not based on DOS at all. Latest Windows versions are descendants of NT, not MS-DOS. Under the hood it’s conceptually closer to Unix than to CP/M. There are features like protected memory, kernel/user separation, and file handles. However, still it’s not Unix.<h2 id="what-is-macos">What Is macOS?</h2><p>In 1984, <a href="https://www.apple.com/">Apple</a> shipped their first <a href="https://en.wikipedia.org/wiki/Macintosh_128K">Macintosh</a> with the “System 1” operating system. It was no better than MS-DOS: no multitasking, no memory protection, and primitive file system. No surprise, it didn’t fly.<p>In 1997, Apple bought <a href="https://en.wikipedia.org/wiki/NeXT">NeXT</a> and adopted <a href="https://en.wikipedia.org/wiki/NeXTSTEP">NeXTSTEP</a> operating system. They made it the foundation for the new <a href="https://en.wikipedia.org/wiki/MacOS">Mac OS</a>—codenamed <a href="https://en.wikipedia.org/wiki/Rhapsody_(operating_system)">Rhapsody</a>, later “Mac OS X”.<p>In 2001 they shipped Mac OS X 10.0 (“<a href="https://en.wikipedia.org/wiki/Mac_OS_X_10.0">Cheetah</a>”). Five years later I threw away my ThinkPad with Windows and bought my first MacBook with <a href="https://en.wikipedia.org/wiki/Mac_OS_X_Leopard">Mac OS X Leopard</a>.<p>Modern macOS (Catalina, Ventura, Sequoia, etc.) is still built on that NeXT foundation. It is POSIX-compliant and, of course, it has processes and pipelines. In other words, it is Unix with a pretty GUI.<h2 id="abstractions">Abstractions</h2><p>Both Windows and macOS, in their current versions, are solid operating systems. The difference is in the abstractions inside them: files, sockets, processes, memory blocks, users, permissions, and so on. In Unix (macOS), everything is a <em>file</em>, while in Windows, everything is an <em>object</em>. Files in Unix are a uniform abstraction, that’s why they can be chained via pipes. In Windows objects are not unified in practice, they have different interfaces.<p>This is why <a href="https://en.wikipedia.org/wiki/Unix_shell">Unix shells</a> and small composable tools became so powerful. The uniformity of “everything is a file” made composition natural. You can build complex workflows from simple programs.<p>Windows, on the other hand, evolved around GUI apps and message loops, not shell pipelines.<h2 id="pipelines">Pipelines</h2><p><a href="https://en.wikipedia.org/wiki/Unix">Unix</a> was built around pipelines. In Unix, everything is a small tool reading stdin, writing stdout. At the same time, everything is a file, including sockets, devices, and processes. Programmers, in Unix, see every process as a <em>composition</em> of smaller processes, glued together via pipelines. This mindset, since 1970s, has proven to be effective, amongst a few generations of software engineering elite.<p>Say, you want to know which parts of your codebase change the most—maybe for refactoring, testing focus, or bug-hotspot analysis. This is how you do it Unix-style:<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git log <span class="nt">--pretty</span><span class="o">=</span>format: <span class="nt">--name-only</span> | <span class="se">\</span>
  <span class="nb">grep</span> <span class="s1">'\.java$'</span> | <span class="se">\</span>
  <span class="nb">sort</span> | <span class="se">\</span>
  <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="se">\</span>
  <span class="nb">sort</span> <span class="nt">-nr</span> | <span class="se">\</span>
  <span class="nb">head</span> <span class="nt">-20</span>
</code></pre></div></div><p>Does this syntax make sense to you? If it does, I bet you use <a href="https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux">WSL</a>. Most serious Windows developers end up doing exactly that.<p>The command line is the bare metal interface to Unix. The heart of the command line is pipelines. Thanks to pipelines, command-line tools are inherently composable. You can chain them and automate tasks in seconds that would take hours by hand. No <a href="https://en.wikipedia.org/wiki/Integrated_development_environment">IDE</a> plugin can replace this power.<h2 id="what-are-you">What Are You?</h2><p>Now, you know what the difference is between Windows and macOS. In both of them you can code, browse Internet, and watch movies. However, in macOS you interact with the computer through Unix abstractions in a <a href="https://en.wikipedia.org/wiki/Unix_shell">shell</a>. You don’t just use macOS—you inherit <em>fifty years of disciplined abstraction</em>.<p>In Windows you interact with the computer through draggable GUI elements. A GUI makes you a consumer; a CLI makes you a creator. A GUI hides the logic behind gestures and icons; a CLI exposes it as text you can reason about, automate, and combine. You can’t pipe a button click into another program, you can’t grep a progress bar, and you can’t version-control a mouse movement. Every click you make dies the moment you make it; every command you write can live forever.<p>Oh, wait. In macOS you can’t really play games. Bummer… Maybe you shouldn’t, since you are a programmer?</article>