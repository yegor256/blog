<!DOCTYPE html>
<html amp lang="en">
  <head>

    <meta charset="utf-8">
    <title>Object Behavior Must Not Be Configurable</title>
    <link rel="canonical" href="http://www.yegor256.com/2016/04/19/object-must-not-be-configurable.html">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "http://www.yegor256.com/2016/04/19/object-must-not-be-configurable.html"
        },
        "headline": "Object Behavior Must Not Be Configurable",
        "image": {
          "@type": "ImageObject",
          "url": "https://cf.jare.io/?u=http://www.yegor256.com/images/2016/04/the-take.jpg",
          "height": 677,
          "width": 1200
        },
        "datePublished": "2016-04-19",
        "dateModified": "2016-04-19",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "http://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Using object properties as configuration parameters
for object behavior is a bad practice that leads to
bigger and less cohesive objects.
",
        "keywords": ["settings object", "parameters object", "decorator pattern", "decorator pattern java", "object configuration"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <style amp-custom="amp-custom">
      body { padding: .5em; font-size: 1.2em; }
      article { width: 600px; max-width: 100%; margin-left: auto; margin-right: auto; }
      .intro { color: red; font-size: .75em; }
      .photo { border-radius: 50%; }
      pre { overflow-x:scroll; }
    </style>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <article>
      <p class="intro">
        This is a mobile version, full one is
        <a href="http://www.yegor256.com/2016/04/19/object-must-not-be-configurable.html">here</a>.
      </p>
      <p>
        <amp-img src="/images/yegor-bugayenko-192x192.png" width="80" height="80" alt="Yegor Bugayenko" class="photo"></amp-img>
      </p>
      <p>Yegor Bugayenko<br>19 April 2016</p>
      <h1>Object Behavior Must Not Be Configurable</h1>
      <p>Using object properties as configuration parameters is a very common
mistake we keep making mostly because our objects
are mutableâ€”we <strong>configure</strong> them. We change their behavior by
injecting parameters or even entire settings/configuration objects
into them. Do I have to say that it's abusive and disrespectful
from a <a href="/2014/11/20/seven-virtues-of-good-object.html">philosophical</a>
point of view? I can, but let's take a look at
it from a practical perspective.</p>



<amp-img src="https://cf.jare.io/?u=http://www.yegor256.com/images/2016/04/the-take.jpg" alt="The Take (2009) by David Drury" height="677" width="1200" layout="responsive"></amp-img>

<p>Let's say there is a class that is supposed to read a web page and
return its content:</p>

<pre>class Page {
  private final String uri;
  Page(final String address) {
    this.uri = address;
  }
  public String html() throws IOException {
    return IOUtils.toString(
      new URL(this.uri).openStream(),
      "UTF-8"
    );
  }
}</pre>

<p>Looks simple and straight-forward, right? Yes, it's a rather cohesive
and solid class. Here is how we use it to read the content of Google
front page:</p>

<pre>String html = new Page("http://www.google.com").html();</pre>

<p>Everything is fine until we start making this class more powerful.
Let's say we want to configure the encoding. We don't always want to use <code>"UTF-8"</code>.
We want it to be configurable. Here is what we do:</p>

<pre>class Page {
  private final String uri;
  private final String encoding;
  Page(final String address, final String enc) {
    this.uri = address;
    this.encoding = enc;
  }
  public String html() throws IOException {
    return IOUtils.toString(
      new URL(this.uri).openStream(),
      this.encoding
    );
  }
}</pre>

<p>Done, the encoding is encapsulated and configurable. Now, let's say we
want to change the behavior of the class for the situation of an empty
page. If an empty page is loaded, we want to return <code>"&lt;html/&gt;"</code>. But not
always. We want this to be configurable. Here is what we do:</p>

<pre>class Page {
  private final String uri;
  private final String encoding;
  private final boolean alwaysHtml;
  Page(final String address, final String enc,
    final boolean always) {
    this.uri = address;
    this.encoding = enc;
    this.alwaysHtml = always;
  }
  public String html() throws IOException {
    String html = IOUtils.toString(
      new URL(this.uri).openStream(),
      this.encoding
    );
    if (html.isEmpty() &amp;&amp; this.alwaysHtml) {
      html = "&lt;html/&gt;";
    }
    return html;
  }
}</pre>

<p>The class is getting bigger, huh? It's great, we're good programmers and our
code must be complex, right? The more complex it is, the better programmers
we are! I'm being sarcastic. Definitely
<a href="/2015/06/29/simple-diagrams.html">not</a>! But let's move on. Now
we want our class to proceed anyway, even if the encoding is not
supported on the current platform:</p>

<pre>class Page {
  private final String uri;
  private final String encoding;
  private final boolean alwaysHtml;
  private final boolean encodeAnyway;
  Page(final String address, final String enc,
    final boolean always, final boolean encode) {
    this.uri = address;
    this.encoding = enc;
    this.alwaysHtml = always;
    this.encodeAnyway = encode;
  }
  public String html() throws IOException,
  UnsupportedEncodingException {
    final byte[] bytes = IOUtils.toByteArray(
      new URL(this.uri).openStream()
    );
    String html;
    try {
      html = new String(bytes, this.encoding);
    } catch (UnsupportedEncodingException ex) {
      if (!this.encodeAnyway) {
        throw ex;
      }
      html = new String(bytes, "UTF-8")
    }
    if (html.isEmpty() &amp;&amp; this.alwaysHtml) {
      html = "&lt;html/&gt;";
    }
    return html;
  }
}</pre>

<p>The class is growing and becoming more and more powerful! Now it's time
to introduce a new class, which we will call <code>PageSettings</code>:</p>

<pre>class Page {
  private final String uri;
  private final PageSettings settings;
  Page(final String address, final PageSettings stts) {
    this.uri = address;
    this.settings = stts;
  }
  public String html() throws IOException {
    final byte[] bytes = IOUtils.toByteArray(
      new URL(this.uri).openStream()
    );
    String html;
    try {
      html = new String(bytes, this.settings.getEncoding());
    } catch (UnsupportedEncodingException ex) {
      if (!this.settings.isEncodeAnyway()) {
        throw ex;
      }
      html = new String(bytes, "UTF-8")
    }
    if (html.isEmpty() &amp;&amp; this.settings.isAlwaysHtml()) {
      html = "&lt;html/&gt;";
    }
    return html;
  }
}</pre>

<p>Class <code>PageSettings</code> is basically a holder of parameters, without any
behavior. It has getters, which give us access to the parameters:
<code>isEncodeAnyway()</code>, <code>isAlwaysHtml()</code>, and <code>getEncoding()</code>. If we keep
going in this direction, there could be a few dozen configuration settings
in that class. This may look very convenient and
is a very typical pattern in Java world. For example,
look at
<a href="https://hadoop.apache.org/docs/r2.4.1/api/org/apache/hadoop/mapred/JobConf.html"><code>JobConf</code></a>
from Hadoop.
This is how we will call our highly configurable <code>Page</code>
(I'm assuming <code>PageSettings</code> is immutable):</p>

<pre>String html = new Page(
  "http://www.google.com",
  new PageSettings()
    .withEncoding("ISO_8859_1")
    .withAlwaysHtml(true)
    .withEncodeAnyway(false)
).html();</pre>

<p>However, no matter how convenient it may look at first glance,
this approach is <strong>very wrong</strong>. Mostly because it encourages us
to make big and non-cohesive objects. They grow in size and become less
testable, less maintainable and less readable.</p>



<p>To prevent that from happening,
I would suggest a simple rule here:
object behavior should not be configurable.
Or, more technically, encapsulated properties must not be used to
change the behavior of an object.</p>

<p>Object properties are there only to coordinate the location
of a real-world entity, which the object is representing. The <code>uri</code> is the
coordinate, while the <code>alwaysHtml</code> boolean property is a behavior changing
trigger. See the difference?</p>

<p>So, what should we do instead? What is the right design? We must
use <a href="/2015/02/26/composable-decorators.html">composable decorators</a>.
Here is how:</p>

<pre>Page page = new NeverEmptyPage(
  new DefaultPage("http://www.google.com")
)
String html = new AlwaysTextPage(
  new TextPage(page, "ISO_8859_1")
  page
).html();</pre>

<p>Here is how our <code>DefaultPage</code> would look (yes, I had to change
its design a bit):</p>

<pre>class DefaultPage implements Page {
  private final String uri;
  DefaultPage(final String address) {
    this.uri = address;
  }
  @Override
  public byte[] html() throws IOException {
    return IOUtils.toByteArray(
      new URL(this.uri).openStream()
    );
  }
}</pre>

<p>As you see, I'm making it implement interface <code>Page</code>.
Now <code>TextPage</code> decorator, which converts an array of bytes to a text using
provided encoding:</p>

<pre>class TextPage {
  private final Page origin;
  private final String encoding;
  TextPage(final Page page, final String enc) {
    this.origin = page;
    this.encoding = enc;
  }
  public String html() throws IOException {
    return new String(
      this.origin.html(),
      this.encoding
    );
  }
}</pre>

<p>Now the <code>NeverEmptyPage</code>:</p>

<pre>class NeverEmptyPage implements Page {
  private final Page origin;
  NeverEmptyPage(final Page page) {
    this.origin = page;
  }
  @Override
  public byte[] html() throws IOException {
    byte[] bytes = this.origin.html();
    if (bytes.length == 0) {
      bytes = "&lt;html/&gt;".getBytes();
    }
    return bytes;
  }
}</pre>

<p>And finally the <code>AlwaysTextPage</code>:</p>

<pre>class AlwaysTextPage {
  private final TextPage origin;
  private final Page source;
  AlwaysTextPage(final TextPage page, final Page src) {
    this.origin = page;
    this.source = src;
  }
  public String html() throws IOException {
    String html;
    try {
      html = this.origin.html();
    } catch (UnsupportedEncodingException ex) {
      html = new TextPage(this.source, "UTF-8").html();
    }
    return html;
  }
}</pre>

<p>You may say that <code>AlwaysTextPage</code> will make two calls to the encapsulated
<code>origin</code>, in case of an unsupported encoding, which will lead to a duplicated
HTTP request. That's true and this is by design. We don't want this
duplicated HTTP roundtrip to happen. Let's introduce one more class,
which will cache the page fetched (
<a href="/2017/01/17/synchronized-decorators.html">not thread-safe</a>, but it's not important now):</p>

<pre>class OncePage implements Page {
  private final Page origin;
  private final AtomicReference&lt;byte[]&gt; cache =
    new AtomicReference&lt;&gt;;
  OncePage(final Page page) {
    this.origin = page;
  }
  @Override
  public byte[] html() throws IOException {
    if (this.cache.get() == null) {
      this.cache.set(this.origin.html());
    }
    return this.cache.get();
  }
}</pre>

<p>Now, our code should look like this (pay attention, I'm now using <code>OncePage</code>):</p>

<pre>Page page = new NeverEmptyPage(
  new OncePage(
    new DefaultPage("http://www.google.com")
  )
)
String html = new AlwaysTextPage(
  new TextPage(page, "ISO_8859_1")
  "UTF-8"
).html();</pre>

<p>This is probably the most code-intensive post on this site so far, but I
hope it's readable and I managed to convey the idea. Now we have five
classes, each of which is rather small, easy to read and easy to reuse.</p>

<p>Just follow the rule: never make classes configurable!</p>

    </article>
  </body>
</html>
