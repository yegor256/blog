<!DOCTYPE html>
<html amp lang="en">
  <head>

    <meta charset="utf-8">
    <title>Object Behavior Must Not Be Configurable</title>
    <link rel="canonical" href="http://www.yegor256.com/2016/04/19/object-must-not-be-configurable.html">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "http://www.yegor256.com/2016/04/19/object-must-not-be-configurable.html"
        },
        "headline": "Object Behavior Must Not Be Configurable",
        "image": {
          "@type": "ImageObject",
          "url": "http://img.teamed.io/face-1400x1400.jpg",
          "height": 1400,
          "width": 1400
        },
        "datePublished": "2016-04-19",
        "dateModified": "2016-04-19",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "http://img.teamed.io/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Using object properties as configuration parameters
for object behavior is a bad practice that leads to
bigger and less cohesive objects.
",
        "keywords": ["settings object", "parameters object", "decorator pattern", "decorator pattern java", "object configuration"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <style amp-custom="amp-custom">
      body { padding: 2em; }
      article { width: 600px; max-width: 100%; margin-left: auto; margin-right: auto; }
      .intro { color: red; font-size: .75em; }
    </style>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <article>
      <p class="intro">
        This is an AMP version of the article,
        its original content can be found
        <a href="http://www.yegor256.com/2016/04/19/object-must-not-be-configurable.html">here</a>.
      </p>
      <h1>Object Behavior Must Not Be Configurable</h1>
      <p>Using object properties as configuration parameters is a very common
mistake we keep making mostly because our objects
are mutableâ€”we <strong>configure</strong> them. We change their behavior by
injecting parameters or even entire settings/configuration objects
into them. Do I have to say that it's abusive and disrespectful
from a <a href="/2014/11/20/seven-virtues-of-good-object.html">philosophical</a>
point of view? I can, but let's take a look at
it from a practical perspective.</p>





<p>Let's say there is a class that is supposed to read a web page and
return its content:</p>



<p>Looks simple and straight-forward, right? Yes, it's a rather cohesive
and solid class. Here is how we use it to read the content of Google
front page:</p>



<p>Everything is fine until we start making this class more powerful.
Let's say we want to configure the encoding. We don't always want to use <code>"UTF-8"</code>.
We want it to be configurable. Here is what we do:</p>



<p>Done, the encoding is encapsulated and configurable. Now, let's say we
want to change the behavior of the class for the situation of an empty
page. If an empty page is loaded, we want to return <code>"&lt;html/&gt;"</code>. But not
always. We want this to be configurable. Here is what we do:</p>



<p>The class is getting bigger, huh? It's great, we're good programmers and our
code must be complex, right? The more complex it is, the better programmers
we are! I'm being sarcastic. Definitely
<a href="/2015/06/29/simple-diagrams.html">not</a>! But let's move on. Now
we want our class to proceed anyway, even if the encoding is not
supported on the current platform:</p>



<p>The class is growing and becoming more and more powerful! Now it's time
to introduce a new class, which we will call <code>PageSettings</code>:</p>



<p>Class <code>PageSettings</code> is basically a holder of parameters, without any
behavior. It has getters, which give us access to the parameters:
<code>isEncodeAnyway()</code>, <code>isAlwaysHtml()</code>, and <code>getEncoding()</code>. If we keep
going in this direction, there could be a few dozen configuration settings
in that class. This may look very convenient and
is a very typical pattern in Java world. For example,
look at
<a href="https://hadoop.apache.org/docs/r2.4.1/api/org/apache/hadoop/mapred/JobConf.html"><code>JobConf</code></a>
from Hadoop.
This is how we will call our highly configurable <code>Page</code>
(I'm assuming <code>PageSettings</code> is immutable):</p>



<p>However, no matter how convenient it may look at first glance,
this approach is <strong>very wrong</strong>. Mostly because it encourages us
to make big and non-cohesive objects. They grow in size and become less
testable, less maintainable and less readable.</p>



<p>To prevent that from happening,
I would suggest a simple rule here:
object behavior should not be configurable.
Or, more technically, encapsulated properties must not be used to
change the behavior of an object.</p>

<p>Object properties are there only to coordinate the location
of a real-world entity, which the object is representing. The <code>uri</code> is the
coordinate, while the <code>alwaysHtml</code> boolean property is a behavior changing
trigger. See the difference?</p>

<p>So, what should we do instead? What is the right design? We must
use <a href="/2015/02/26/composable-decorators.html">composable decorators</a>.
Here is how:</p>



<p>Here is how our <code>DefaultPage</code> would look (yes, I had to change
its design a bit):</p>



<p>As you see, I'm making it implement interface <code>Page</code>.
Now <code>TextPage</code> decorator, which converts an array of bytes to a text using
provided encoding:</p>



<p>Now the <code>NeverEmptyPage</code>:</p>



<p>And finally the <code>AlwaysTextPage</code>:</p>



<p>You may say that <code>AlwaysTextPage</code> will make two calls to the encapsulated
<code>origin</code>, in case of an unsupported encoding, which will lead to a duplicated
HTTP request. That's true and this is by design. We don't want this
duplicated HTTP roundtrip to happen. Let's introduce one more class,
which will cache the page fetched (
<a href="/2017/01/17/synchronized-decorators.html">not thread-safe</a>, but it's not important now):</p>



<p>Now, our code should look like this (pay attention, I'm now using <code>OncePage</code>):</p>



<p>This is probably the most code-intensive post on this site so far, but I
hope it's readable and I managed to convey the idea. Now we have five
classes, each of which is rather small, easy to read and easy to reuse.</p>

<p>Just follow the rule: never make classes configurable!</p>

    </article>
  </body>
</html>
