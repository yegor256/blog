<!DOCTYPE html>
<html amp lang="en">
  <head>

    <meta charset="utf-8">
    <title>Why InputStream Design Is Wrong</title>
    <link rel="canonical" href="http://www.yegor256.com/2016/04/26/why-inputstream-design-is-wrong.html">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "http://www.yegor256.com/2016/04/26/why-inputstream-design-is-wrong.html"
        },
        "headline": "Why InputStream Design Is Wrong",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2016/04/a-serious-man.jpg",
          "height": 656,
          "width": 1200
        },
        "datePublished": "2016-04-26",
        "dateModified": "2016-04-26",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "http://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Class InputStream in Java has three methods read(),
this is what I think is very wrong. Not only in
this class, but in general in OOP.
",
        "keywords": ["why InputStream is a class", "InputStream", "InputStream java", "method overloading", "method overloading java"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500">
    <style amp-custom="amp-custom">
      @font-face {
        font-family: 'Cambria';
        src: url('http://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf');
      }
      body { font-family: 'Cambria', 'Times New Roman', serif; padding: .5em; font-size: 1.2em; }
      article { width: 600px; max-width: 100%; margin-left: auto; margin-right: auto; }
      pre, code { font-family: 'Source Code Pro', 'Courier New', monospace; font-size: .8em; }
      code { padding: 0 .3em; background-color: lightgray; }
      a, a:hover, a:visited { color: inherit; }
      .intro { color: red; font-size: .75em; }
      .photo { border-radius: 50%; }
      pre { overflow-x:scroll; }
    </style>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <article>
      <p class="intro">
        This is a mobile version, full one is
        <a href="http://www.yegor256.com/2016/04/26/why-inputstream-design-is-wrong.html">here</a>.
      </p>
      <p>
        <amp-img src="/images/yegor-bugayenko-192x192.png" width="80" height="80" alt="Yegor Bugayenko" class="photo"></amp-img>
      </p>
      <p>Yegor Bugayenko<br>26 April 2016</p>
      <h1>Why InputStream Design Is Wrong</h1>
      <p>It's not just about <code>InputSteam</code>, this class is a good
example of a bad design. I'm talking about three overloaded
methods <code>read()</code>. I've mentioned this problem in Section 2.9
of <a href="/elegant-objects.html">Elegant Objects</a>. In a few words,
I strongly believe that interfaces must be "functionality poor."
<code>InputStream</code> should have been an interface in the first place
and it should have had a single method <code>read(byte[])</code>. Then if
its authors wanted to give us extra functionality, they should have
created supplementary "smart" classes.</p>



<amp-img src="/images/2016/04/a-serious-man.jpg" alt="A Serious Man (2009) by Coen Brothers" height="656" width="1200" layout="responsive"></amp-img>

<p>This is how it looks now:</p>

<pre>abstract class InputStream {
  int read();
  int read(byte[] buffer, int offset, int length);
  int read(byte[] buffer);
}</pre>

<p>What's wrong? It's very convenient to have the ability to read
a single byte, an array of bytes or even an array of bytes
with a direct positioning into a specific place in the buffer!</p>

<p>However, we are still lacking a few methods: for reading the bytes and
immediately saving into a file, converting to a text with a selected
encoding, sending them by email and posting on Twitter. It would be
great to have the features too, right in the poor <code>InputStream</code>.
I hope the Oracle Java team is working on them now.</p>

<p>In the mean time, let's see what exactly is wrong with what these
bright engineers designed for us already. Or maybe let me show
how I would design <code>InputStream</code> and we'll compare:</p>

<pre>interface InputStream {
  int read(byte[] buffer, int offset, int length);
}</pre>

<p>This is my design. The <code>InputStream</code> is responsible for reading
bytes from the stream. There is one single method for this
feature. Is it convenient for everybody? Does it read and post
on Twitter? Not yet. Do we need that functionality? Of course we do,
but it doesn't mean that we will add it to the interface. Instead,
we will create supplementary "smart" class:</p>

<pre>interface InputStream {
  int read(byte[] buffer, int offset, int length);
  class Smart {
    private final InputStream origin;
    public Smart(InputStream stream) {
      this.origin = stream;
    }
    public int read() {
      final byte[] buffer = new byte[1];
      final int read = this.origin.read(buffer, 0, 1);
      final int result;
      if (read &lt; 1) {
        result = -1;
      } else {
        result = buffer[0];
      }
      return result;
    }
  }
}</pre>

<p>Now, we want to read a single byte from the stream. Here is how:</p>

<pre>final InputStream input = new FileInputStream("/tmp/a.txt");
final byte b = new InputStream.Smart(input).read();</pre>

<p>The functionality of reading a single byte is outside of <code>InputStream</code>,
because this is not its business. The stream doesn't need to know
how to manage the data after it is read. All the stream
is <strong>responsible</strong> for is reading, not parsing or manipulating afterwards.</p>

<p>Interfaces must be small.</p>

<p>Obviously, method overloading in interfaces is a code smell. An interface
with more than <strong>three methods</strong> is a good candidate for refactoring. If methods
overload each otherâ€”it's serious trouble.</p>

<p>Interfaces must be small!</p>

<p>You may say that the creators of <code>InputStream</code> cared about performance, that's
why allowed us to implement <code>read()</code> in three different forms. Then I have
to ask again, why not create a method for reading and immediately post it
on Twitter? That would be fantastically fast. Isn't it what we all want?
A fast software which nobody has any desire to read or maintain.</p>

    </article>
  </body>
</html>
