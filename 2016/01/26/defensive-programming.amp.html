<!DOCTYPE html>
<html amp lang="en">
  <head>

    <meta charset="utf-8">
    <title>Defensive Programming via Validating Decorators</title>
    <link rel="canonical" href="http://www.yegor256.com/2016/01/26/defensive-programming.html">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "http://www.yegor256.com/2016/01/26/defensive-programming.html"
        },
        "headline": "Defensive Programming via Validating Decorators",
        "image": {
          "@type": "ImageObject",
          "url": "http://www.yegor256.com/images/face-1400x1400.jpg",
          "height": 1400,
          "width": 1400
        },
        "datePublished": "2016-01-26",
        "dateModified": "2016-01-26",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "http://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Defensive programming is a good idea, but the way
it gets implemented is, in most cases, very wrong;
here is what I'm suggesting instead.
",
        "keywords": ["defensive programming", "validators in oop", "check for null", "validate method arguments", "startup failure stories"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <style amp-custom="amp-custom">
      body { padding: .5em; font-size: 1.2em; }
      article { width: 600px; max-width: 100%; margin-left: auto; margin-right: auto; }
      .intro { color: red; font-size: .75em; }
      .photo { border-radius: 50%; }
      pre { overflow-x:scroll; }
    </style>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <article>
      <p class="intro">
        This is a mobile version of the article,
        its original content can be found
        <a href="http://www.yegor256.com/2016/01/26/defensive-programming.html">here</a>.
      </p>
      <p>
        <amp-img src="/images/yegor-bugayenko-192x192.png" width="80px" height="80px" alt="Yegor Bugayenko" class="photo"></amp-img>
      </p>
      <p>Yegor Bugayenko<br>26 January 2016</p>
      <h1>Defensive Programming via Validating Decorators</h1>
      <p>Do you check the input parameters of your methods for validity?
I don't. I used to, but not anymore.
I just let my methods crash with a null pointer and other exceptions
when parameters are not valid.
This may sound illogical, but only in the beginning.
I'm suggesting you use <strong>validating decorators</strong> instead.</p>



<amp-img src="/images/2016/01/shi-mian-mai-fu.jpg" alt="Shi mian mai fu (2004) by Yimou Zhang" height="508" width="1200" layout="responsive"></amp-img>

<p>Let's take a look at this rather typical Java example:</p>

<pre>class Report {
  void export(File file) {
    if (file == null) {
      throw new IllegalArgumentException(
        "File is NULL; can't export."
      );
    }
    if (file.exists()) {
      throw new IllegalArgumentException(
        "File already exists."
      );
    }
    // Export the report to the file
  }
}</pre>

<p>Pretty <a href="https://en.wikipedia.org/wiki/Defensive_programming">defensive</a>, right?
If we remove these validations, the code
will be much shorter, but it will crash with rather confusing messages
if <code>NULL</code> is provided by the client. Moreover, if the file already exists,
our <code>Report</code> will silently overwrite it. Pretty dangerous, right?</p>

<p>Yes, we must protect ourselves, and we must be defensive.</p>

<p>But not this way, not by bloating the class with validations that
have nothing to do with its core functionality. Instead, we should
use decorators to do the validation. Here is how. First,
there must be an interface <code>Report</code>:</p>

<pre>interface Report {
  void export(File file);
}</pre>

<p>Then, a class that implements the core functionality:</p>

<pre>class DefaultReport implements Report {
  @Override
  void export(File file) {
    // Export the report to the file
  }
}</pre>

<p>And, finally, a number of decorators that will protect us:</p>

<pre>class NoWriteOverReport implements Report {
  private final Report origin;
  NoWriteOverReport(Report rep) {
    this.origin = rep;
  }
  @Override
  void export(File file) {
    if (file.exists()) {
      throw new IllegalArgumentException(
        "File already exists."
      );
    }
    this.origin.export(file);
  }
}</pre>

<p>Now, the client has the flexibility of composing a complex object
from decorators that perform their specific tasks. The core object
will do the reporting, while the decorators will validate parameters:</p>

<pre>Report report = new NoNullReport(
  new NoWriteOverReport(
    new DefaultReport()
  )
);
report.export(file);</pre>

<p>What do we achieve with this approach?
First and foremost: smaller objects.
And smaller objects always mean higher <strong>maintainability</strong>.
Our <code>DefaultReport</code> class will always remain small, no matter
how many validations we may invent in the future. The
more things we need to validate, the more validating decorators
we will create. All of them will be small and cohesive. And we'll
be able to put them together in different variations.</p>

<p>Besides that, this approach makes our code much more
<strong>reusable</strong>, as classes perform very few operations
and don't defend themselves by default. While being defensive
is an important feature, we'll use validating decorators. But
this will not always be the case. Sometimes validation is just
too expensive in terms of time and memory, and we may want to work
directly with objects that don't defend themselves.</p>

<p>I also decided not to use the Java Validation API anymore for the
same reason. Its annotations make classes much more verbose
and less cohesive. I'm using validating decorators instead.</p>

    </article>
  </body>
</html>
