<!doctypehtml><html amp lang="en"><meta charset="utf-8"><title>Who Is an Object?</title><link rel="canonical"href="https://www.yegor256.com/2016/07/14/who-is-object.html"><link rel="icon"type="image/png"href="/favicon.ico"><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><script type="application/ld+json">{
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2016/07/14/who-is-object.html"
        },
        "headline": "Who Is an Object?",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2016/07/jackass-the-movie.jpg",
          "height": 675,
          "width": 1200
        },
        "datePublished": "2016-07-14",
        "dateModified": "2016-07-14",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "The definition of an object is fundamental to
the entire object-oriented programming paradigm, but
it is not defined correctly in most books.
",
        "keywords": ["object", "object in oop", "oop object", "object definition in oop", "what is object in oop"]
      }</script><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript><link rel="stylesheet"href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500"><style amp-custom="amp-custom">@font-face{font-family:Cambria;src:url(https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf)}body{font-family:Cambria,'Times New Roman',serif;padding:.5em;font-size:1.2em}article{width:600px;max-width:100%;margin-left:auto;margin-right:auto}code,pre{font-family:'Source Code Pro','Courier New',monospace;font-size:.8em}code{padding:0 .3em;background-color:#d3d3d3}a,a:hover,a:visited{color:inherit}.intro{color:red;font-size:.75em}.photo{border-radius:50%}pre{overflow-x:scroll}</style><script async src="https://cdn.ampproject.org/v0.js"></script><article><p class="intro">This is a mobile version, full one is <a href="https://www.yegor256.com/2016/07/14/who-is-object.html">here</a>.<p><amp-img src="/images/face-256x256.jpg"width="80"height="80"alt="Yegor Bugayenko"class="photo"></amp-img><p>Yegor Bugayenko<br>14 July 2016<h1>Who Is an Object?</h1><p>There are thousands of books about object-oriented programming and hundreds of object-oriented languages, and I believe most (read “all”) of them give us an incorrect definition of an “object.” That’s why the entire OOP world is so full of misconceptions and mistakes. Their definition of an object is limited by the hardware architecture they are working with and that’s why is very primitive and mechanical. I’d like to introduce a better one.</p><amp-img src="/images/2016/07/jackass-the-movie.jpg"alt="Jackass: The Movie (2002) by Jeff Tremaine"height="675"width="1200"layout="responsive"></amp-img><p>What is an object? I’ve done a little research, and this is what I’ve found:<ul><li><p>“Objects may contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods”—<a href="https://en.wikipedia.org/wiki/Object-oriented_programming">Wikipedia</a> at the time of writing.<li><p>“An object stores its state in fields and exposes its behavior through methods”—<a href="https://docs.oracle.com/javase/tutorial/java/concepts/object.html">What Is an Object?</a> by Oracle.<li><p>“Each object looks quite a bit like a little computer—it has a state, and it has operations that you can ask it to perform”—<a href="https://amzn.to/1PBmQpm">Thinking in Java</a>, 4th Ed., Bruce Eckel, p. 16.<li><p>“A class is a collection of data fields that hold values and methods that operate on those values”—<a href="https://amzn.to/28PEqSi">Java in a Nutshell</a>, 6th Ed., Evans and Flanagan, p. 98.<li><p>“An object is some memory that holds a value of some type”—<a href="https://amzn.to/1XyGCtk">The C++ Programming Language</a>, 4th Ed., Bjarne Stroustrup, p. 40.<li><p>“An object consists of some private memory and a set of operations”—<a href="https://amzn.to/1UhYinp">Smalltalk-80</a>, Goldberg and Robson, p. 6.</ul><p>What is common throughout all these definitions is the word “contains” (or “holds,” “consists,” “has,” etc.). They all think that an object is a <em>box with data</em>. And this perspective is exactly what I’m strongly against.<p>If we look at how C++ or Java are implemented, such a definition of an object will sound <em>technically</em> correct. Indeed, for each object, Java Virtual Machine allocates a few bytes in memory in order to store object attributes there. Thus, we can technically say, in that language, that an object is an in-memory box with data.<p>Right, but this is just a corner case!<p>Let’s try to imagine another object-oriented language that doesn’t store object attributes in memory. Confused? Bear with me for a minute. Let’s say that in that language we define an object:<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c {
  vin: v,
  engine: e
}
</code></pre></div></div><p>Here, <code class="language-plaintext highlighter-rouge">vin</code> and <code class="language-plaintext highlighter-rouge">engine</code> are attributes of object <code class="language-plaintext highlighter-rouge">c</code> (it’s a car; let’s forget about classes for now to focus strictly on objects). Thus, there is a simple object that has two attributes. The first one is car’s VIN, and the second one is its engine. The VIN is an object <code class="language-plaintext highlighter-rouge">v</code>, while the engine is <code class="language-plaintext highlighter-rouge">e</code>. To make it easier to understand, this is how a similar object would look in Java:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span><span class="o">[]</span> <span class="n">v</span> <span class="o">=</span> <span class="o">{</span><span class="sc">'W'</span><span class="o">,</span><span class="sc">'D'</span><span class="o">,</span><span class="sc">'B'</span><span class="o">,</span><span class="sc">'H'</span><span class="o">,...</span><span class="sc">'7'</span><span class="o">,</span><span class="sc">'2'</span><span class="o">,</span><span class="sc">'8'</span><span class="o">,</span><span class="sc">'8'</span><span class="o">};</span> <span class="c1">// 17 chars</span>
<span class="nc">Engine</span> <span class="n">e</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Engine</span><span class="o">();</span>
<span class="nc">Car</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Car</span><span class="o">(</span><span class="n">v</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
</code></pre></div></div><p>I’m not entirely sure about JVM, but in C++ such an object will take exactly 25 bytes in memory (assuming it’s 64-bit x86 architecture). The first 17 bytes will be taken by the array of chars and another 8 bytes by a pointer to the block in memory with object <code class="language-plaintext highlighter-rouge">e</code>. That’s how the C++ compiler understands objects and translates them to the x86 architecture. In C++, objects are just data structures with clearly defined allocation of data attributes.<p>In that example, attributes <code class="language-plaintext highlighter-rouge">vin</code> and <code class="language-plaintext highlighter-rouge">engine</code> are not equal: <code class="language-plaintext highlighter-rouge">vin</code> is “data,” while <code class="language-plaintext highlighter-rouge">engine</code> is a “pointer” to another object. I intentionally made it this way in order to demonstrate that calling an object a box with data is possible only with <code class="language-plaintext highlighter-rouge">vin</code>. Only when the data are located right “inside” the object can we say that the object is actually a box for the data. With <code class="language-plaintext highlighter-rouge">engine</code>, it isn’t really true because there is no data technically <em>inside</em> the object. Instead, there is a <em>pointer</em> to another object. If our object would only have an <code class="language-plaintext highlighter-rouge">engine</code> attribute, it would take just 8 bytes in memory, with none of them actually occupied by “data.”<p>Now, let’s get back to our new pseudo language. Let’s imagine it treats objects very differently than C++—it doesn’t keep object attributes in memory <em>at all</em>. It doesn’t have pointers, and it doesn’t know anything about x86 architecture. It just <em>knows</em> somehow what attributes belong to an object.<p>Thus, in our language, objects are no longer boxes with data both technically and conceptually. They know where the data is, but they don’t <em>contain</em> the data. They <em>represent</em> the data, as well as other objects and entities. Indeed, the object <code class="language-plaintext highlighter-rouge">c</code> in our imaginary language represents two other objects: a VIN and an engine.<p>To summarize, we have to understand that even though a mechanical definition of an object is correct in most programming languages on the market at the moment, it is very incorrect conceptually because it treats an object as a box with data that are too visible to the outside world. That visibility provokes us to think <em>procedurally</em> and try to access that data as much as possible.<p>If we would think of an object as a <strong>representative</strong> of data instead of a container of them, we would not want to get a hold of data as soon as possible. We would understand that the data are far away and we can’t just easily touch them. We should communicate with an object—and how exactly it communicates with the data is not our concern.<p>I hope that in the near future, the market will introduce new object-oriented languages that won’t store objects as in-memory data structures, even technically.<p>By the way, here is the definition of an object from my favorite book, <a href="https://amzn.to/266oJr4">Object Thinking</a> by David West, p. 66:<blockquote><p>An object is the equivalent of the quanta from which the universe is constructed</blockquote><p>What do you think? Is it close to the “representative” definition I just proposed?</article>