<!doctypehtml><html amp lang="en"><meta charset="utf-8"><title>How Much Cohesion Is Enough?</title><link rel="canonical"href="https://www.yegor256.com/2019/11/19/how-much-cohesion-is-enough.html"><link rel="icon"type="image/png"href="/favicon.ico"><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><script type="application/ld+json">{
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2019/11/19/how-much-cohesion-is-enough.html"
        },
        "headline": "How Much Cohesion Is Enough?",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2019/11/irreversible.jpg",
          "height": 938,
          "width": 2202
        },
        "datePublished": "2019-11-19",
        "dateModified": "2019-11-19",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "There are two extreme cases: all methods in a single
large class or a large number of small classes; which
one do you prefer?
",
        "keywords": ["srp principle", "abstraction layers", "separation of concerns", "oop layers", "oop design"]
      }</script><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript><link rel="stylesheet"href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500"><style amp-custom="amp-custom">@font-face{font-family:Cambria;src:url(https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf)}body{font-family:Cambria,'Times New Roman',serif;padding:.5em;font-size:1.2em}article{width:600px;max-width:100%;margin-left:auto;margin-right:auto}code,pre{font-family:'Source Code Pro','Courier New',monospace;font-size:.8em}code{padding:0 .3em;background-color:#d3d3d3}a,a:hover,a:visited{color:inherit}.intro{color:red;font-size:.75em}.photo{border-radius:50%}pre{overflow-x:scroll}</style><script async src="https://cdn.ampproject.org/v0.js"></script><article><p class="intro">This is a mobile version, full one is <a href="https://www.yegor256.com/2019/11/19/how-much-cohesion-is-enough.html">here</a>.<p><amp-img src="/images/face-256x256.jpg"width="80"height="80"alt="Yegor Bugayenko"class="photo"></amp-img><p>Yegor Bugayenko<br>19 November 2019<h1>How Much Cohesion Is Enough?</h1><p>Which one is better: <code class="language-plaintext highlighter-rouge">books.del(42)</code> or <code class="language-plaintext highlighter-rouge">books.book(42).del()</code>? I do both and I rarely can tell which one is better. The first option is shorter, while the second one is more object-oriented. The first option is more difficult to extend, while the second one is more verbose and requires more lines of code, which means a higher chance of making mistakes. Which one do you prefer?</p><amp-img src="/images/2019/11/irreversible.jpg"alt="Irréversible (2002) by Gaspar Noé"height="938"width="2202"layout="responsive"></amp-img><p>Either one will work, of course, but the question is which design is more object-oriented? It seems to depend on the size of the object <code class="language-plaintext highlighter-rouge">books</code>. If it’s small, there’s no need to get the book first, we can just delete it right there:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Books</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">create</span><span class="o">(</span><span class="nc">String</span> <span class="n">title</span><span class="o">);</span>
  <span class="kt">void</span> <span class="nf">delete</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">);</span>
  <span class="kt">void</span> <span class="nf">rename</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">,</span> <span class="nc">String</span> <span class="n">title</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>However, if it’s larger, it’s better to get the <code class="language-plaintext highlighter-rouge">book</code> first:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Book</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">delete</span><span class="o">();</span> <span class="c1">// Here!</span>
  <span class="kt">void</span> <span class="nf">rename</span><span class="o">(</span><span class="nc">String</span> <span class="n">title</span><span class="o">);</span>
<span class="o">}</span>
<span class="kd">interface</span> <span class="nc">Books</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">create</span><span class="o">(</span><span class="nc">String</span> <span class="n">title</span><span class="o">);</span>
  <span class="kt">int</span> <span class="nf">total</span><span class="o">();</span>
  <span class="nc">Iterable</span><span class="o">&lt;</span><span class="nc">Book</span><span class="o">&gt;</span> <span class="nf">all</span><span class="o">();</span>
  <span class="nc">Book</span> <span class="nf">all</span><span class="o">(</span><span class="nc">String</span> <span class="n">query</span><span class="o">);</span>
  <span class="nc">Book</span> <span class="nf">book</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">);</span> <span class="c1">// Here!</span>
<span class="o">}</span>
</code></pre></div></div><p>Is there an explicit hard line between these two? Is there a <a href="/2017/12/19/srp-is-hoax.html">strict rule</a> or maybe the ambiguous question “Is this class large enough already?” should be answered every time by a vote?<p>Let’s try to give two extreme answers: 1) never large enough, and 2) always large enough.<ul><li><p>If a class is <em>never</em> ready for extracting any parts of it and turning them into new objects, we will end up with a very big class, with many attributes, methods, and long lists of arguments in almost all of them.<li><p>If a class is <em>always</em> good enough for extractions, we will end up with <a href="/2017/02/28/too-many-classes.html">many small classes</a>, methods with almost no arguments, and … a better object-oriented design.</ul><p>The common denominator is <a href="https://en.wikipedia.org/wiki/Cohesion_%28computer_science%29"><em>cohesion</em></a>.<p>Highly cohesive classes include attributes and methods that are related to each other, while non-cohesive classes include whatever their developers decided to add, even though some elements may not really belong together. The first answer will give us a class with a very low cohesion, while the second one will produce a large amount of highly cohesive small classes.<p>Thus, the second option is better? Yes, it is. Smaller classes, higher cohesion, … but more opportunities to lose focus and spread functionality around too many places. “All methods in one object” is a much more popular design, even though it’s less cohesive, exactly because it’s easier to create: just put everything in one place and call it a day. Later, of course, maintainability problems will show up.<p>The bottom line is that there is no exact distinction between the right and the wrong design in this case. We just have to do our best to keep classes highly cohesive by decreasing the amount of methods in each of them. If there are just a few methods, no need to extract the <code class="language-plaintext highlighter-rouge">Book</code>, but once the amount of methods gets bigger, the <code class="language-plaintext highlighter-rouge">Book</code> is a perfect candidate for a new entity to define.<p>How many methods is OK?<p><a href="https://softwareengineering.stackexchange.com/questions/104406/">Nobody knows</a>, but I would suggest you question the cohesion of your class once you see more than seven methods or more than four attributes. Also, start thinking about refactoring when any of your methods (except constructors) accepts more than two arguments.<blockquote class="twitter-tweet"><p lang="en"dir="ltr">Which design is better? <a href="https://twitter.com/hashtag/elegantobjects?src=hash&amp;ref_src=twsrc%5Etfw">#elegantobjects</a></p>— Yegor Bugayenko (@yegor256) <a href="https://twitter.com/yegor256/status/1198599871495835649?ref_src=twsrc%5Etfw">November 24, 2019</a></blockquote></article>