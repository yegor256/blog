<!doctypehtml><html amp lang="en"><meta charset="utf-8"><title>How Data Visibility Hurts Maintainability</title><link rel="canonical"href="https://www.yegor256.com/2019/03/12/data-and-maintainability.html"><link rel="icon"type="image/png"href="/favicon.ico"><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><script type="application/ld+json">{
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2019/03/12/data-and-maintainability.html"
        },
        "headline": "How Data Visibility Hurts Maintainability",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2019/03/taboo.jpg",
          "height": 1073,
          "width": 1906
        },
        "datePublished": "2019-03-12",
        "dateModified": "2019-03-12",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "In object-oriented programming, the more visible
and accessible object attributes are, the lower
the maintainability of the code around it.
",
        "keywords": ["object-oriented", "object-oriented spaghetti code", "spaghetti code", "object-oriented maintainability", "object-oriented readability"]
      }</script><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript><link rel="stylesheet"href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500"><style amp-custom="amp-custom">@font-face{font-family:Cambria;src:url(https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf)}body{font-family:Cambria,'Times New Roman',serif;padding:.5em;font-size:1.2em}article{width:600px;max-width:100%;margin-left:auto;margin-right:auto}code,pre{font-family:'Source Code Pro','Courier New',monospace;font-size:.8em}code{padding:0 .3em;background-color:#d3d3d3}a,a:hover,a:visited{color:inherit}.intro{color:red;font-size:.75em}.photo{border-radius:50%}pre{overflow-x:scroll}</style><script async src="https://cdn.ampproject.org/v0.js"></script><article><p class="intro">This is a mobile version, full one is <a href="https://www.yegor256.com/2019/03/12/data-and-maintainability.html">here</a>.<p><amp-img src="/images/face-256x256.jpg"width="80"height="80"alt="Yegor Bugayenko"class="photo"></amp-img><p>Yegor Bugayenko<br>12 March 2019<h1>How Data Visibility Hurts Maintainability</h1><p>I’ve been writing <a href="/tags/oop.html">so much</a> about object-oriented programming and its <a href="/2016/02/03/design-patterns-and-anti-patterns.html">pitfalls</a>, claiming that most of the design patterns and “good practices” which we are accustomed to are actually <a href="/2014/09/10/anti-patterns-in-oop.html">wrong and hurtful</a>, that I totally forgot to explain the bigger picture problem. Someone <a href="https://www.yegor256.com/2016/11/21/naked-data.html#comment-3879044054">asked</a> me some time ago in the <a href="/2016/11/21/naked-data.html">blog post</a> about “naked” data: What is the problem we are solving and why exactly does maintainability suffer if we don’t <em>encapsulate</em> our data enough? Here is the answer.</p><amp-img src="/images/2019/03/taboo.jpg"alt="Taboo (2017) by Tom Hardy, et al."height="1073"width="1906"layout="responsive"></amp-img><p>I re-read the first few pages of <a href="/elegant-objects.html"><em>Elegant Objects, Volume 1</em></a>, my book entirely dedicated to the problem of modern object-oriented programming <a href="/2016/08/15/what-is-wrong-object-oriented-programming.html">flaws</a>, and found out that maintainability is directly mentioned there: “The main goal I’m trying to achieve with this writing is to increase the <em>maintainability</em> of your code,” and then it also explains that maintainability is “the time required for me to understand your code.” You <a href="https://softwareengineering.stackexchange.com/questions/141005">can argue with that</a>, but the question remains: how does the lack of “true” object-orientation and proper encapsulation hurt readability?<p>I don’t know the exact answer, but here is my own version, derived from my years of coding and suffering: <em>smaller scope</em> is the key success factor of better maintainability, and lack of encapsulation leads to a larger scope. You know what <a href="https://en.wikipedia.org/wiki/Scope_%28computer_science%29">scope of visibility</a> is, right? Let’s take this C code as an example:<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">print</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d * 2 = %d"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d * 3 = %d"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>There are two variables <code class="language-plaintext highlighter-rouge">i</code>, visible in two different <code class="language-plaintext highlighter-rouge">for</code> loops, two different scopes of visibility. The <em>size</em> of each scope is three lines of code. How about this code, doing exactly the same:<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">print</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d * 2 = %d"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">i</span> <span class="o">-=</span> <span class="mi">10</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d * 3 = %d"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>Now, the scope of visibility of <code class="language-plaintext highlighter-rouge">i</code> is ten lines of code. The code works as well as in the first snippet, but its maintainability is lower, because in order to understand what’s going on and how to modify it, I need more time. I need to read a 10-line block of code, instead of two 3-line blocks. I need to understand the entire method <code class="language-plaintext highlighter-rouge">print()</code> before I can start making any modifications. I need to understand the lifetime algorithm of that poor <code class="language-plaintext highlighter-rouge">i</code> and why, for example, it gets decremented by 10 instead of being reassigned to zero—this is the surprise previous programmers left for me. Maybe they were not aware of the existence of <code class="language-plaintext highlighter-rouge">for</code> loops?<p>It’s obvious that the first snippet is better than the second one. The question is how do we <em>make</em> programmers write code the way the first snippet is written and make the scope of each variable and function smaller? We can teach them, write books for them, convince them, train them, or maybe even punish them for larger scope and less readable code, but if the programming language itself doesn’t prevent these large scopes from happening, nothing will really help. It’s better to <a href="/2016/11/29/eolang.html">invent</a> a programming language or an entire programming paradigm to make it harder, or impossible, to grow the scope.<p>For example, the largest scope you can imagine in C/C++, Python, Ruby and many other modern languages is the <a href="/2018/07/03/global-variables.html">global</a> one, for example here:<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d * 2 = %d"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>Now the variable <code class="language-plaintext highlighter-rouge">i</code> is visible not only inside the function <code class="language-plaintext highlighter-rouge">print()</code> but in <del>many</del> all other places of the application we develop. The scope of visibility of <code class="language-plaintext highlighter-rouge">i</code> is the size of the entire code base. Needless to say that makes the code of function <code class="language-plaintext highlighter-rouge">print()</code> <a href="/2018/07/03/global-variables.html">very unreadable</a>. I simply can’t know what value to expect in <code class="language-plaintext highlighter-rouge">i</code> when the execution of <code class="language-plaintext highlighter-rouge">print()</code> starts—I have to go through the entire code base to find it out. If it’s a small app, maybe I will manage, but if it’s a large piece of software, I will have big troubles. So, how about we create a programming language, which will not allow global variables? This will solve the problem. Programmers will have no technical ability to define them and their scopes will inevitably be smaller.<p>I believe that objects <a href="/2017/12/12/alan-kay-was-wrong.html">were invented</a> exactly to do that: to <em>force</em> programmers to keep their scopes of visibility smaller. Well, actually, functions and sub-routines were invented for that too, but with a less strong emphasis on the “force” part, since they could co-exist with code parts that were not decomposed yet. To the contrary, objects were supposed to be first-class citizens of an object world, communicating with objects only.<p>They were.<p>But then C++ showed up and ruined everything.<p>Let’s try to introduce an object to our C snippet, the way <del>most</del> some C++ programmers would do it:<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Idx</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">int</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">v</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">v</span> <span class="o">+=</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>And then:<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">print</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Idx</span> <span class="n">i</span><span class="p">();</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d * 2 = %d"</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">i</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">i</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d * 3 = %d"</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">i</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">*</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">i</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>What changed? Not much. Instead of a plain “scalar” variable <code class="language-plaintext highlighter-rouge">i</code> we have an “object,” which stores an integer value inside and provides a few methods to access it and modify it. Did it help us minimize the scope? Not at all. Moreover, the length of <code class="language-plaintext highlighter-rouge">print()</code> is now even a few lines longer. But now we have an object and can call our code object-oriented!<p>This is how most of the “objects” are used nowadays, mostly thanks to C++: they are just data holders, while the real users of the data are still outside of them. The object <code class="language-plaintext highlighter-rouge">Idx</code> doesn’t know anything about the real purpose of the data it holds. It doesn’t know that its <code class="language-plaintext highlighter-rouge">v</code> is used as a step counter and that it gets multiplied by something before printing some text. <code class="language-plaintext highlighter-rouge">Idx</code> is a data holder, while the real logic is outside of it.<p>The maintainability problem is not solved, the scope is not smaller, the complexity of the code is not reduced. Moreover, it is increased, because now, in order to understand how <code class="language-plaintext highlighter-rouge">print()</code> works, I have to know what is inside the <code class="language-plaintext highlighter-rouge">Idx</code>. The object paradigm in this particular example made a promise to take part of the problem and let me never worry about it, but in reality it only made the problem larger, by giving me back two problems: <code class="language-plaintext highlighter-rouge">print()</code> and <code class="language-plaintext highlighter-rouge">Idx</code>.<p>Why is this thanks to C++? Because C++ added object-orientation on top of C procedural programming ideas, never even thinking about prohibiting some of them, to <em>force</em> programmers to write objects the way they are supposed to be written: as black boxes that encapsulate everything they need and never allow anyone from the outside to even <em>know</em> what’s inside! C++ didn’t even make an attempt to switch the paradigm from procedures and variables to objects and methods. <a href="https://en.wikipedia.org/wiki/Bjarne_Stroustrup">Bjarne Stroustrup</a>, the creator of C++, just gave programmers methods and classes and said: “Use them, they are more convenient than variables, … or maybe not, sometimes, … I don’t know” (I’m not sure it’s his quote, but I believe that it’s very close to what he had in mind). Read <a href="https://amzn.to/2uMlANB">his book</a>, and you will see how many pages are dedicated to the philosophy of object orientation and how many to the technicalities of operators and statements.<p>A proper object-oriented solution would look different and would involve true encapsulation, where data never “escapes” the borders of its owner. First, here is how I would design <code class="language-plaintext highlighter-rouge">Idx</code>… well, I would rename it first and call it <code class="language-plaintext highlighter-rouge">Line</code>:<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Line</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Line</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">)</span><span class="o">:</span> <span class="n">mul</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">{};</span>
  <span class="kt">void</span> <span class="nf">print</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d * %d = %d"</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">v</span> <span class="o">*</span> <span class="n">m</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kt">bool</span> <span class="nf">next</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">++</span><span class="n">v</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">n</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
  <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">mul</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>And now here is the code of <code class="language-plaintext highlighter-rouge">print()</code>:<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">print</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Line</span> <span class="n">a</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">next</span><span class="p">())</span> <span class="p">{</span> <span class="n">a</span><span class="p">.</span><span class="n">print</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">Line</span> <span class="nf">b</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">next</span><span class="p">())</span> <span class="p">{</span> <span class="n">b</span><span class="p">.</span><span class="n">print</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div><p>As you see, <code class="language-plaintext highlighter-rouge">print()</code> doesn’t have any access to the internal data of <code class="language-plaintext highlighter-rouge">Line</code>. All <code class="language-plaintext highlighter-rouge">print()</code> can do is ask the <code class="language-plaintext highlighter-rouge">Line</code> to move forward and print itself. How exactly this logic is implemented inside the <code class="language-plaintext highlighter-rouge">Line</code>—nobody knows and nobody wants to know. Since we don’t have any <a href="/2014/09/16/getters-and-setters-are-evil.html">getters</a> in the <code class="language-plaintext highlighter-rouge">Line</code>, we can’t fetch the data out of it.<p>Since we can’t get the data out, we can’t build any logic in the <code class="language-plaintext highlighter-rouge">print()</code>. We simply have nothing to work with, no data, no integers, no numbers. We can only deal with objects, which don’t trust us with their internals. We can only <em>politely</em> ask them to do something for us. The scope of <code class="language-plaintext highlighter-rouge">print()</code> is pretty small now and very well <em>isolated</em> from the internals of the <code class="language-plaintext highlighter-rouge">Line</code>. Proper encapsulation helped us achieve that: by not exposing the internals of the <code class="language-plaintext highlighter-rouge">Line</code> we made it impossible for anyone to invite themselves into its own scope. The <code class="language-plaintext highlighter-rouge">print()</code> simply can’t do anything with the data encapsulated by the <code class="language-plaintext highlighter-rouge">Line</code>.<p>Thus, the more visible and accessible the data is, the lower the maintainability.<p>The very idea of object-oriented programming is based on encapsulation, which doesn’t mean just restricting the ability to modify object attributes from the outside, but also prohibiting everyone from reading those attributes.<blockquote class="twitter-tweet"data-lang="en"><p lang="en"dir="ltr">What is wrong with this Java object? <a href="https://twitter.com/hashtag/elegantobjects?src=hash&amp;ref_src=twsrc%5Etfw">#elegantobjects</a> <a href="https://twitter.com/hashtag/java?src=hash&amp;ref_src=twsrc%5Etfw">#java</a><br><br>final class Time {<br>int getHours();<br>int getMinutes();<br>int getSeconds();<br>}</p>— Yegor Bugayenko (@yegor256) <a href="https://twitter.com/yegor256/status/1109750701285142533?ref_src=twsrc%5Etfw">March 24, 2019</a></blockquote></article>