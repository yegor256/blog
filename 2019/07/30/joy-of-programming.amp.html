<!doctypehtml><html amp lang="en"><meta charset="utf-8"><title>The Joy of Programming</title><link rel="canonical"href="https://www.yegor256.com/2019/07/30/joy-of-programming.html"><link rel="icon"type="image/png"href="/favicon.ico"><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><script type="application/ld+json">{
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2019/07/30/joy-of-programming.html"
        },
        "headline": "The Joy of Programming",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2019/07/boardwalk-empire.jpg",
          "height": 900,
          "width": 1600
        },
        "datePublished": "2019-07-30",
        "dateModified": "2019-07-30",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "If I don't understand the logic of my code down to its
lowest level, I feel depressed and don't get any joy
out of my work; I do want to know what's inside!
",
        "keywords": ["complexity", "complexity of code", "spring framework", "depression programmer", "programmer depression"]
      }</script><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript><link rel="stylesheet"href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500"><style amp-custom="amp-custom">@font-face{font-family:Cambria;src:url(https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf)}body{font-family:Cambria,'Times New Roman',serif;padding:.5em;font-size:1.2em}article{width:600px;max-width:100%;margin-left:auto;margin-right:auto}code,pre{font-family:'Source Code Pro','Courier New',monospace;font-size:.8em}code{padding:0 .3em;background-color:#d3d3d3}a,a:hover,a:visited{color:inherit}.intro{color:red;font-size:.75em}.photo{border-radius:50%}pre{overflow-x:scroll}</style><script async src="https://cdn.ampproject.org/v0.js"></script><article><p class="intro">This is a mobile version, full one is <a href="https://www.yegor256.com/2019/07/30/joy-of-programming.html">here</a>.<p><amp-img src="/images/face-256x256.jpg"width="80"height="80"alt="Yegor Bugayenko"class="photo"></amp-img><p>Yegor Bugayenko<br>30 July 2019<h1>The Joy of Programming</h1><p>Yesterday I was working with a slide deck for one of my future talks about Java and object-oriented programming and got stuck at finding convincing arguments for the <em>transparency of logic</em>. I was going to say that it is important for programmers to be able to understand how everything they do works, even if they don’t see it or never want to see it. But then I realized that maybe not everybody thinks that way. Maybe some programmers prefer to stay in the dark about the majority of things, as long as the code in front of them “just works.” Hence this blog post, to ask you which side you are on.</p><amp-img src="/images/2019/07/boardwalk-empire.jpg"alt="Boardwalk Empire (2010–2014) by Terence Winter"height="900"width="1600"layout="responsive"></amp-img><p>Many years ago I was at a job interview as a candidate. They were looking for a web architect and I was talking to their CTO. He asked me to explain what happens behind the scenes when we enter a new URL in a web browser and hit “Enter”. I drew him a small diagram with a domain registrar, a few DNS servers, a load balancer, a few HTTP servers, a few databases, and a few IP relays in the middle. I believe he was impressed by the answer (even though they didn’t hire me back then) and told me that the majority of web developers didn’t understand most of this picture. According to him, they only knew how HTTP servers worked, caring very little about the rest. Most of them didn’t even know what HTTP was, as long as the PHP code did what it was intended to.<p>I remembered that interview, and started asking similar questions to people I was interviewing later, being a CTO of my own company and an architect on a few other projects. His conclusions were confirmed. Indeed, most programmers don’t understand how, for example, DNS works nor what it’s for. Moreover, they feel just fine without this information. Does it mean they are bad programmers?<p>Let me tell you another story, which just happened to me a few days ago. I was solving a pretty complex technical problem, trying to integrate software I hadn’t had a chance to use before with another piece of software I also hadn’t seen before. It took three full days of work. Now I’m looking back at this short journey and realizing that I went through a few particular phases, which are always the same for me when I start working with something new:<ul><li><p><strong>Enthusiasm</strong>. Here I start quickly, usually from a Quick Start one-pager of the new library I’m going to use. I skim through the documentation, ignore the majority of it, since it doesn’t make any sense, and quickly copy-paste what they recommend. It all seems easy and I’m expecting the code to work in a few minutes. And usually it does.<li><p><strong>Guessing</strong>. I start making changes to the simple code I just copy-pasted and I make some assumptions about the logic behind it. I don’t know how the products I’m using are designed, but I need to rely on something. So, I rely on what I can <em>guess</em>.<li><p><strong>Frustration</strong>. Obviously, most of my assumptions are wrong. I start googling and stackoverflowing. The answers I get (if I get any) are not helping much, since the big picture is still missing and the best I can do is patch my code to make it work, according to the pieces of advice I’m getting from random sources. But I keep staying in the dark and the overall design concept is still not clear. And I’m still hoping to solve it all without reading the full Developers Manual manuscript.<li><p><strong>Depression</strong>. Very soon I realize that I’m just a monkey trying to start an aircraft. Maybe it will fly and maybe I will even manage to land it. But I’m still a monkey and it’s very depressing. I have no joy in doing this. I hate myself for being stupid. I hate those library creators for making it so not obvious to use. And I hate my job.</ul><p>I believe these four phases are very common for all of us software engineers. However, what happens afterwards distinguishes good programmers from bad ones. To be honest, I belong to both categories, depending on the situation. What do I do when I’m being a bad programmer? I make it all work and call it a day, still with no idea what is going on inside nor why exactly it works this way and doesn’t work the way I tried before. My depression doesn’t go anywhere. It only escalates. I still hate myself, but my software works. I move on to the next problem, waiting for the weekend to come.<p>What do I do when I’m a good programmer? I dive deeper into the problem, learn the software I use, download its source code, read its documentation, until I <em>understand</em> what’s going on. Then, I get back to my part of the code, fix it with a full understanding, and call it a day. I sometimes even write a blog post about it, like this one for <a href="/2019/04/17/nutch-from-java.html">Nutch</a>, this one about <a href="/2014/07/20/liquibase-in-maven.html">Liquibase</a>, or this one about <a href="/2014/06/21/casperjs-with-maven.html">CasperJS</a>. My depression completely goes away. I don’t hate myself anymore, don’t hate my job, and don’t hate the developers of those “stupid” libraries. I even help their projects with my blog posts.<p>How do I decide which way to choose: to behave like a bad programmer or like a good one? You may think it depends on the time/budget I have for the job at hand, but you would be wrong. It totally depends on my <em>readiness</em> to live in depression.<p>Some time ago I told myself that I won’t do it anymore. I don’t want to be a <em>monkey</em> flying an aircraft. I want to be a <em>pilot</em>. Of course, the learning curve will be longer, but the result is … joy. I do enjoy my work when I clearly and transparently see the logic of every line of code I write. I know exactly why I write them, what they do, and what will happen if I change them. I don’t know all the details, of course, I know where to click in order to find those details. This is what makes my work fun for me: the transparency of my coding logic.<p>I truly enjoy being in charge of everything my code does. I love to feel that it does exactly what I want it to do. You may say I’m a control freak—maybe so. But this is where I’ve been getting most of the fun, over the last 30 years of coding: seeing computers do what I want. If some libraries try to take this away from me, putting me in the passenger’s seat, I will do everything I can to get back in the driving seat. I want to know what’s going on and I want this to happen according to my will. I want to enjoy my work.<p>Now, back to my conference talk. I’m going to show this piece of code in one of my slides (this is how <a href="https://spring.io/">Spring Framework</a> is supposed to be used):<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloController</span> <span class="o">{</span>
    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/hello"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">handle</span><span class="o">(</span><span class="nc">Model</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"message"</span><span class="o">,</span> <span class="s">"Hello World!"</span><span class="o">);</span>
        <span class="k">return</span> <span class="s">"index"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>Then I will ask a question: Do you know who is making an instance of the <code class="language-plaintext highlighter-rouge">HelloController</code> class and how that instance is being used? Who is calling its methods, why and when? Moreover, do you know how to modify that behavior? My point at the conference will be that a good framework must make it easier for its users to understand its <em>internals</em>. Because good programmers do want to know what’s inside. Bad programmers, on the other hand, are OK with being aircraft-flying monkeys.<p>What about you?</article>