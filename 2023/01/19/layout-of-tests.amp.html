<!DOCTYPE html>
<html amp lang="en">
  <head>

    <meta charset="utf-8">
    <title>On the Layout of Tests</title>
    <link rel="canonical" href="https://www.yegor256.com/2023/01/19/layout-of-tests.html">
    <link rel="icon" type="image/png" href="/favicon.ico">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2023/01/19/layout-of-tests.html"
        },
        "headline": "On the Layout of Tests",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2022/11/mimino.jpg",
          "height": 924,
          "width": 1643
        },
        "datePublished": "2023-01-19",
        "dateModified": "2023-01-19",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "What is the right way to keep test classes in a repository?
There is no single canonical approach, but a few principles may help
you keep test files in order.
",
        "keywords": ["test methods", "java test organization", "how to structure test classes", "test methods design", "layout of tests classes"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500">
    <style amp-custom="amp-custom">
      @font-face {
        font-family: 'Cambria';
        src: url('https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf');
      }
      body { font-family: 'Cambria', 'Times New Roman', serif; padding: .5em; font-size: 1.2em; }
      article { width: 600px; max-width: 100%; margin-left: auto; margin-right: auto; }
      pre, code { font-family: 'Source Code Pro', 'Courier New', monospace; font-size: .8em; }
      code { padding: 0 .3em; background-color: lightgray; }
      a, a:hover, a:visited { color: inherit; }
      .intro { color: red; font-size: .75em; }
      .photo { border-radius: 50%; }
      pre { overflow-x:scroll; }
    </style>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <article>
      <p class="intro">
        This is a mobile version, full one is
        <a href="https://www.yegor256.com/2023/01/19/layout-of-tests.html">here</a>.
      </p>
      <p>
        <amp-img src="/images/face-256x256.jpg" width="80" height="80" alt="Yegor Bugayenko" class="photo"></amp-img>
      </p>
      <p>Yegor Bugayenko<br>19 January 2023</p>
      <h1>On the Layout of Tests</h1>
      <p>I don’t know what programming language you use, but my experience
of recent coding in Java, Ruby, JavaScript, PHP, Python, C++, and Rust tells
me that the principle, which I will try to convince you to adhere
to—is universal for all languages. It’s about the naming of test files.
It may look to you like a question of low importance, but let me try
to demonstrate that it’s not. How do you name your files with test classes? How many
of them do you create in the src/test/java directory? Where do you place
a class that is used only in a test but is not a test by itself? To most of these
questions, the answer most of you would give is “Whatever!”
So let’s try to find a better answer.</p>



<amp-img src="/images/2022/11/mimino.jpg" alt="Мимино (1977) by Георгий Данелия" height="924" width="1643" layout="responsive"></amp-img>

<p>The primary purpose of my unit tests is to help me code. They are the
<a href="/2022/07/05/safety-net.html">safety net</a>—they
catch me when I make a mistake. For example, let’s say I go back and edit a few files that I
edited a few years ago and, of course, I do it wrong this time. Then, I run all 500 unit tests
in the project, and … ten of them turn red. Pay attention, I don’t say “fail” because,
just like a safety net around a building, failed tests are the tests
that didn’t catch a falling hammer and didn’t spot a bug just introduced.
Thus, 490 of them <em>failed</em>, but ten of them <em>succeeded</em>.</p>

<h2 id="assertions">Assertions</h2>

<p>Next, I scratch my head and think—what exactly did I do wrong? Which
file did I break? I just changed a few dozen code lines. Where exactly was the
mistake? In order to find out, I read the output of the tests. I expect
the messages they print to the console to be descriptive enough to
help me understand the problem. I don’t want to revert all my changes
and start from scratch, right? I want to quickly jump to the line with
the bug, fix it, rerun all 500 tests, see all of them green,
commit my changes and call it a day.</p>

<p>Needless to say, descriptive messages of test assertions
and proper naming of test methods are the recipe for success.
Let’s consider simple object Phrases, where we add
a few English phrases, and it magically understands which
of them are greetings (obviously, using ML).
For such a class, this Java/JUnit5 test would be very bad:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.junit.jupiter.api.Test</span><span class="o">;</span>

<span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">test1</span><span class="o">()</span> <span class="o">{</span>
  <span class="nc">Phrases</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Phrases</span><span class="o">();</span>
  <span class="n">p</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Hello, world!"</span><span class="o">);</span>
  <span class="n">p</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"London is a capital of Great Britain"</span><span class="o">);</span>
  <span class="k">assert</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">greetings</span><span class="o">().</span><span class="na">count</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>While this test is much better, thanks to <a href="https://www.hamcrest.org">Hamcrest</a>
assertions (how to name test methods—is a separate
story explained in detail <a href="https://stackoverflow.com/questions/155436/">here</a>):</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">hamcrest</span><span class="o">.</span><span class="na">MatcherAssert</span><span class="o">.</span><span class="na">assertThat</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">org</span><span class="o">.</span><span class="na">hamcrest</span><span class="o">.</span><span class="na">Matchers</span><span class="o">.</span><span class="na">equalTo</span><span class="o">;</span>

<span class="nd">@Test</span>
<span class="kt">void</span> <span class="nf">countsSimpleGreetings</span><span class="o">()</span> <span class="o">{</span>
  <span class="nc">Phrases</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Phrases</span><span class="o">();</span>
  <span class="n">p</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Hello, world!"</span><span class="o">);</span>
  <span class="n">p</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"London is a capital of Great Britain"</span><span class="o">);</span>
  <span class="n">assertThat</span><span class="o">(</span>
    <span class="s">"Total count of greetings"</span><span class="o">,</span>
    <span class="n">p</span><span class="o">.</span><span class="na">greetings</span><span class="o">().</span><span class="na">count</span><span class="o">(),</span> <span class="n">equalTo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The first snippet will print a pretty obscure error message, while the
second one will help me a lot in my struggle with the bug I just made:
The message will be self-explanatory. I will quickly understand
what the problem is.</p>

<h2 id="test-classes">Test Classes</h2>

<p>Descriptive messages will help me understand what the problem is.
However, will I know <em>where</em> the problem is? In which Java class? Not really.
Is it in <code class="language-plaintext highlighter-rouge">Phrases.java,</code> or maybe in <code class="language-plaintext highlighter-rouge">Greetings.java,</code> which is returned by <code class="language-plaintext highlighter-rouge">Phrases.greetings()</code>?
I can only get this information from the <em>name</em> of the test class.
If it’s called <code class="language-plaintext highlighter-rouge">PhrasesTest.java</code>—all bugs that it catches <em>are most probably</em>
located in <code class="language-plaintext highlighter-rouge">Phrases.java.</code> If it’s called <code class="language-plaintext highlighter-rouge">GreetingsTest.java</code>—… well, you get the idea.</p>

<p>My point is that the name of a test class is not just a name. It’s an instruction
for a wondering programmer:
“Go look into the source file, the name of which you can derive from my name,
removing the <code class="language-plaintext highlighter-rouge">Test</code> suffix.” If I try to follow this instruction and
it leads me nowhere, I get very frustrated, especially if the project
is not mine. I can’t get the required information from anywhere else.
The name of the test class is my last hope.</p>

<h2 id="very-long-test-classes">Very Long Test Classes</h2>

<p>What if a test class gets too long? It may have a few dozen or more test methods. We don’t
want a class to be too big, right? Wrong! A test class is not a class. It’s not even
a utility class. It’s a container for test scripts. It’s called a class because
Java (and many other languages) do not have alternative code
organization instruments. So don’t worry about your test classes getting excessively long. 5000 lines of code
in a test class is <em>not a problem</em> at all. Again, because it’s not a class, it’s only
a collection of test scripts.</p>

<h2 id="test-prerequisites-wrong-way">Test Prerequisites (Wrong Way)</h2>

<p>Very often some classes or functions  are not tests,
but must be shared among tests. (I’m sure you know that sharing tests is an
<a href="/2018/12/11/unit-testing-anti-patterns.html">anti-pattern</a>. Do you?)
Look at how I refactored the unit test from above (it’s not elegant
at all, but bear with me for a moment!):</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">PhrasesTest</span> <span class="o">{</span>
  <span class="nd">@Test</span>
  <span class="kt">void</span> <span class="nf">countsSimpleGreetings</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Phrases</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Phrases</span><span class="o">();</span>
    <span class="n">prepare</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
    <span class="n">assertThat</span><span class="o">(</span>
      <span class="s">"Total count of greetings"</span><span class="o">,</span>
      <span class="n">p</span><span class="o">.</span><span class="na">greetings</span><span class="o">().</span><span class="na">count</span><span class="o">(),</span> <span class="n">equalTo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">);</span>
  <span class="o">}</span>
  <span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">prepare</span><span class="o">(</span><span class="nc">Phrases</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">p</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Hello, world!"</span><span class="o">);</span>
    <span class="n">p</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"London is a capital of Great Britain"</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Here, in private method <code class="language-plaintext highlighter-rouge">prepare(),</code> I have a convenient builder
of the object of class <code class="language-plaintext highlighter-rouge">Phrases.</code> This builder may be beneficial
for other tests, such as <code class="language-plaintext highlighter-rouge">GreetingsTest.</code> I don’t want
to copy it from <code class="language-plaintext highlighter-rouge">PhrasesTest</code> to <code class="language-plaintext highlighter-rouge">GreetingsTest.</code> Instead, I
want to put it somewhere where it can be reused. This would
be the right place for it (<code class="language-plaintext highlighter-rouge">foo</code> is the Java
package that all our classes belong to):</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/
  main/
    java/
      foo/
        Phrases.java
        Greetings.java
  test/
    java/
      foo/
        support/
          FooUtils.java
        PhrasesTest.java
        GreetingsTest.java
</code></pre></div></div>

<p>Static method <code class="language-plaintext highlighter-rouge">FooUtils.prepare()</code> now sits in the <code class="language-plaintext highlighter-rouge">FooUtils</code> utility
class (a terrible <a href="/2014/05/05/oop-alternative-to-utility-classes.html">anti-pattern</a>!),
which is in the package <code class="language-plaintext highlighter-rouge">foo.support</code>. But, pay attention, not in the <code class="language-plaintext highlighter-rouge">foo</code> package, but
in the sub-package that doesn’t have a counterpart in the live code block:
there is no directory <code class="language-plaintext highlighter-rouge">src/main/java/foo/support.</code> This is a clear message
to a programmer who would meet this repository in a few years: all classes
that stay in <code class="language-plaintext highlighter-rouge">foo.support</code> belong to the test pipeline only and are not tests by
themselves.</p>

<h2 id="test-prerequisites-right-way">Test Prerequisites (Right Way)</h2>

<p>As <a href="/2014/05/05/oop-alternative-to-utility-classes.html">you know</a>,
utility classes and <a href="/2017/02/07/private-method-is-new-class.html">private static methods</a>
are the rudiments of imperative programming. The object-oriented world has better alternatives.
JUnit5, in particular, offers pretty elegant mechanisms for
creating test prerequisites: <a href="https://junit.org/junit5/docs/current/user-guide/#extensions-registration">test extensions</a>.
Everything that a test method needs we supply through its parameters,
which are instantiated by extensions, for example:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.junit.jupiter.api.extension.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">PhrasesExtension</span> <span class="kd">implements</span> <span class="nc">ParameterResolver</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">supportsParameter</span><span class="o">(</span>
    <span class="nc">ParameterContext</span> <span class="n">pctx</span><span class="o">,</span> <span class="nc">ExtensionContext</span> <span class="n">ectx</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">pctx</span><span class="o">.</span><span class="na">getParameter</span><span class="o">().</span><span class="na">getType</span><span class="o">()</span> <span class="o">==</span> <span class="nc">Phrases</span><span class="o">.</span><span class="na">class</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="nc">Object</span> <span class="nf">resolveParameter</span><span class="o">(</span>
    <span class="nc">ParameterContext</span> <span class="n">pctx</span><span class="o">,</span> <span class="nc">ExtensionContext</span> <span class="n">ectx</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Phrases</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Phrases</span><span class="o">();</span>
    <span class="n">p</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Hello, world!"</span><span class="o">);</span>
    <span class="n">p</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"London is a capital of Great Britain"</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Then, the test will look like this:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">org.junit.jupiter.api.extension.ExtendWith</span><span class="o">;</span>

<span class="nd">@ExtendWith</span><span class="o">(</span><span class="nc">PhrasesExtension</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">class</span> <span class="nc">PhrasesTest</span> <span class="o">{</span>
  <span class="nd">@Test</span>
  <span class="kt">void</span> <span class="nf">countsSimpleGreetings</span><span class="o">(</span><span class="nc">Phrases</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">assertThat</span><span class="o">(</span>
      <span class="s">"Total count of greetings"</span><span class="o">,</span>
      <span class="n">p</span><span class="o">.</span><span class="na">greetings</span><span class="o">().</span><span class="na">count</span><span class="o">(),</span> <span class="n">equalTo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Now, the test and its prerequisites stay in two different places and are not
as tightly coupled as they were before. Moreover, the prerequisites may be
easily reused. The magic <code class="language-plaintext highlighter-rouge">@ExtendWith</code> annotation may be attached to other
tests. The implementation of <code class="language-plaintext highlighter-rouge">PhrasesExtension</code> may become smarter: it
may start paying attention not only to the type of argument of a test method
but also to a custom annotation attached to it (this is how
<a href="https://junit.org/junit5/docs/5.4.1/api/org/junit/jupiter/api/io/TempDir.html"><code class="language-plaintext highlighter-rouge">@TempDir</code></a> works).</p>

<h2 id="fake-objects-best-way">Fake Objects (Best Way)</h2>

<p>Despite the beauty of JUnit extensions, I don’t think they are the best way
to decouple prerequisites from test methods. JUnit extensions are still pretty
coupled … not to test methods, but to the entire test suite of a project. If you
decide to use them somewhere else, in another project, you won’t be able to do so.</p>

<p>Also, if you decide to test your prerequisites, you won’t be able to do
it elegantly. Of course, you could write tests for them in the same directory, but in this case,
you will break the principle: one test per one live class.</p>

<p>The solution is: <a href="/2014/09/23/built-in-fake-objects.html">fake objects</a>.
They stay together with other live objects, but have special “fake” behavior,
for example (BTW, I <a href="/2017/11/14/static-factory-methods.html">don’t like factories</a>,
but in this case, it’s OK):</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">FactoryOfPhrases</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="nc">Phrases</span> <span class="nf">aboutLondon</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Phrases</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Phrases</span><span class="o">();</span>
    <span class="n">p</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"Hello, world!"</span><span class="o">);</span>
    <span class="n">p</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"London is a capital of Great Britain"</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">p</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Then, the test will look like this:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">PhrasesTest</span> <span class="o">{</span>
  <span class="nd">@Test</span>
  <span class="kt">void</span> <span class="nf">countsSimpleGreetings</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">assertThat</span><span class="o">(</span>
      <span class="s">"Total count of greetings"</span><span class="o">,</span>
      <span class="k">new</span> <span class="nf">FactoryOfPhrases</span><span class="o">().</span><span class="na">aboutLondon</span><span class="o">()</span>
        <span class="o">.</span><span class="na">greetings</span><span class="o">().</span><span class="na">count</span><span class="o">(),</span>
      <span class="n">equalTo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Repository layout would look like this:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/
  main/
    java/
      foo/
        FactoryOfPhrases.java
        Phrases.java
        Greetings.java
  test/
    java/
      foo/
        FactoryOfPhrasesTest.java
        PhrasesTest.java
        GreetingsTest.java
</code></pre></div></div>

<p>Pay attention to the test <code class="language-plaintext highlighter-rouge">FactoryOfPhrasesTest.</code> It tests the “fake” object <code class="language-plaintext highlighter-rouge">FactoryOfPhrases,</code>
which is part of the live classes collection. The factory of phrases is shipped together
with all other classes. Therefore, it can be used by other projects and not only for test
purposes.</p>

<p>To summarize, as a rule, I suggest keeping test classes clean: only test methods
belong there. No attributes and, of course, no static private methods. Everything
that is a prerequisite must be a “fake” object.</p>

<h2 id="integration-tests">Integration Tests</h2>

<p>In the Maven world, there are unit test classes (<code class="language-plaintext highlighter-rouge">Test</code> suffix),
and integration test classes (<code class="language-plaintext highlighter-rouge">ITCase</code> suffix).
The difference is huge. While both are compiled at the <code class="language-plaintext highlighter-rouge">test-compile</code> phase
by the same <code class="language-plaintext highlighter-rouge">maven-compiler-plugin,</code> they are not executed together.
Instead, unit tests are executed at the <code class="language-plaintext highlighter-rouge">test</code> phase. The build fails immediately if
any unit test is red. It’s a pretty straightforward approach, which
is similar to other build automation engines.</p>

<p>Integration tests are executed in four steps (these are the names of Maven phases):</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pre-integration-test
integration-test
post-integration-test
verify
</code></pre></div></div>

<p>First, the resources needed for integration testing are acquired
at the <code class="language-plaintext highlighter-rouge">pre-integration-test</code> phase. For example, a test instance of MySQL
database may be started. Then, the tests with <code class="language-plaintext highlighter-rouge">ITCase</code> are executed at the ‘integration-test’ phase. The
result of their execution is ignored for now but only recorded in a file.
Then, the resources are released at the <code class="language-plaintext highlighter-rouge">post-integration-test</code> phase.
For example, the MySQL server is shut down. Finally, at the <code class="language-plaintext highlighter-rouge">verify</code> phase,
the results of the tests are verified, and the build fails if
some of them are not green.</p>

<p>I keep <code class="language-plaintext highlighter-rouge">ITCase</code> files together with <code class="language-plaintext highlighter-rouge">Test</code> files only when they are
integration tests for specific live classes. Very often, they are not—that’s why
they are integration tests. They may integrate and test a number of classes together.
In this case, I put them in a separate package and gave them arbitrary names
that don’t match with the names of live classes:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>src/
  main/
    java/
      foo/
        Phrases.java
        Greetings.java
  test/
    java/
      foo/
        it/
          SimpleGuessingITCase.java
        PhrasesTest.java
        GreetingsTest.java
        GreetingsITCase.java
</code></pre></div></div>

<p>Here, <code class="language-plaintext highlighter-rouge">GreetingsITCase.java</code> is an integration test for <code class="language-plaintext highlighter-rouge">Greetings.java,</code>
while <code class="language-plaintext highlighter-rouge">SimpleGuessingITCase.java</code> is an integration test for no particular
class. Obviously, the package <code class="language-plaintext highlighter-rouge">foo.it</code> only exists in tests and is not
present in <code class="language-plaintext highlighter-rouge">src/main/java.</code></p>

<p><br></p>

<p>Thus, there is the first rule:
a test class may only have methods
annotated with <code class="language-plaintext highlighter-rouge">@Test</code> (in the case of Java).</p>

<p>Then, there is the second rule:
a package with tests may only have classes with <code class="language-plaintext highlighter-rouge">Test</code> or <code class="language-plaintext highlighter-rouge">ITCase</code> suffices
that map one-to-one to live classes and nothing else.</p>

    </article>
  </body>
</html>
