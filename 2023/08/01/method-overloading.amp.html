<!doctypehtml><html amp lang="en"><meta charset="utf-8"><title>The Hidden Dangers of Method Overloading</title><link rel="canonical"href="https://www.yegor256.com/2023/08/01/method-overloading.html"><link rel="icon"type="image/png"href="/favicon.ico"><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><script type="application/ld+json">{
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2023/08/01/method-overloading.html"
        },
        "headline": "The Hidden Dangers of Method Overloading",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2023/08/youth.jpg",
          "height": 889,
          "width": 1368
        },
        "datePublished": "2023-08-01",
        "dateModified": "2023-08-01",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "While method overloading is purported to enhance readability,
it actually tends to diminish it and introduce bugs.
",
        "keywords": ["method overloading", "function overloading", "overload methods", "method overloading design", "method overloading oop"]
      }</script><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript><link rel="stylesheet"href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500"><style amp-custom="amp-custom">@font-face{font-family:Cambria;src:url(https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf)}body{font-family:Cambria,'Times New Roman',serif;padding:.5em;font-size:1.2em}article{width:600px;max-width:100%;margin-left:auto;margin-right:auto}code,pre{font-family:'Source Code Pro','Courier New',monospace;font-size:.8em}code{padding:0 .3em;background-color:#d3d3d3}a,a:hover,a:visited{color:inherit}.intro{color:red;font-size:.75em}.photo{border-radius:50%}pre{overflow-x:scroll}</style><script async src="https://cdn.ampproject.org/v0.js"></script><article><p class="intro">This is a mobile version, full one is <a href="https://www.yegor256.com/2023/08/01/method-overloading.html">here</a>.<p><amp-img src="/images/face-256x256.jpg"width="80"height="80"alt="Yegor Bugayenko"class="photo"></amp-img><p>Yegor Bugayenko<br>1 August 2023<h1>The Hidden Dangers of Method Overloading</h1><p><a href="https://en.wikipedia.org/wiki/Function_overloading">Method overloading</a> is a common feature in many programming languages that allows a class to have two or more methods with the same name but different parameters. <a href="https://learn.microsoft.com/en-us/dotnet/standard/design-guidelines/member-overloading">According</a> to Microsoft, method overloading is “one of the most important techniques for <em>improving</em> usability, productivity, and readability of reusable libraries.” I disagree. In my opinion, method overloading may lead to less readable code and more bugs, because maintaining two or more implementations under the same name gives rise to concealed semantics, which inevitably result in misunderstandings and functional defects.</p><amp-img src="/images/2023/08/youth.jpg"alt="Youth (2015) by Paolo Sorrentino"height="889"width="1368"layout="responsive"></amp-img><p>Let’s start with a Java example. Suppose you wish to enable the addition of a product to the shopping cart, having either the product ID or the <code class="language-plaintext highlighter-rouge">Product</code> object at your disposal. If only the ID is provided, you’d want the shopping cart to access the product catalog, locate the corresponding <code class="language-plaintext highlighter-rouge">Product</code> object, and add it. This is where method overloading can prove beneficial (the <code class="language-plaintext highlighter-rouge">add()</code> method is defined twice with two different <a href="https://stackoverflow.com/questions/8516498">signatures</a> and implementations):<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Cart</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">products</span><span class="o">;</span>
  <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Catalog</span><span class="o">().</span><span class="na">findById</span><span class="o">(</span><span class="n">id</span><span class="o">));</span>
  <span class="o">}</span>
  <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Product</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">products</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="kt">var</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Cart</span><span class="o">();</span>
<span class="n">c</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="s">"book"</span><span class="o">));</span>
<span class="n">c</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">42</span><span class="o">);</span>
</code></pre></div></div><p>This approach is indeed convenient for at least two reasons. First, the <code class="language-plaintext highlighter-rouge">add(int)</code> method handles the conversion from <code class="language-plaintext highlighter-rouge">int</code> to <code class="language-plaintext highlighter-rouge">Product</code>, which need not be repeated elsewhere—they can simply pass the product’s ID to this method and let it do the work—thereby eliminating code duplication. Second, because the functionality of “searching the catalog” is not exposed beyond the <code class="language-plaintext highlighter-rouge">Cart</code> class, it simplifies the surrounding code. It appears that, indeed, the usability and readability of the code are enhanced.<p>However, the issues addressed (code duplication and complexity) are lesser than the problems introduced. While the semantics of the <code class="language-plaintext highlighter-rouge">add(Product)</code> method are obvious, the workings of the <code class="language-plaintext highlighter-rouge">add(int)</code> method are not clear to its users. Perhaps it searches the catalog? Maybe it selects the n-th product from the existing cart and re-adds it to the end of the cart? Or perhaps it searches the orders previously placed by the user and extracts the n-th product from there? We simply don’t know when we examine the method’s signature.<p>In order to comprehend what the <code class="language-plaintext highlighter-rouge">add(int)</code> method does, we must refer to its Javadoc block, which may not be sufficiently accurate. Furthermore, <a href="https://stackoverflow.com/a/913342/187141">as is often the case</a>, the documentation in the Javadoc block might not be in sync with the code inside the method. To put it plainly, the client using the <code class="language-plaintext highlighter-rouge">add(int)</code> method invariably makes an assumption about its inner workings. If the client is fortunate, 1) the assumption will be accurate, and 2) any changes subsequently made to the method won’t invalidate that assumption.<p>It appears that method overloading is the root of the issue: maintaining multiple implementations under a single name inevitably introduces some concealed semantics in most of them. Then, when something is obscured, it prompts assumptions, which in turn lead to misunderstandings, and eventually to bugs.<p>I believe, a better alternative looks like this:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">ProductInCatalog</span> <span class="kd">implements</span> <span class="nc">Product</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Product</span> <span class="n">p</span><span class="o">;</span>
  <span class="nc">ProductInCatalog</span><span class="o">(</span><span class="kt">int</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Catalog</span><span class="o">().</span><span class="na">findById</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="c1">// all "Product" interface's methods</span>
<span class="o">}</span>
<span class="kd">class</span> <span class="nc">Cart</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">products</span><span class="o">;</span>
  <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Product</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">products</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="kt">var</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Cart</span><span class="o">();</span>
<span class="n">c</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">Product</span><span class="o">(</span><span class="s">"book"</span><span class="o">));</span>
<span class="n">c</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ProductInCatalog</span><span class="o">(</span><span class="mi">42</span><span class="o">));</span>
</code></pre></div></div><p>The constructor of <code class="language-plaintext highlighter-rouge">ProductInCatalog</code> is not code-free, as <a href="/2015/05/07/ctors-must-be-code-free.html">it ideally should be</a>, however, this point is not so significant for our current discussion. The <code class="language-plaintext highlighter-rouge">ProductInCatalog</code> class serves as an abstraction of a <code class="language-plaintext highlighter-rouge">Product</code> found in the catalog. This class is used by the client of the <code class="language-plaintext highlighter-rouge">Cart</code> class. The client, in full awareness and with explicit intent, converts 42 (the product’s ID) into an instance of <code class="language-plaintext highlighter-rouge">ProductInCatalog</code>. This design no longer conceals any elements. There are no assumptions to be made and no conditions that the code must fulfill.<p>Do we still preserve the advantages provided by method overloading? Indeed, we do. There is no code duplication, and the complexity of the code is reduced. Furthermore, the readability of the code using the <code class="language-plaintext highlighter-rouge">Cart</code> is significantly improved. To summarize, I recommend avoiding method overloading, even though it will undoubtedly result in a larger number of classes in the codebase. However, that is <a href="/2017/02/28/too-many-classes.html">a different discussion altogether</a>.</article>