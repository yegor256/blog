<!doctypehtml><html amp lang="en"><meta charset="utf-8"><title>How to Handle the Problem of Too Many Classes</title><link rel="canonical"href="https://www.yegor256.com/2017/02/28/too-many-classes.html"><link rel="icon"type="image/png"href="/favicon.ico"><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><script type="application/ld+json">{
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2017/02/28/too-many-classes.html"
        },
        "headline": "How to Handle the Problem of Too Many Classes",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2017/02/el-dia-de-la-bestia.jpg",
          "height": 646,
          "width": 1200
        },
        "datePublished": "2017-02-28",
        "dateModified": "2017-02-28",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "I often hear that having too many classes in an
object-oriented design is a problem; let's investigate
when this is likely to happen and how to handle it correctly.
",
        "keywords": ["too many classes", "OOP classes", "class names in OOP", "naming classes in OOP", "many classes"]
      }</script><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript><link rel="stylesheet"href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500"><style amp-custom="amp-custom">@font-face{font-family:Cambria;src:url(https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf)}body{font-family:Cambria,'Times New Roman',serif;padding:.5em;font-size:1.2em}article{width:600px;max-width:100%;margin-left:auto;margin-right:auto}code,pre{font-family:'Source Code Pro','Courier New',monospace;font-size:.8em}code{padding:0 .3em;background-color:#d3d3d3}a,a:hover,a:visited{color:inherit}.intro{color:red;font-size:.75em}.photo{border-radius:50%}pre{overflow-x:scroll}</style><script async src="https://cdn.ampproject.org/v0.js"></script><article><p class="intro">This is a mobile version, full one is <a href="https://www.yegor256.com/2017/02/28/too-many-classes.html">here</a>.<p><amp-img src="/images/face-256x256.jpg"width="80"height="80"alt="Yegor Bugayenko"class="photo"></amp-img><p>Yegor Bugayenko<br>28 February 2017<h1>How to Handle the Problem of Too Many Classes</h1><p>During nearly <a href="/talks.html">every presentation</a> in which I explain <a href="/2016/07/14/who-is-object.html">my view</a> of <a href="/2016/08/15/what-is-wrong-object-oriented-programming.html">object-oriented programming</a>, there is someone who shares a comment like this: “If we follow your advice, we will have so many small classes.” And my answer is always the same: “Of course we will, and that’s great!” I honestly believe that even if you can’t consider having “a lot of classes” a virtue, you can’t call it a drawback of any truly object-oriented code either. However, there may come a point when classes become a problem; let’s see when, how, and what to do about that.</p><amp-img src="/images/2017/02/el-dia-de-la-bestia.jpg"alt="El día de la bestia (1995) by Álex de la Iglesia"height="646"width="1200"layout="responsive"></amp-img><p>There were a number of “rules” previously mentioned that, if applied, would obviously lead to a large number of classes, including: a) all public methods <a href="/2014/11/20/seven-virtues-of-good-object.html">must be</a> declared in interfaces; b) objects must not have more than four attributes (Section 2.1 of <a href="/elegant-objects.html">Elegant Objects</a>); c) static methods are <a href="/2014/05/05/oop-alternative-to-utility-classes.html">not allowed</a>; d) constructors <a href="/2015/05/07/ctors-must-be-code-free.html">must be</a> code-free; e) objects must expose fewer than five public methods (Section 3.1 of <a href="/elegant-objects.html">Elegant Objects</a>).<p>The biggest concern, of course, is maintainability: “If, instead of 50 longer classes, we had 300 shorter ones, then the code would be way less readable.” This will most certainly happen if you design them wrong.<p>Types (or classes) in OOP constitute your <a href="https://en.wikipedia.org/wiki/Vocabulary"><em>vocabulary</em></a>, which explains the world around your code—the world your code lives in. The richer the vocabulary, the more powerful your code. The more types you have, the better you can understand and explain the world.<p>If your vocabulary is big enough, you will say something like:<blockquote><p>Read the book that is on the table.</blockquote><p>With a much smaller vocabulary, the same phrase would sound like:<blockquote><p>Do it with the thing that is on that thing.</blockquote><p>Obviously, it’s easier to read and understand the first phrase. The same occurs with types in OOP: the more of them you have at your disposal, the more expressive, bright, and readable your code is.<p>Unfortunately, Java and many other languages are not designed with this concept in mind. Packages, modules, and namespaces don’t really help, and we usually end up with names like <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/method/annotation/AbstractCooKyivalueMethodArgumentResolver.html"><code class="language-plaintext highlighter-rouge">AbstractCooKyivalueMethodArgumentResolver</code></a> (Spring) or <a href="https://hadoop.apache.org/docs/r3.0.0-alpha1/api/org/apache/hadoop/mapreduce/lib/input/CombineFileRecordReaderWrapper.html"><code class="language-plaintext highlighter-rouge">CombineFileRecordReaderWrapper</code></a> (Hadoop). We’re trying to pack as many semantics into class names as possible so their users won’t doubt for a second. Then we’re trying to put as many methods into one class as possible to make life easier for users; they will use their IDE hints to find the right one.<p>This is anything but OOP.<p>If your code is object-oriented, your classes must be small, their names must be nouns, and their method names must be just one word. Here is what I do in my code to make that happen:<p><strong>Interfaces are nouns</strong>. For example, <a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/Request.html"><code class="language-plaintext highlighter-rouge">Request</code></a>, <a href="http://static.javadoc.io/com.jcabi.incubator/xembly/0.22/org/xembly/Directive.html"><code class="language-plaintext highlighter-rouge">Directive</code></a>, or <a href="https://github.com/yegor256/jare/blob/0.8.4/src/main/java/io/jare/model/Domain.java"><code class="language-plaintext highlighter-rouge">Domain</code></a>. There are no exceptions. Types (also known as <a href="https://docs.oracle.com/javase/tutorial/java/concepts/interface.html">interfaces</a> in Java) are the core part of my vocabulary; they have to be nouns.<p><strong>Classes are prefixed</strong>. My classes <a href="/2014/11/20/seven-virtues-of-good-object.html">always</a> implement interfaces. Thanks to that, I can say they always <em>are</em> requests, directives, or domains. And I always want their users to remember that. Prefixes help. For example, <a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/rq/RqBuffered.html"><code class="language-plaintext highlighter-rouge">RqBuffered</code></a> is a buffered request, <a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/rq/RqSimple.html"><code class="language-plaintext highlighter-rouge">RqSimple</code></a> is a simple request, <a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/rq/RqLive.html"><code class="language-plaintext highlighter-rouge">RqLive</code></a> is a request that represents a “live” HTTP connection, and <a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/rq/RqWithHeader.html"><code class="language-plaintext highlighter-rouge">RqWithHeader</code></a> is a request with an extra header.<p>An alternative approach is to use the type name as the central part of the class name and add a prefix that explains implementation details. For example, <a href="https://github.com/yegor256/jare/blob/0.8.4/src/main/java/io/jare/dynamo/DyDomain.java"><code class="language-plaintext highlighter-rouge">DyDomain</code></a> is a domain that persists its data in DynamoDB. Once you know what that <code class="language-plaintext highlighter-rouge">Dy</code> prefix is for, you can easily understand what <a href="https://github.com/yegor256/jare/blob/0.8.4/src/main/java/io/jare/dynamo/DyUser.java"><code class="language-plaintext highlighter-rouge">DyUser</code></a> and <a href="https://github.com/yegor256/jare/blob/0.8.4/src/main/java/io/jare/dynamo/DyBase.java"><code class="language-plaintext highlighter-rouge">DyBase</code></a> are about.<p>In a medium-sized application or a library, there will be as many as 10 to 15 prefixes you will have to remember, no more. For example, in the <a href="https://www.takes.org">Takes Framework</a>, there are 24,000 lines of code, 410 Java files, and 10 prefixes: <code class="language-plaintext highlighter-rouge">Bc</code>, <code class="language-plaintext highlighter-rouge">Cc</code>, <code class="language-plaintext highlighter-rouge">Tk</code>, <code class="language-plaintext highlighter-rouge">Rq</code>, <code class="language-plaintext highlighter-rouge">Rs</code>, <code class="language-plaintext highlighter-rouge">Fb</code>, <code class="language-plaintext highlighter-rouge">Fk</code>, <code class="language-plaintext highlighter-rouge">Hm</code>, <code class="language-plaintext highlighter-rouge">Ps</code>, and <code class="language-plaintext highlighter-rouge">Xe</code>. Not so difficult to remember what they mean, right?<p>Among all <a href="http://static.javadoc.io/org.takes/takes/1.1/allclasses-frame.html">240 classes</a>, the longest name is <a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/rq/RqWithDefaultHeader.html"><code class="language-plaintext highlighter-rouge">RqWithDefaultHeader</code></a>.<p>I find this approach to class naming rather convenient. I used it in these open source projects (in GitHub): <a href="https://github.com/yegor256/takes">yegor256/takes</a> (10 prefixes), <a href="https://github.com/yegor256/jare">yegor256/jare</a> (5 prefixes), <a href="https://github.com/yegor256/rultor">yegor256/rultor</a> (6 prefixes), and <a href="https://github.com/yegor256/wring">yegor256/wring</a> (5 prefixes).</article>