<!doctypehtml><html amp lang="en"><meta charset="utf-8"><title>The TDD That Works for Me</title><link rel="canonical"href="https://www.yegor256.com/2017/03/24/tdd-that-works.html"><link rel="icon"type="image/png"href="/favicon.ico"><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><script type="application/ld+json">{
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2017/03/24/tdd-that-works.html"
        },
        "headline": "The TDD That Works for Me",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2017/03/la-grande-bellezza.jpg",
          "height": 812,
          "width": 1917
        },
        "datePublished": "2017-03-24",
        "dateModified": "2017-03-24",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Test-driven development is a brilliant idea...if it works;
in reality, it doesn't work the way most software books
explain it.
",
        "keywords": ["tdd", "test-driven development", "tdd doesn't work", "tdd works", "automated testing"]
      }</script><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript><link rel="stylesheet"href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500"><style amp-custom="amp-custom">@font-face{font-family:Cambria;src:url(https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf)}body{font-family:Cambria,'Times New Roman',serif;padding:.5em;font-size:1.2em}article{width:600px;max-width:100%;margin-left:auto;margin-right:auto}code,pre{font-family:'Source Code Pro','Courier New',monospace;font-size:.8em}code{padding:0 .3em;background-color:#d3d3d3}a,a:hover,a:visited{color:inherit}.intro{color:red;font-size:.75em}.photo{border-radius:50%}pre{overflow-x:scroll}</style><script async src="https://cdn.ampproject.org/v0.js"></script><article><p class="intro">This is a mobile version, full one is <a href="https://www.yegor256.com/2017/03/24/tdd-that-works.html">here</a>.<p><amp-img src="/images/face-256x256.jpg"width="80"height="80"alt="Yegor Bugayenko"class="photo"></amp-img><p>Yegor Bugayenko<br>24 March 2017<h1>The TDD That Works for Me</h1><p><a href="https://en.wikipedia.org/wiki/Test-driven_development">Test-driven development</a> (a.k.a. TDD) was <a href="https://www.quora.com/Why-does-Kent-Beck-refer-to-the-rediscovery-of-test-driven-development">rediscovered</a> by <a href="https://en.wikipedia.org/wiki/Kent_Beck">Kent Beck</a> and explained in <a href="https://amzn.to/2mTuxCs">his famous book</a> in 2002. In 2014, David Heinemeier Hansson (the creator of Ruby on Rails) said that TDD <a href="https://dhh.dk/2014/tdd-is-dead-long-live-testing.html">is dead</a> and only <a href="https://dhh.dk/2014/test-induced-design-damage.html">harms architecture</a>. <a href="https://en.wikipedia.org/wiki/Robert_Cecil_Martin">Robert Martin</a> (the inventor of the <a href="/2017/03/28/solid.html">SOLID principles</a>) <a href="https://8thlight.com/blog/uncle-bob/2014/04/25/MonogamousTDD.html">disagreed</a> and <a href="https://8thlight.com/blog/uncle-bob/2014/04/30/When-tdd-does-not-work.html">explained</a> that TDD may not work only in certain cases. A few days later, he even <a href="https://8thlight.com/blog/uncle-bob/2014/05/02/ProfessionalismAndTDD.html">compared</a> the importance of TDD with the importance of hand-washing for medicine, and added that “it would not surprise me if, one day, TDD had the force of law behind it.” Two years later, now just a few months ago, he wrote <a href="http://blog.cleancoder.com/uncle-bob/2017/03/03/TDD-Harms-Architecture.html">more</a> about it, and <a href="http://blog.cleancoder.com/uncle-bob/2017/03/06/TestingLikeTheTSA.html">more</a>, and <a href="http://blog.cleancoder.com/uncle-bob/2016/11/10/TDD-Doesnt-work.html">more</a>. This subject seems to be hot. Of course, I have my own take on it; let me share.</p><amp-img src="/images/2017/03/la-grande-bellezza.jpg"alt="La grande bellezza (2013) by Paolo Sorrentino"height="812"width="1917"layout="responsive"></amp-img><p>In theory, TDD means “writing tests first and code next.” In practice, according to <a href="https://www.zerocracy.com">my experience</a> while working with more than 250 developers over the last four years, it means writing tests when we’re in a good mood and have nothing else to do. And this is only logical, if we understand TDD literally, by <a href="https://en.wikipedia.org/wiki/Kent_Beck">the book</a>.<p>Writing a test for a class without having that class in front of you is <em>difficult</em>. I would even say impossible, if we are talking about real code, not calculator examples. It’s also very <em>inefficient</em>, because tests by definition are much more rigid than the code they validate—creating them first will cause many re-do cycles until the design is stabilized.<p>I’ve personally <a href="https://github.com/yegor256">written</a> almost 300,000 lines of code in Java, Ruby, PHP, and JavaScript over the last four years, and I have never done TDD by the book: “write a test, make it run, make it right.” Ever.<h2 id="code-deploy-break-test-fix">Code, Deploy, Break, Test, Fix</h2><p>Even though I’m a huge fan of automated testing (unit or integration) and totally <a href="https://8thlight.com/blog/uncle-bob/2014/05/02/ProfessionalismAndTDD.html">agree</a> with Uncle Bob: Those who don’t write tests must be put <a href="/2015/11/24/imprisonment-for-irresponsible-coding.html">in jail</a>, I just have my own interpretation of TDD. This is how it looks:<ul><li><p>First, I write <strong>code</strong> without any tests. A lot of code. I implement the functionality and create the design. Dozens of classes. Of course, the build is automated, the deployment pipeline is configured, and I can test the product myself in a sandbox. I make sure “<a href="https://blog.codinghorror.com/the-works-on-my-machine-certification-program/">it works on my machine</a>.”<li><p>Then, I <strong>deploy</strong> it to production. Yes, it goes to my “users” without any tests because it works for me. They are either real users if it’s something open source or one of my <a href="/pets.html">pet projects</a>, or manual testers if it’s a money project.<li><p>Then, they <strong>break</strong> it. They either test it or they use it; it doesn’t matter. They just find problems and report bugs. As many as they can.<li><p>Right after some bugs are reported, I pick the most critical of them and…voilà!…I create an automated <strong>test</strong>. The bug is a message to me that my tests are weak; I have to fix them first. A new test will prove that the code is broken. Or maybe I fix an existing one. This is where I go “tests first.” I don’t touch the production code until I manage to break my build and prove the problem’s existence with a new test. Then, I do <code class="language-plaintext highlighter-rouge">git commit.</code><li><p>Finally, it’s time to <strong>fix</strong> the problem. I make changes to the production code in order to make sure the build is green again. Then, I do <code class="language-plaintext highlighter-rouge">git commit</code> and <code class="language-plaintext highlighter-rouge">git push.</code> And I go back to the “deploy” step; the updated product goes to my users.</ul><p>Once in a while, I have to make serious modifications to the product, like to introduce a new feature or perform a massive refactoring. In this case, I go back to the first step and do it without tests.<h2 id="the-reasoning-behind">The Reasoning Behind</h2><p>The justification behind this no-tests-upfront approach is simple: We don’t need to test until it’s broken, mostly because we understand that it’s technically not possible to test everything or to fix all bugs. We have to fix only what’s visible and intolerable by the business. If the business doesn’t care or our users/testers don’t see our bugs—we must not <em>waste</em> project resources on fixing them.<p>On the other hand, when the business or our users/testers are complaining, we have to be very strict with ourselves; our testing system is weak and must be fixed first. We can’t just fix the production code and deploy, because in this case, we may make this mistake again after some refactoring, and our tests won’t catch it. The user will find the bug again, and the business will pay us again to fix it. That will be the <em>waste</em> of resources.<p>As you can see, it’s all money-driven. First, don’t fix anything if nobody pays for it. Second, fix it once and for all if they actually paid. It’s as simple as that.<h2 id="the-dynamics">The Dynamics</h2><p>Thanks to this test-and-fix-only-when-broken approach, the balance between production code and test code is not the same over the entire project lifecycle. When the project starts, there are almost no tests. Then, the number of tests grows together with the number of bugs. Eventually, the situation stabilizes, and we can move the product from beta version to the first release.<p>I created a simple <a href="https://github.com/yegor256/tdx">command line tool</a> in order to demonstrate the statistics from a few projects of mine, to prove my point. Take a look at these graphs:<p><a href="https://github.com/yegor256/takes">yegor256/takes</a> (Web framework, Java):<p><a href="https://github.com/yegor256/xembly">yegor256/xembly</a> (XML builder, Java):<p><a href="https://github.com/jcabi/jcabi-aspects">jcabi/jcabi-aspects</a> (AOP library, Java):<p><a href="https://github.com/yegor256/s3auth">yegor256/s3auth</a> (S3 gateway, Java):<p>First commercial project:<p>Second commercial project:<p>In each graph, there are two parts. The first one on the top demonstrates the dynamics of production <a href="/2014/11/14/hits-of-code.html">Hits-of-Code</a> (green line), test-related HoC (red line), and the number of issues reported to GitHub (orange line).<p>The bottom part shows how big the test-related HoC portion is relative to all project activity. In other words, it shows how much <em>effort</em> the project invested into automated tests, compared with the total effort.<p>This is what I want you to pay attention to: The shape of the curve is almost the same in every project. It looks very similar to a <a href="https://en.wikipedia.org/wiki/Learning_curve">learning curve</a>, where we start to learn fast and then slow down over time:<p>This perfectly illustrates what I just described above. I don’t need tests at the beginning of the project; I create them later when my users express the need for them by reporting bugs. This dynamic looks only logical to me.<p>You can also analyze your project using <a href="https://github.com/yegor256/tdx">my tool</a> and see the graph. It would be interesting to learn what kind of curve you will get.<blockquote class="twitter-tweet"data-lang="en"><p lang="en"dir="ltr">When do you write unit tests? <a href="https://twitter.com/hashtag/testing?src=hash&amp;ref_src=twsrc%5Etfw">#testing</a></p>— Yegor Bugayenko (@yegor256) <a href="https://twitter.com/yegor256/status/1094483307130060803?ref_src=twsrc%5Etfw">February 10, 2019</a></blockquote></article>