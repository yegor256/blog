<!doctypehtml><html amp lang="en"><meta charset="utf-8"><title>Alan Kay Was Wrong About Him Being Wrong</title><link rel="canonical"href="https://www.yegor256.com/2017/12/12/alan-kay-was-wrong.html"><link rel="icon"type="image/png"href="/favicon.ico"><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><script type="application/ld+json">{
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2017/12/12/alan-kay-was-wrong.html"
        },
        "headline": "Alan Kay Was Wrong About Him Being Wrong",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2017/12/rain-man.jpg",
          "height": 750,
          "width": 1440
        },
        "datePublished": "2017-12-12",
        "dateModified": "2017-12-12",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Alan Kay said in 1998 that object-oriented programming
should have been called message-oriented programming instead;
I disagree.
",
        "keywords": ["alan kay oop", "alan kay about oop", "message oriented programming", "messages oop", "alan kay oop definition"]
      }</script><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript><link rel="stylesheet"href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500"><style amp-custom="amp-custom">@font-face{font-family:Cambria;src:url(https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf)}body{font-family:Cambria,'Times New Roman',serif;padding:.5em;font-size:1.2em}article{width:600px;max-width:100%;margin-left:auto;margin-right:auto}code,pre{font-family:'Source Code Pro','Courier New',monospace;font-size:.8em}code{padding:0 .3em;background-color:#d3d3d3}a,a:hover,a:visited{color:inherit}.intro{color:red;font-size:.75em}.photo{border-radius:50%}pre{overflow-x:scroll}</style><script async src="https://cdn.ampproject.org/v0.js"></script><article><p class="intro">This is a mobile version, full one is <a href="https://www.yegor256.com/2017/12/12/alan-kay-was-wrong.html">here</a>.<p><amp-img src="/images/face-256x256.jpg"width="80"height="80"alt="Yegor Bugayenko"class="photo"></amp-img><p>Yegor Bugayenko<br>12 December 2017<h1>Alan Kay Was Wrong About Him Being Wrong</h1><p>From time to time someone asks me what I think about what <a href="https://en.wikipedia.org/wiki/Alan_Kay">Alan Kay</a>, the father of OOP, the designer of <a href="https://en.wikipedia.org/wiki/Smalltalk">Smalltalk</a>, the first object-oriented language, <a href="https://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en">said</a> in 1998 about OOP. He literally said that the very term “object” was misleading and a more appropriate one would be “messaging.” Here is what I think.</p><amp-img src="/images/2017/12/rain-man.jpg"alt="Rain Man (1988) by Barry Levinson"height="750"width="1440"layout="responsive"></amp-img><p>I believe that there are two orthogonal means of interaction between objects: messaging and composition. Let’s say, we have a point and a canvas:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Point</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
<span class="nc">Canvas</span> <span class="n">canvas</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Canvas</span><span class="o">();</span>
</code></pre></div></div><p>This is how messaging would look:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span><span class="o">.</span><span class="na">printTo</span><span class="o">(</span><span class="n">canvas</span><span class="o">);</span>
</code></pre></div></div><p>The problem with messaging is that it keeps objects on the same level of abstraction. They communicate as equal and independent “modules,” sending <a href="/2016/11/21/naked-data.html">data messages</a> to each other. Even though they look object-oriented, the entire communication pattern is very procedural. We try to encapsulate as much as we can inside a single object, however inevitably still having to expose a lot of its data in order to be able to “connect” it with other objects.<p>We turn objects into “little computers,” as <a href="https://amzn.to/2npiZZQ">some books</a> refer to them. They expect data to come in, they process the data, and return back some new data. The maintainability problem is not really solved with this approach—we still have to deal with a lot of data, remembering its semantic outside of the objects. In other words, there is no true encapsulation.<p>On the other hand, this is how composition would look instead:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Point</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintedOn</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">canvas</span><span class="o">);</span>
</code></pre></div></div><p>Every time we need objects to communicate we create a bigger object that encapsulates more primitive ones, letting them interact inside. Of course, the data will also go from object to object, but that will happen inside a bigger object. We can even make the encapsulator and the encapsulated “friends,” as <a href="/2016/12/20/can-objects-be-friends.html">I suggested before</a>, to make that interaction more transparent and avoid data exposure through <a href="/2014/09/16/getters-and-setters-are-evil.html">getters</a> or even <a href="/2016/04/05/printers-instead-of-getters.html">printers</a>.<p>Let me <a href="https://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en">quote</a> Alan Kay again:<blockquote><p>The key in making great and growable systems is much more to design how its modules communicate rather than what their internal properties and behaviors should be.</blockquote><p>It seems to me that he means <em>modules</em>, which are not objects. These are different things. Modules are elements of the architecture, while objects are elements of the design. These are two different levels. At the level of architecture we obviously need messages and Kay’s statement is perfectly correct. However, at the level of design we need composable structures, to increase maintainability and messaging is not what can help us achieve this goal.<p>Thus, I believe Alan Kay was right when he invented objects, called them objects, and gave their programming style the “object-oriented” title.</article>