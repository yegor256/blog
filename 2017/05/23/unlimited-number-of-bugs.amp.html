<!doctypehtml><html amp lang="en"><meta charset="utf-8"><title>Any Program Has an Unlimited Number of Bugs</title><link rel="canonical"href="https://www.yegor256.com/2017/05/23/unlimited-number-of-bugs.html"><link rel="icon"type="image/png"href="/favicon.ico"><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><script type="application/ld+json">{
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2017/05/23/unlimited-number-of-bugs.html"
        },
        "headline": "Any Program Has an Unlimited Number of Bugs",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2017/05/lamico-di-famiglia.jpg",
          "height": 578,
          "width": 1280
        },
        "datePublished": "2017-05-23",
        "dateModified": "2017-05-23",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Since requirements and user expectations are vague
any piece of software may be improved a literally
unlimited amount of times.
",
        "keywords": ["testing", "bugs", "number of bugs", "bugs count", "philosophy of testing"]
      }</script><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript><link rel="stylesheet"href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500"><style amp-custom="amp-custom">@font-face{font-family:Cambria;src:url(https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf)}body{font-family:Cambria,'Times New Roman',serif;padding:.5em;font-size:1.2em}article{width:600px;max-width:100%;margin-left:auto;margin-right:auto}code,pre{font-family:'Source Code Pro','Courier New',monospace;font-size:.8em}code{padding:0 .3em;background-color:#d3d3d3}a,a:hover,a:visited{color:inherit}.intro{color:red;font-size:.75em}.photo{border-radius:50%}pre{overflow-x:scroll}</style><script async src="https://cdn.ampproject.org/v0.js"></script><article><p class="intro">This is a mobile version, full one is <a href="https://www.yegor256.com/2017/05/23/unlimited-number-of-bugs.html">here</a>.<p><amp-img src="/images/face-256x256.jpg"width="80"height="80"alt="Yegor Bugayenko"class="photo"></amp-img><p>Yegor Bugayenko<br>23 May 2017<h1>Any Program Has an Unlimited Number of Bugs</h1><p>This may sound strange, but I will prove it: no matter how big or stable a piece of software is, it has an <em>unlimited</em> number of bugs not yet found. No matter how many of them we have already managed to find and fix, there are still too many left to count.</p><amp-img src="/images/2017/05/lamico-di-famiglia.jpg"alt="L'amico di famiglia (2006) by Paolo Sorrentino"height="578"width="1280"layout="responsive"></amp-img><p>Let’s take this simple Java method that calculates a sum of two integers as an example:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">sum</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div><p>This simple program has an <em>unlimited</em> number of bugs.<p>To prove this claim we just need to put two thoughts together:<ul><li><p>First, a bug is something that compromises the quality of software, which, according to <a href="https://standards.ieee.org/findstds/standard/610.12-1990.html">IEEE 610.12-1990</a>, is “the degree to which a system meets specified requirements or <em>user expectations</em>.”<li><p>Second, requirements and expectations may be functional and non-functional. The latter include performance, resilience, robustness, <em>maintainability</em>, and a few dozen other <a href="https://en.wikipedia.org/wiki/Non-functional_requirement">NFRs</a>.</ul><p>It is obvious that there are at least two variables in this equation that are ambiguous: user expectations and <a href="/2015/06/11/wikipedia-bug-definition.html">maintainability</a>. We can’t be precise about them and that’s why the number of bugs they will produce has no limit.<p>Of course, only a very limited subset of the entire set of bugs has any real business impact. Most of the bugs that exist in a program may stay there even after it is shipped to its users—nobody will ever find them or else the damage they cause to the user experience will be insignificant.<p>Finally, take a look at the method <code class="language-plaintext highlighter-rouge">sum()</code> one more time. How about these bugs:<ul><li>It doesn’t handle overflows<li>It doesn’t have any user documentation<li>Its design is not object-oriented<li>It doesn’t sum three or more numbers<li>It doesn’t sum <code class="language-plaintext highlighter-rouge">double</code> numbers<li>It doesn’t cast <code class="language-plaintext highlighter-rouge">long</code> to <code class="language-plaintext highlighter-rouge">int</code> automatically<li>It doesn’t skip execution if one argument is zero<li>It doesn’t cache results of previous calculations<li>There is no logging<li>Checkstyle would complain since arguments are not <code class="language-plaintext highlighter-rouge">final</code></ul><p>I’m sure you can find many more.<p>BTW, Glenford J. Myers said something very similar in his book “<a href="https://amzn.to/1Y3qAbN">The Art of Software Testing</a>,” which I <a href="/2014/08/22/art-of-software-testing.html">reviewed</a> earlier.<p>Bill Hetzel, <a href="https://amzn.to/2HziEtM"><em>The Complete Guide to Software Testing</em></a> (1993): “Some Theoretical Limits to Testing: ‘We can never be sure the specifications are correct,’ ‘No testing system can identify every correct program,’ ‘We can never be certain that a testing system is correct.’ These theoretical limits tell us that there will never be a way to be sure we have a perfect understanding of what a program is supposed to do (the expected or required results) and that any testing system we might construct will always have some possibility of failing. In short, we cannot achieve 100 percent confidence no matter how much time and energy we put into it!”</article>