<!doctypehtml><html amp lang="en"><meta charset="utf-8"><title>Synchronized Decorators to Replace Thread-Safe Classes</title><link rel="canonical"href="https://www.yegor256.com/2017/01/17/synchronized-decorators.html"><link rel="icon"type="image/png"href="/favicon.ico"><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><script type="application/ld+json">{
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2017/01/17/synchronized-decorators.html"
        },
        "headline": "Synchronized Decorators to Replace Thread-Safe Classes",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2017/01/aladdin.jpg",
          "height": 679,
          "width": 1200
        },
        "datePublished": "2017-01-17",
        "dateModified": "2017-01-17",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Don't make your classes thread-safe; instead,
create thread-safe decorators to make
thread safety configurable.
",
        "keywords": ["thread safety", "synchronized java", "synchronized in java", "how to make class thread-safe", "thread-safe java"]
      }</script><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript><link rel="stylesheet"href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500"><style amp-custom="amp-custom">@font-face{font-family:Cambria;src:url(https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf)}body{font-family:Cambria,'Times New Roman',serif;padding:.5em;font-size:1.2em}article{width:600px;max-width:100%;margin-left:auto;margin-right:auto}code,pre{font-family:'Source Code Pro','Courier New',monospace;font-size:.8em}code{padding:0 .3em;background-color:#d3d3d3}a,a:hover,a:visited{color:inherit}.intro{color:red;font-size:.75em}.photo{border-radius:50%}pre{overflow-x:scroll}</style><script async src="https://cdn.ampproject.org/v0.js"></script><article><p class="intro">This is a mobile version, full one is <a href="https://www.yegor256.com/2017/01/17/synchronized-decorators.html">here</a>.<p><amp-img src="/images/face-256x256.jpg"width="80"height="80"alt="Yegor Bugayenko"class="photo"></amp-img><p>Yegor Bugayenko<br>17 January 2017<h1>Synchronized Decorators to Replace Thread-Safe Classes</h1><p>You know what thread safety is, right? If not, there is a simple example below. All classes must be thread-safe, right? Not really. Some of them have to be thread-safe? Wrong again. I think none of them have to be thread-safe, while all of them have to provide synchronized decorators.</p><amp-img src="/images/2017/01/aladdin.jpg"alt="Aladdin (1992) by Ron Clements and John Musker"height="679"width="1200"layout="responsive"></amp-img><p>Let’s start with an example (it’s <a href="/2014/06/09/objects-should-be-immutable.html">mutable</a>, by the way):<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Position</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">before</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">number</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">after</span> <span class="o">=</span> <span class="n">before</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">number</span> <span class="o">=</span> <span class="n">after</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>What do you think—is it <a href="https://en.wikipedia.org/wiki/Thread_safety">thread-safe</a>? This term refers to whether an object of this class will operate without mistakes when used by multiple threads at the same time. Let’s say we have two threads working with the same object, <code class="language-plaintext highlighter-rouge">position</code>, and calling its method <code class="language-plaintext highlighter-rouge">increment()</code> at exactly the same moment in time.<p>We expect the <code class="language-plaintext highlighter-rouge">number</code> integer to be equal to 2 when both threads finish up, because each of them will increment it once, right? However, most likely this won’t happen.<p>Let’s see what will happen. In both threads, <code class="language-plaintext highlighter-rouge">before</code> will equal <code class="language-plaintext highlighter-rouge">0</code> when they start. Then <code class="language-plaintext highlighter-rouge">after</code> will be set to <code class="language-plaintext highlighter-rouge">1</code>. Then, both threads will do <code class="language-plaintext highlighter-rouge">this.number = 1</code> and we will end up with <code class="language-plaintext highlighter-rouge">1</code> in <code class="language-plaintext highlighter-rouge">number</code> instead of the expected <code class="language-plaintext highlighter-rouge">2</code>. See the problem? Classes with such a flaw in their design are <strong>not thread-safe</strong>.<p>The simplest and most obvious solution is to make our method <a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html"><code class="language-plaintext highlighter-rouge">synchronized</code></a>. That will guarantee that no matter how many threads call it at the same time, they will all go sequentially, not in parallel: one thread after another. Of course, it will take longer, but it will prevent that mistake from happening:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">Position</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">before</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">number</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">after</span> <span class="o">=</span> <span class="n">before</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">number</span> <span class="o">=</span> <span class="n">after</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>A class that guarantees it won’t break no matter how many threads are working with it is called <strong>thread-safe</strong>.<p>Now the question is: Do we have to make all classes thread-safe or only some of them? It would seem to be better to have all classes error-free, right? Why would anyone want an object that may break at some point? Well, not exactly. Remember, there is a performance concern involved; we don’t often have multiple threads, and we always want our objects to run as fast as possible. A between-threads synchronization mechanism will definitely slow us down.<p>I think the right approach is to have two classes. The first one is not thread-safe, while the other one is a <strong>synchronized decorator</strong>, which would look like this:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">SyncPosition</span> <span class="kd">implements</span> <span class="nc">Position</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Position</span> <span class="n">origin</span><span class="o">;</span>
  <span class="nc">SyncPosition</span><span class="o">(</span><span class="nc">Position</span> <span class="n">pos</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">origin</span> <span class="o">=</span> <span class="n">pos</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kd">synchronized</span> <span class="kt">void</span> <span class="nf">increment</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">origin</span><span class="o">.</span><span class="na">increment</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>Now, when we need our <code class="language-plaintext highlighter-rouge">position</code> object to be thread-safe, we decorate it with <code class="language-plaintext highlighter-rouge">SyncPosition</code>:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Position</span> <span class="n">position</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SyncPosition</span><span class="o">(</span>
  <span class="k">new</span> <span class="nf">SimplePosition</span><span class="o">()</span>
<span class="o">);</span>
</code></pre></div></div><p>When we need a plain simple position, without any thread safety, we do this:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Position</span> <span class="n">position</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SimplePosition</span><span class="o">();</span>
</code></pre></div></div><p>Making class functionality both rich <em>and</em> thread-safe is, in my opinion, a violation of that famous <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">single responsibility principle</a>.<p>By the way, this problem is very close to the one of <a href="/2016/01/26/defensive-programming.html">defensive programming</a> and validators.</article>