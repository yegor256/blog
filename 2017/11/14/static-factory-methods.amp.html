<!DOCTYPE html>
<html amp lang="en">
  <head>

    <meta charset="utf-8">
    <title>Constructors or Static Factory Methods?</title>
    <link rel="canonical" href="https://www.yegor256.com/2017/11/14/static-factory-methods.html">
    <link rel="icon" type="image/png" href="/favicon.ico">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2017/11/14/static-factory-methods.html"
        },
        "headline": "Constructors or Static Factory Methods?",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2017/11/extract.jpg",
          "height": 688,
          "width": 1280
        },
        "datePublished": "2017-11-14",
        "dateModified": "2017-11-14",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "http://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Static factory methods are supposed to be a convenient
replacement of object constructors; however, I disagree
with this idea and explain why.
",
        "keywords": ["constructors", "factory methods", "factory method", "constructor or factory", "factories vs constructiors"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500">
    <style amp-custom="amp-custom">
      @font-face {
        font-family: 'Cambria';
        src: url('https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf');
      }
      body { font-family: 'Cambria', 'Times New Roman', serif; padding: .5em; font-size: 1.2em; }
      article { width: 600px; max-width: 100%; margin-left: auto; margin-right: auto; }
      pre, code { font-family: 'Source Code Pro', 'Courier New', monospace; font-size: .8em; }
      code { padding: 0 .3em; background-color: lightgray; }
      a, a:hover, a:visited { color: inherit; }
      .intro { color: red; font-size: .75em; }
      .photo { border-radius: 50%; }
      pre { overflow-x:scroll; }
    </style>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <article>
      <p class="intro">
        This is a mobile version, full one is
        <a href="https://www.yegor256.com/2017/11/14/static-factory-methods.html">here</a>.
      </p>
      <p>
        <amp-img src="/images/face-256x256.jpg" width="80" height="80" alt="Yegor Bugayenko" class="photo"></amp-img>
      </p>
      <p>Yegor Bugayenko<br>14 November 2017</p>
      <h1>Constructors or Static Factory Methods?</h1>
      <p>I believe Joshua Bloch said it first in his very good book
"<a href="http://amzn.to/2zgpiRI">Effective Java</a>": static factory methods are the preferred
way to instantiate objects compared with constructors. I disagree.
Not only because I believe that static methods are pure evil, but
mostly because in this particular case they pretend to be good
and make us think that we have to love them.</p>



<amp-img src="/images/2017/11/extract.jpg" alt="Extract (2009) by Mike Judge" height="688" width="1280" layout="responsive"></amp-img>

<p>Let's analyze the reasoning and see why it's wrong, from
an object-oriented point of view.</p>

<p>This is a class with one primary and two secondary constructors:</p>

<pre>class Color {
  private final int hex;
  Color(String rgb) {
    this(Integer.parseInt(rgb, 16));
  }
  Color(int red, int green, int blue) {
    this(red &lt;&lt; 16 + green &lt;&lt; 8 + blue);
  }
  Color(int h) {
    this.hex = h;
  }
}</pre>

<p>This is a similar class with three static factory methods:</p>

<pre>class Color {
  private final int hex;
  static Color makeFromRGB(String rgb) {
    return new Color(Integer.parseInt(rgb, 16));
  }
  static Color makeFromPalette(int red, int green, int blue) {
    return new Color(red &lt;&lt; 16 + green &lt;&lt; 8 + blue);
  }
  static Color makeFromHex(int h) {
    return new Color(h);
  }
  private Color(int h) {
    this.hex = h;
  }
}</pre>

<p>Which one do you like better?</p>



<p>According to Joshua Bloch, there are three basic advantages
to using static factory methods instead of constructors (there
are actually four, but the fourth one is not applicable to Java
<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/language/type-inference-generic-instance-creation.html">anymore</a>):</p>

<ul>
<li>They have names.</li>
<li>They can cache.</li>
<li>They can subtype.</li>
</ul>

<p>I believe that all three make perfect sense ... if the design is wrong.
They are good excuses for workarounds.
Let's take them one by one.</p>

<h2 id="they-have-names">They Have Names</h2>

<p>This is how you make a
<a href="http://www.rapidtables.com/web/color/red-color.htm">red tomato</a>
color object with a constructor:</p>

<pre>Color tomato = new Color(255, 99, 71);</pre>

<p>This is how you do it with a static factory method:</p>

<pre>Color tomato = Color.makeFromPalette(255, 99, 71);</pre>

<p>It seems that <code>makeFromPalette()</code> is semantically richer than just <code>new Color()</code>,
right? Well, yes. Who knows what those three numbers mean if we just pass
them to the constructor. But the word "palette" helps us figure everything
out immediately.</p>

<p>True.</p>

<p>However, the right solution would be to use polymorphism and encapsulation,
to decompose the problem into a few semantically rich classes:</p>

<pre>interface Color {
}
class HexColor implements Color {
  private final int hex;
  HexColor(int h) {
    this.hex = h;
  }
}
class RGBColor implements Color {
  private final Color origin;
  RGBColor(int red, int green, int blue) {
    this.origin = new HexColor(
      red &lt;&lt; 16 + green &lt;&lt; 8 + blue
    );
  }
}</pre>

<p>Now, we use the right constructor of the right class:</p>

<pre>Color tomato = new RGBColor(255, 99, 71);</pre>

<p>See, Joshua?</p>

<h2 id="they-can-cache">They Can Cache</h2>

<p>Let's say I need a red tomato color in multiple places in the application:</p>

<pre>Color tomato = new Color(255, 99, 71);
// ... sometime later
Color red = new Color(255, 99, 71);</pre>

<p>Two objects will be created, which is obviously inefficient, since they are
identical. It would be better to keep the first instance somewhere in memory
and return it when the second call arrives. Static factory methods make
it possible to solve this very problem:</p>

<pre>Color tomato = Color.makeFromPalette(255, 99, 71);
// ... sometime later
Color red = Color.makeFromPalette(255, 99, 71);</pre>

<p>Then somewhere inside the <code>Color</code> we keep a private static <code>Map</code> with all the
objects already instantiated:</p>

<pre>class Color {
  private static final Map&lt;Integer, Color&gt; CACHE =
    new HashMap&lt;&gt;();
  private final int hex;
  static Color makeFromPalette(int red, int green, int blue) {
    final int hex = red &lt;&lt; 16 + green &lt;&lt; 8 + blue;
    return Color.CACHE.computeIfAbsent(
      hex, h -&gt; new Color(h)
    );
  }
  private Color(int h) {
    return new Color(h);
  }
}</pre>

<p>It is very effective performance-wise. With a small object like our
<code>Color</code> the problem may not be so obvious, but when objects are bigger, their
instantiation and garbage collection may waste a lot of time.</p>

<p>True.</p>

<p>However, there is an object-oriented way to solve this problem. We just
introduce a new class <code>Palette</code>, which becomes a store of colors:</p>

<pre>class Palette {
  private final Map&lt;Integer, Color&gt; colors =
    new HashMap&lt;&gt;();
  Color take(int red, int green, int blue) {
    final int hex = red &lt;&lt; 16 + green &lt;&lt; 8 + blue;
    return this.computerIfAbsent(
      hex, h -&gt; new Color(h)
    );
  }
}</pre>

<p>Now, we make an instance of <code>Palette</code> once and ask it to return a color
to us every time we need it:</p>

<pre>Color tomato = palette.take(255, 99, 71);
// Later we will get the same instance:
Color red = palette.take(255, 99, 71);</pre>

<p>See, Joshua, no static methods, no static attributes.</p>

<h2 id="they-can-subtype">They Can Subtype</h2>

<p>Let's say our class <code>Color</code> has a method <code>lighter()</code>, which is supposed
to shift the color to the next available lighter one:</p>

<pre>class Color {
  protected final int hex;
  Color(int h) {
    this.hex = h;
  }
  public Color lighter() {
    return new Color(hex + 0x111);
  }
}</pre>

<p>However, sometimes it's more desirable to pick the next lighter color
through a set of available
<a href="https://en.wikipedia.org/wiki/Pantone">Pantone</a> colors:</p>

<pre>class PantoneColor extends Color {
  private final PantoneName pantone;
  PantoneColor(String name) {
    this(new PantoneName(name));
  }
  PantoneColor(PantoneName name) {
    this.pantone = name;
  }
  @Override
  public Color lighter() {
    return new PantoneColor(this.pantone.up());
  }
}</pre>

<p>Then, we create a static factory method, which will decide
which <code>Color</code> implementation is the most suitable for us:</p>

<pre>class Color {
  private final String code;
  static Color make(int h) {
    if (h == 0xBF1932) {
      return new PantoneColor("19-1664 TPX");
    }
    return new RGBColor(h);
  }
}</pre>

<p>If the <a href="https://www.pantone.com/color-finder/19-1664-TPX">true red</a> color
is requested, we return an instance of <code>PantoneColor</code>. In all other cases it's
just a standard <code>RGBColor</code>. The decision is made by the static factory
method. This is how we will call it:</p>

<pre>Color color = Color.make(0xBF1932);</pre>

<p>It would not be possible to do the same "forking" with a constructor, since
it can only return the class it is declared in. A static method has all the
necessary freedom to return any subtype of <code>Color</code>.</p>

<p>True.</p>

<p>However, in an object-oriented world we can and must do it all differently.
First, we would make <code>Color</code> an interface:</p>

<pre>interface Color {
  Color lighter();
}</pre>

<p>Next, we would move this decision making process to its own class <code>Colors</code>, just
like we did in the previous example:</p>

<pre>class Colors {
  Color make(int h) {
    if (h == 0xBF1932) {
      return new PantoneColor("19-1664-TPX");
    }
    return new RGBColor(h);
  }
}</pre>

<p>And we would use an instance of class <code>Colors</code> instead of a static fa—Åtory
method inside <code>Color</code>:</p>

<pre>colors.make(0xBF1932);</pre>



<p>However, this is still not really an object-oriented way of thinking, because
we're taking the decision-making away from the object it belongs to. Either
through a static factory method <code>make()</code> or a new class <code>Colors</code>---it doesn't
really matter how---we tear our objects into two pieces. The first
piece is the object itself and the second one is the decision
making algorithm that stays somewhere else.</p>

<p>A much more object-oriented design would be to put the logic into an
object of class <code>PantoneColor</code> which would decorate
the original <code>RGBColor</code>:</p>

<pre>class PantoneColor {
  private final Color origin;
  PantoneColor(Color color) {
    this.origin = color;
  }
  @Override
  public Color lighter() {
    final Color next;
    if (this.origin.hex() == 0xBF1932) {
      next = new RGBColor(0xD12631);
    } else {
      next = this.origin.lighter();
    }
    return new PantoneColor(next);
  }
)</pre>

<p>Then, we make an instance of <code>RGBColor</code> and decorate it with <code>PantoneColor</code>:</p>

<pre>Color red = new PantoneColor(
  new RGBColor(0xBF1932)
);</pre>

<p>We ask <code>red</code> to return a lighter color and it returns the one from
the Pantone palette, not the one that is merely lighter in RGB coordinates:</p>

<pre>Color lighter = red.lighter(); // 0xD12631</pre>

<p>Of course, this example is rather primitive and needs
<a href="/2016/12/20/can-objects-be-friends.html">further improvement</a>
if we really want it to be applicable to all Pantone colors, but I hope
you get the idea. The logic must stay <em>inside</em> the class, not somewhere outside,
not in static factory methods or even in some other supplementary class.
I'm talking about the logic that belongs to this particular class, of course.
If it's something related to the management of class instances, then there can
be containers and stores, just like in the previous example above.</p>

<p>To summarize, I would strongly recommend you <em>never</em> use static methods, especially
when they are going to replace object constructors. Giving birth to an
object through its constructor is
<a href="/2014/10/03/di-containers-are-evil.html">the most</a>
"sacred" moment in any object-oriented
software, don't miss the beauty of it.</p>

    </article>
  </body>
</html>
