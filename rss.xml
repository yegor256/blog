<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://www.yegor256.com/rss.xml" rel="self" type="application/atom+xml" /><link href="https://www.yegor256.com/" rel="alternate" type="text/html" /><updated>2025-09-01T16:19:12+00:00</updated><id>https://www.yegor256.com/rss.xml</id><title type="html">Yegor Bugayenko</title><subtitle>Yegor Bugayenko</subtitle><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><entry><title type="html">The End of Type Annotations</title><link href="https://www.yegor256.com/2025/08/17/type-annotations.html" rel="alternate" type="text/html" title="The End of Type Annotations" /><published>2025-08-17T00:00:00+00:00</published><updated>2025-08-17T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/08/17/type-annotations</id><content type="html" xml:base="https://www.yegor256.com/2025/08/17/type-annotations.html"><![CDATA[<p>Type annotations are what make statically typed object-oriented languages like Java run <strong>faster</strong> and <strong>safer</strong>.
Without annotations, every variable would effectively collapse to <code class="language-plaintext highlighter-rouge">Object</code>, forcing runtime casts.
The code would work, but slower and with more runtime errors.
Some type annotations may be inferred instead of being explicitly specified by a programmer.
Not all though.
In Java, for example, a number of hard-to-resolve challenges prevent us from inferring types of all objects.
This is not a fundamental limitation of OOP itself.
It’s a result of design trade-offs in Java and similar languages.
In a perfect object-oriented language, all variable types would be inferrable.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="Swingers (1996) by Doug Liman" src="/images/2025/08/swingers.jpg" longdesc="#4225221a" /><figcaption id="4225221a">Swingers (1996) by Doug Liman</figcaption></figure>

<p>Imagine a simple Java method:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Price priceOfDelivery(Book book, City city) {
  Price price = book.price();
  Delivery delivery = new Delivery(price, city);
  return delivery.price();
}
</code></pre></div></div>

<p>Two reasons justify the usage of <code class="language-plaintext highlighter-rouge">Book</code>, <code class="language-plaintext highlighter-rouge">City</code>, <code class="language-plaintext highlighter-rouge">Price</code>, and <code class="language-plaintext highlighter-rouge">Delivery</code> type annotations:
Compilers and programmers need help.</p>

<h2 id="type-annotations-are-helpful">Type Annotations Are Helpful</h2>

<p>First, we help the compiler eliminate some <strong>dynamic dispatches</strong> in favor of static calls.
If the <code class="language-plaintext highlighter-rouge">Book</code> is a class, not an interface, the <code class="language-plaintext highlighter-rouge">book.price()</code> call may be compiled into a jump to an absolute address.
Without information about the <code class="language-plaintext highlighter-rouge">book</code>’s class, <code class="language-plaintext highlighter-rouge">.price()</code> goes to a virtual table first, finds the address, and only then jumps.
The second scenario is more expensive.
The type annotation attached to <code class="language-plaintext highlighter-rouge">book</code> helps avoid it.</p>

<p>Second, we help ourselves write safe code, avoiding “Method not found” <strong>runtime errors</strong>.
If <code class="language-plaintext highlighter-rouge">book</code> is not annotated as <code class="language-plaintext highlighter-rouge">Book</code>, we may mistakenly pass <code class="language-plaintext highlighter-rouge">Integer</code>, meaning the book’s ID in the database.
At compile time, that would lead to no errors.
Later, at runtime, we get an error when <code class="language-plaintext highlighter-rouge">.price()</code> is not found in the virtual table of the <code class="language-plaintext highlighter-rouge">Integer</code> class.</p>

<p>However, both compilers and programmers can improve.</p>

<h2 id="compilers-can-do-better">Compilers Can Do Better</h2>

<p>Sometimes, a compiler can infer the type of a variable, without an explicit annotation.
For example, this code compiles in Java, starting from version 10:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Price priceOfDelivery(Book book, City city) {
  var price = book.price();
  var delivery = new Delivery(price, city);
  return delivery.price();
}
</code></pre></div></div>

<p>The type annotation used in earlier Java versions is replaced with the <code class="language-plaintext highlighter-rouge">var</code> keyword.</p>

<p>In a small piece of code such as this one, the compiler can <strong>infer</strong> types.
However, it may fall short with the <code class="language-plaintext highlighter-rouge">book</code> and <code class="language-plaintext highlighter-rouge">city</code> parameters.
In the general case, type inference is not decidable for Java programs.
Because of generics, method overloading, reflection, and … complexity.</p>

<p>The complexity is the technical obstacle.
The compiler can’t infer types for all variables because it would be too expensive to analyze the whole program.
Instead, it compiles file by file.
Even if the compiler had the whole program, inference in Java would still hit undecidability in the general case.
File-by-file compilation makes this even more restrictive.</p>

<p>All other barriers, such as generics, the compiler can’t overcome:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void print(List&lt;?&gt; items) {
  var x = items.get(0); // What is the type?
}
</code></pre></div></div>

<p>No matter how hard the compiler tries, in the general case, this question doesn’t have an answer.</p>

<h2 id="programmers-can-do-better">Programmers Can Do Better</h2>

<p>We, programmers, can help the compiler infer types.</p>

<p>For example, we can stop using generics.
Instead of <code class="language-plaintext highlighter-rouge">List&lt;Book&gt;</code> we can have a <code class="language-plaintext highlighter-rouge">Library</code> and instead of <code class="language-plaintext highlighter-rouge">Map&lt;User, Phone&gt;</code> we can have a <code class="language-plaintext highlighter-rouge">PhoneBook</code>.
It’s easier to infer the type of the object taken from a <code class="language-plaintext highlighter-rouge">Library</code> versus the object taken from a generic <code class="language-plaintext highlighter-rouge">List</code>.</p>

<p>We can also stop using method overloading.
Instead of <code class="language-plaintext highlighter-rouge">print(String x)</code> and <code class="language-plaintext highlighter-rouge">print(Integer x)</code> we can create <code class="language-plaintext highlighter-rouge">printString(x)</code> and <code class="language-plaintext highlighter-rouge">printInteger(x)</code>.
Types of parameters are easier to infer in more specialized methods.</p>

<p>We can also stop using reflection.</p>

<aside class="quote">The easier it is to infer the type of a variable for a compiler, the faster the programmer gets the semantics of it too.
</aside>

<p>Java programmers may not be ready for such a <strong>radical move</strong>.
However, if they were, they would not only help the compiler but themselves too.
Eliminating type annotations makes code shorter and, because of that, cleaner.
This is why <code class="language-plaintext highlighter-rouge">var</code> syntax was introduced in Java 10.</p>

<p>In the code above, variable names are nouns.
In well-written code, nouns as names are <a href="/2015/01/12/compound-name-is-code-smell.html">sufficient</a> to disambiguate variables.
No need to call it <code class="language-plaintext highlighter-rouge">cityOfDelivery</code> or <code class="language-plaintext highlighter-rouge">bookToDeliver</code>.
Just <code class="language-plaintext highlighter-rouge">book</code> and <code class="language-plaintext highlighter-rouge">city</code> are enough.</p>

<p>We also named variables by their types: a <code class="language-plaintext highlighter-rouge">book</code> is of type <code class="language-plaintext highlighter-rouge">Book</code>, and so on.
By looking at the name of the variable we can tell its type.
The <code class="language-plaintext highlighter-rouge">Book</code> type annotation looks like a syntactical redundancy.
It only leads to lower code readability, by making it longer.
It’s reasonable to expect type inference to free our programs from this redundancy.</p>

<p>Thus, better type inference means better <strong>readability</strong> of the code.</p>

<h2 id="languages-can-do-better">Languages Can Do Better</h2>

<p>Languages like Haskell and the ML family prove that full type inference is achievable.
However, they still need annotations for edge cases.
Rust takes a middle ground.
It infers local variable types but enforces explicit annotations at public interfaces.
Go, until recently, avoided generics, operator overloading, and heavy reflection, making inference straightforward.
However, it forces programmers to annotate all public boundaries—function signatures, struct fields, and interfaces.</p>

<aside class="quote">If the type of a variable can’t be inferred, compilation fails.
</aside>

<p>I suggest taking one step forward and designing a language that doesn’t have any type annotations.
Such a language should not have generics, method overloading, reflection, and everything else that prevents 100% type inference.
Then, we must design a compiler for this language that compiles the entire program, not single files.</p>

<p>The language may be as strict as this:
If the type of a variable can’t be inferred, compilation fails.</p>

<p>This is how the book price snippet would look in such a language:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>priceOfDelivery(book, city) {
  p = book.price();
  d = new Delivery(p, city);
  return d.price();
}
</code></pre></div></div>

<p>To me, this seems to be much more readable than the original code in Java.</p>

<p>Compilation time remains a limitation though.
We turn this issue into an opportunity.
Programmers are forced, by the timing limitations of the compiler, to write smaller modules.
When they need larger programs, they break them into modules that communicate via <a href="https://en.wikipedia.org/wiki/Inter-process_communication">IPC</a> instead of staying in a monolithic binary.</p>

<p>We’re experimenting with this approach in <a href="https://www.eolang.org">EOLANG</a>, a language designed to maximize inference by eliminating features that make it undecidable.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="oop" /><summary type="html"><![CDATA[Type annotations are a workaround for compiler limitations, not a feature—a well-designed language should infer all types automatically, forcing programmers to write smaller, cleaner modules.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/08/swingers.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/08/swingers.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">remove(42) vs. find(42).remove()</title><link href="https://www.yegor256.com/2025/06/22/retrieve-or-remove.html" rel="alternate" type="text/html" title="remove(42) vs. find(42).remove()" /><published>2025-06-22T00:00:00+00:00</published><updated>2025-06-22T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/06/22/retrieve-or-remove</id><content type="html" xml:base="https://www.yegor256.com/2025/06/22/retrieve-or-remove.html"><![CDATA[<p>We have a list of books in the <code class="language-plaintext highlighter-rouge">books</code> object.
How do we remove a single book from it, given that we know its ID?
We can do <code class="language-plaintext highlighter-rouge">books.removeById(42)</code>.
Alternatively, we can find it with <code class="language-plaintext highlighter-rouge">books.findById(42)</code> and then call <code class="language-plaintext highlighter-rouge">b.remove()</code>.
Which option should we prefer, and why?
The second choice is the better one.
Not only because it’s more object-oriented, but also due to several practical advantages.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="8 Femmes (2002) by François Ozon" src="/images/2025/06/8-femmes.jpg" longdesc="#d7e21337" /><figcaption id="d7e21337">8 Femmes (2002) by François Ozon</figcaption></figure>

<h2 id="extending-the-deletion-behavior">Extending the Deletion Behavior</h2>

<p>What if we want to extend the deletion algorithm?
For example, suppose we want to print a log message every time a book is deleted.</p>

<p>If we follow the <a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">open-closed principle</a>, we should avoid modifying the existing <code class="language-plaintext highlighter-rouge">Book</code> or <code class="language-plaintext highlighter-rouge">Books</code> classes.
Instead, we want to either <a href="/2016/09/13/inheritance-is-procedural.html">extend</a> or <a href="/2015/02/26/composable-decorators.html">decorate</a> them.
A decorator is the ideal choice if we want to avoid <a href="/2016/09/13/inheritance-is-procedural.html">implementation inheritance</a>.</p>

<p>If we use <code class="language-plaintext highlighter-rouge">removeById()</code>, we must decorate the <code class="language-plaintext highlighter-rouge">books</code> object.
If we use <code class="language-plaintext highlighter-rouge">remove()</code>, we can decorate the individual book retrieved via <code class="language-plaintext highlighter-rouge">findById()</code>.
The latter approach may be more <strong>cohesive</strong>, since its decoratee is likely <strong>smaller</strong> and more <strong>focused</strong>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="nf">findById</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="no">Logged</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">b</span><span class="p">.</span><span class="nf">remove!</span>
</code></pre></div></div>

<h2 id="handling-missing-or-non-deletable-books">Handling Missing or Non-Deletable Books</h2>

<p>What if the book isn’t found, or can’t be deleted?
The <code class="language-plaintext highlighter-rouge">removeById()</code> approach doesn’t support the <a href="https://en.wikipedia.org/wiki/Null_object_pattern">Null Object</a> pattern well.
It forces us to throw an exception—or worse, return <code class="language-plaintext highlighter-rouge">false</code>, which goes <a href="/2018/08/22/builders-and-manipulators.html">against</a> the <a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation">CQS</a> principle.</p>

<p>On the other hand, returning an object, even a <a href="https://en.wikipedia.org/wiki/Null_object_pattern">null</a> or <a href="/2014/09/23/built-in-fake-objects.html">fake</a> object, offers more <strong>flexible error handling</strong>.
For instance, we can access <code class="language-plaintext highlighter-rouge">title()</code> safely, knowing that the book was found successfully—or catch and <a href="https://en.wikipedia.org/wiki/Exception_chaining">re-raise exceptions</a> with <a href="/2015/12/01/rethrow-exceptions.html">more context</a>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="nf">findById</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="k">begin</span>
  <span class="n">b</span><span class="p">.</span><span class="nf">remove!</span>
<span class="k">rescue</span> <span class="n">e</span>
  <span class="k">raise</span> <span class="n">e</span><span class="p">,</span> <span class="s2">"Can't delete book </span><span class="si">#{</span><span class="n">b</span><span class="p">.</span><span class="nf">title</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="decoupling-retrieval-and-deletion">Decoupling Retrieval and Deletion</h2>

<p>What if the retrieval and deletion of the object happen far apart in the code?</p>

<p>If <code class="language-plaintext highlighter-rouge">books</code> knows how to find, and a <code class="language-plaintext highlighter-rouge">book</code> knows how to delete, we keep responsibilities nicely separated.
It also allows the book to be immutable and encapsulate its own ID, reducing <a href="/2016/11/21/naked-data.html">leakage</a> of internal data:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="nf">findById</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="c1"># +100 lines here...</span>
<span class="n">b</span><span class="p">.</span><span class="nf">remove!</span>  <span class="c1"># DELETE FROM book WHERE id = 42</span>
<span class="c1"># +200 lines here...</span>
<span class="k">if</span> <span class="n">b</span><span class="p">.</span><span class="nf">exists?</span>  <span class="c1"># SELECT * FROM book WHERE id = 42</span>
  <span class="nb">puts</span> <span class="s2">"The book is back to the library!"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Once the ID is wrapped inside the book by <code class="language-plaintext highlighter-rouge">findById()</code>, it never has to <strong>leak out</strong> again.
This reduces the amount of <a href="/2016/11/21/naked-data.html">naked data</a> exposed to parts of the code that don’t need it.</p>

<p>The less data is visible, the <a href="/2016/11/21/naked-data.html">better</a> the design—at least from an OOP perspective.</p>

<p>Thus, using <code class="language-plaintext highlighter-rouge">findById()</code> followed by <code class="language-plaintext highlighter-rouge">remove()</code> embraces object-oriented principles more fully.
It allows for cleaner extension, better error handling, and tighter encapsulation.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="oop" /><summary type="html"><![CDATA[Delegating behavior to objects rather than invoking utility methods leads to cleaner, more extensible, and properly encapsulated object-oriented design.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/06/8-femmes.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/06/8-femmes.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Write Unit Tests, Don’t Waste Our Money!</title><link href="https://www.yegor256.com/2025/06/08/pull-request-without-test.html" rel="alternate" type="text/html" title="Write Unit Tests, Don’t Waste Our Money!" /><published>2025-06-08T00:00:00+00:00</published><updated>2025-06-08T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/06/08/pull-request-without-test</id><content type="html" xml:base="https://www.yegor256.com/2025/06/08/pull-request-without-test.html"><![CDATA[<p>Automated tests help us write code <a href="/angry-tests.html">faster</a>.
Unit tests immediately tell us when we break something.
Integration tests calm us down, reducing the fear of shipping a failure to a user.
But who are “us”?
Programmers.
What about our employers?
How do automated tests help them?
Automated tests protect their investments.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="La Femme Nikita (1990) by Luc Besson" src="/images/2025/06/la-femme-nikita.jpg" longdesc="#ccb58518" /><figcaption id="ccb58518">La Femme Nikita (1990) by Luc Besson</figcaption></figure>

<p>Every change we make to a codebase costs our employer money.
Whether they pay us monthly or per line of code, the bottom line is the same:
  it’s the code that reaches the repository and is eventually released to the end user.</p>

<p>That’s what the business is investing in—new features or bug fixes.
The code that’s written and shipped is what matters to them.</p>

<p>Even when they say they’re investing in people, what they really want is the code.
People are merely an intermediate by-product.
The ultimate asset is the codebase.</p>

<p>They want to <strong>protect</strong> that <strong>asset</strong>.</p>

<p>A loss of investment could be a hundred lines written today not working tomorrow.
Think about it this way: we expect a car to work after paying the body shop to fix it.
We don’t mind paying again if something else breaks—but not if it’s the exact same part they fixed yesterday.
We expect the repaired part to function properly while driving.
We want a warranty on what’s already been fixed.</p>

<p>Similarly, our employers expect our code to work once we’ve committed it and collected our paycheck.
They want a warranty that the code won’t break again once it’s been fixed.
Automated tests can offer that <strong>warranty</strong>.</p>

<p>Continuing the metaphor: “driving” a codebase means actively modifying its parts—refactoring or extending.
The more aggressively we drive it, the higher the risk of breaking something.
The parts of the code not covered by tests are the first to break.</p>

<p>Test coverage guarantees that what worked before—and was already paid for—continues to work even under the stress of refactoring.</p>

<p>So, any contribution to a codebase without a <strong>supporting</strong> test is a waste of the employer’s money.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="etiquette" /><category term="testing" /><summary type="html"><![CDATA[If you write code without tests, you're probably wasting your employer's money---because it'll break again right where you "fixed" it.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/06/la-femme-nikita.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/06/la-femme-nikita.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Good Title — Good Bug Report</title><link href="https://www.yegor256.com/2025/05/31/good-bug-title.html" rel="alternate" type="text/html" title="Good Title — Good Bug Report" /><published>2025-05-31T00:00:00+00:00</published><updated>2025-05-31T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/05/31/good-bug-title</id><content type="html" xml:base="https://www.yegor256.com/2025/05/31/good-bug-title.html"><![CDATA[<p>A few weeks ago, <a href="https://github.com/horw">@horw</a> released a new GitHub plugin that fixes GitHub issue titles: <a href="https://github.com/horw/issue-title-ai">issue-title-ai</a>.
Once an issue is created, the plugin asks <a href="https://chatgpt.com">ChatGPT</a>—or <a href="https://www.deepseek.com/">DeepSeek</a>, or <a href="https://claude.ai/">Claude</a>—to improve its title.
We’ve already integrated the plugin into <a href="https://github.com/objectionary/eo">objectionary/eo</a> and a few other repositories.
Works like a charm.
What’s wrong with the titles the way they are, you may ask?
Why do we need to ask ChatGPT to make them “better”?
Because we want every issue—either a bug report, a feature request, or a question—to be formulated as a <a href="/2025/05/25/bug-driven-development.html">complaint</a>.
It seems that very few of us can do it on the first try.
The help of AI is appreciated.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="Flawless (1999) by Joel Schumacher" src="/images/2025/05/flawless.jpg" longdesc="#6699c6ab" /><figcaption id="6699c6ab">Flawless (1999) by Joel Schumacher</figcaption></figure>

<p>Let’s say, you try to download a PNG file from a web app, but get a text file instead.
You want to report this problem to the team.
How would you title such a bug report?
Pick one, out of these eight:</p>

<ul>
  <li>“CSV”</li>
  <li>“CSV file downloading”</li>
  <li>“Please, fix CSV-file downloading”</li>
  <li>“CSV downloading must be fixed”</li>
  <li>“Why I get text file instead of PNG?”</li>
  <li>“How can I download PNG file?”</li>
  <li>“I need text file, not PNG”</li>
  <li>“PNG downloading is broken, getting CSV instead”</li>
</ul>

<p>There may be even more variations… but the best is the last one.
It clearly states that something is <strong>broken</strong>.
It demands a fix.</p>

<p>Even if it’s a feature request or a question, it should be filed as a complaint.
This rule—known as <a href="/2025/05/25/bug-driven-development.html">bug driven development</a>—increases our productivity.
In every request made to the team we have to explain the difference between our expectations and reality.
The lack of such an explanation seems to be the primary source of confusion and frustration in task tracking.</p>

<p>Apparently, very few programmers have this skill: formulating a problem as a complaint.
AI should help us.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="etiquette" /><category term="testing" /><summary type="html"><![CDATA[ChatGPT helps us re-format GitHub issue titles after their authors submit them --- helping developers understand their tasks better.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/05/flawless.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/05/flawless.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Stop Asking and Suggesting — Just Complain</title><link href="https://www.yegor256.com/2025/05/25/bug-driven-development.html" rel="alternate" type="text/html" title="Stop Asking and Suggesting — Just Complain" /><published>2025-05-25T00:00:00+00:00</published><updated>2025-05-25T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/05/25/bug-driven-development</id><content type="html" xml:base="https://www.yegor256.com/2025/05/25/bug-driven-development.html"><![CDATA[<p>Wikipedia <a href="https://en.wikipedia.org/wiki/Tester-driven_development">says</a> that Bug Driven Development (BDD) is an anti-pattern.
<a href="https://github.com/rajakolluru">Raja Shankar Kolluru</a> perfectly <a href="https://itmusings.com/bug-driven-development/">explains</a> why.
However, <a href="https://github.com/FlorianRappl">Florian Rappl</a> <a href="https://www.florian-rappl.de/News/Page/227/bug-driven-development">argues</a> that it’s not.
<a href="https://github.com/benwinding">Ben Winding</a> <a href="https://blog.benwinding.com/bug-driven-development-sometimes-its-the-best-choice/">believes</a> that it’s better than TDD.
In simple words, BDD is kind of like trying to build a plane while it’s flying, based on passenger complaints.
Nobody builds planes like that (well, maybe <a href="https://spectrum.ieee.org/how-the-boeing-737-max-disaster-looks-to-a-software-developer">Boeing</a> and <a href="https://www.theguardian.com/technology/2015/may/20/airbus-issues-alert-software-bug-fatal-plane-crash">Airbus</a>).
However, a software team that practices BDD might demonstrate higher productivity.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="Ghost Dog (1999) by Jim Jarmush" src="/images/2025/05/ghost-dog.jpg" longdesc="#32d0d0e9" /><figcaption id="32d0d0e9">Ghost Dog (1999) by Jim Jarmush</figcaption></figure>

<p>A software team does BDD if it follows one simple principle:
Every piece of work is formulated as a <strong>complaint</strong>.</p>

<p>It started <a href="https://www.researchgate.net/publication/2559439_An_Overview_of_the_Software_Engineering_Process_and_Tools_in_the_Mozilla_Project">in 2002</a>, by Mozilla:</p>

<blockquote>
  <p>Every code change in the Mozilla codebase is made as part of a “fix” for a uniquely numbered “bug.” Though it commonly has a pejorative connotation, in the Mozilla Project the term bug is used to refer to any filed request for modification in the software, be it an actual defect, an enhancement, or a change in functionality.</p>
</blockquote>

<p>If you listen to Mozilla’s advice, you won’t have feature requests, or questions, or tasks in your <a href="https://en.wikipedia.org/wiki/Issue_tracking_system">issue tracking system</a>.
Only bug reports.
They may sound like “The wing is on fire!”—a perfect complaint—or “A plane doesn’t have a jacuzzi!”—a perfect feature request in the form of a complaint.
Questions may also look like complaints: “It is unclear how to fasten the belt.”
Whether they are coming from testers or customers, the format is the same: “I don’t like it.”</p>

<p>The primary benefit that BDD can give to a project is <strong>noise reduction</strong>.
I can think of two reasons for that:</p>

<ol>
  <li>
    <p>Complaints, due to their rather aggressive nature, require their authors to provide strong arguments to back them up.
They must think twice before submitting a ticket that accuses the codebase of being broken or imperfect.
They must be specific and precise.
No noise.</p>
  </li>
  <li>
    <p>Similarly, programmers must convince a complainant that the problem is resolved.
They can’t close the ticket with just a text answer.
They need to demonstrate a reasonably significant contribution to the codebase.
No noise.</p>
  </li>
</ol>

<p>A good complaint identifies a <strong>flaw</strong> in something tangible.
A good resolution of a good complaint is a <strong>patch</strong> to that tangible something.
Obviously, in a software project, the <strong>source code</strong> is what is tangible.</p>

<aside class="quote">Bug tracker is not a support line for your coding troubles.
</aside>

<p>In a disciplined team, every ticket is a bug report that addresses a flaw in the source code.
Every bug report leads to a patch—a contribution to the source code.
No noise.
The team is focused and demonstrates the best possible productivity.</p>

<p>BDD also has a major drawback.
It may be hard to train the team to use it.
The adoption of BDD may require a change of their <strong>mindset</strong>.
They must switch from noise-makers to flaw-finders.</p>

<p><a href="https://blog.codinghorror.com/about-me/">Jeff Atwood</a>, in his blog post about <a href="https://blog.codinghorror.com/complaint-driven-development/">complaint-driven development</a>, explains it from a business point of view.
He suggests that instead of implementing what you believe is right, it’s better to give your customers a rough draft and let them complain.
You’re most often wrong about what they’ll actually complain about.
The more they complain, the better you listen, the bigger the value you deliver.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="etiquette" /><category term="testing" /><summary type="html"><![CDATA[When every piece of work is framed as a bug report --- including feature requests and questions --- a software team may become more productive.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/05/ghost-dog.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/05/ghost-dog.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">No BTW in Bug Reports</title><link href="https://www.yegor256.com/2025/05/18/bug-reports-as-contracts.html" rel="alternate" type="text/html" title="No BTW in Bug Reports" /><published>2025-05-18T00:00:00+00:00</published><updated>2025-05-18T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/05/18/bug-reports-as-contracts</id><content type="html" xml:base="https://www.yegor256.com/2025/05/18/bug-reports-as-contracts.html"><![CDATA[<p>Every ticket—a bug report or a feature request—is a short-term contract.
You, the reporter, hire them to make a fix or implement a feature.
They, the team of developers, do it for you—provided you pay, or their motivation is intrinsic—for example, in open source.
The discussion that happens along the way may help clarify the requirements of the contract.
It may also help the team convince you that the bug doesn’t deserve a fix.
Also, it may help them deliver the fix to you and convince you to close the ticket.
However, the discussion may also <strong>distract</strong> both parties if it loses focus.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="Bronx Tale (1993) by Robert De Niro" src="/images/2025/05/bronx-tale.jpg" longdesc="#f1eb3b02" /><figcaption id="f1eb3b02">Bronx Tale (1993) by Robert De Niro</figcaption></figure>

<p>This is how it happens:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Bug #42: The CSV file is saved in the wrong format.
Team: Can you provide an example?
You: Sure, here it is (attached).
Team: Looks like quotes are missing, we'll fix it.
You: BTW, why does the file have no header line?
Team: This is another problem, report it separately.
</code></pre></div></div>

<p>Indeed, the missing header line might also be a bug.
It’s related to the issue you just reported—but it’s not part of the contract you’ve established with the team.
Answering your question could distract them and blur their focus.
You don’t want that.
You want them to stay focused on the problem at hand.</p>

<p>A few more good recipes to distract them:</p>

<ul>
  <li>
    <p>“<strong>BTW</strong>, it would be great to have another feature that…”</p>
  </li>
  <li>
    <p>“<strong>BTW</strong>, why this code is designed this way?”</p>
  </li>
  <li>
    <p>“<strong>BTW</strong>, I wonder, how this works?”</p>
  </li>
</ul>

<p>All of these questions, complaints and suggestions are perfect candidates for new bug reports.</p>

<p>You might think a ticket is an opportunity to <a href="/2014/10/07/stop-chatting-start-coding.html">chat</a> with the team.
They’re already responding—so why not ask all your questions while you have their attention?
It feels like they’re interested, so you don’t want to lose the momentum.
But that’s a false assumption.
They’re <a href="/2014/11/24/principles-of-bug-tracking.html">not motivated</a> to keep the discussion open.
What they really want is to close the ticket—ASAP.
Dragging out the conversation only risks <strong>annoying</strong> them.</p>

<aside class="quote">Nothing hurts a software team more than a silent customer and an empty bug tracker.
</aside>

<p>You might also believe that submitting a ticket offends the team.
They already have a lot of work to do—why bother them with even more?
Every bug report or feature request might seem like an extra burden on their shoulders.
But again, that’s a false belief.
Bug reports are the <a href="/2018/02/06/where-to-find-more-bugs.html">fuel</a> for their engines.
They <a href="/2014/04/13/bugs-are-welcome.html">need</a> your tickets.
First, because they help clarify requirements.
Second, because they provide a sense that their work is <strong>needed</strong> and <strong>appreciated</strong>.
Nothing hurts a software team more than a silent customer and an empty bug tracker.</p>

<p>So, avoid saying “BTW” when talking to the team in a ticket.
Stick to requesting a fix for the bug you originally reported.
If something else comes to mind along the way—whether it’s a question, another bug, or a feature request—submit a <strong>new ticket</strong>.
We—and <a href="https://www.researchgate.net/publication/2559439_An_Overview_of_the_Software_Engineering_Process_and_Tools_in_the_Mozilla_Project">Mozilla</a>—believe that every ticket should be a <a href="/2018/04/24/right-way-to-report-bugs.html">bug report</a>.</p>

<p>You might also consider moving the conversation to a mailing list, as <a href="https://producingoss.com/da/bug-tracker-usage.html">suggested by Karl Fogel</a>.
Or even to Slack or Telegram.
But I <a href="/2016/08/23/communication-maturity.html">don’t recommend</a> it.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="testing" /><category term="etiquette" /><summary type="html"><![CDATA[Keep your ticket focused---one issue per report, no distractions, no "by the way"---this is how you help your team achieve higher efficiency.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/05/bronx-tale.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/05/bronx-tale.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Let the Bug Reporter Have the Last Word</title><link href="https://www.yegor256.com/2025/04/24/dont-close-their-tickets.html" rel="alternate" type="text/html" title="Let the Bug Reporter Have the Last Word" /><published>2025-04-24T00:00:00+00:00</published><updated>2025-04-24T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/04/24/dont-close-their-tickets</id><content type="html" xml:base="https://www.yegor256.com/2025/04/24/dont-close-their-tickets.html"><![CDATA[<p>Someone has submitted a bug report to your repository.
You fix the bug.
You close the bug report.
Stop.
This is wrong.
You shouldn’t close it.
Instead, you should ask the reporter to review your fix.
Then, maybe, they will close the ticket.
If they don’t, you make another fix, until they do.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="Analyze This (1999) by Harold Ramis" src="/images/2025/04/analyze-this.jpg" longdesc="#96fc5703" /><figcaption id="96fc5703">Analyze This (1999) by Harold Ramis</figcaption></figure>

<p>According to <a href="https://www.joelonsoftware.com/2000/11/08/painless-bug-tracking/">Joel Spolsky</a>, ``the only person who can close a bug is the person who opened it in the first place.’’
But, why?
Why shouldn’t you close it, when it’s obvious that the bug is fixed?
There are at least three reasons.</p>

<p>First, this is <strong>offensive</strong> and <strong>demotivating</strong>.
Why do I report a bug or suggest a feature?
Because I’m not happy with your code in its current state.
Something is broken or doesn’t work as expected.
I want you to fix it to make me happy.
I want you to confirm with me whether your fix has made me happy.
If you don’t ask and simply close the ticket, I <strong>feel</strong> like I’m being <strong>ignored</strong>.
Why would I bother reporting another bug or feature request?</p>

<p>Second, this is a <strong>quality threat</strong>.
Quality is always a product of conflict.
The most productive conflict is the one between programmers and testers.
Testers try to prove that the software is bad by submitting bug reports.
Programmers try to prove that the software is good by covering it with tests.
If you close without confirmation from the reporter, you don’t give them a chance to argue with you.
Of course, they may shrug their shoulders and reopen the ticket.
However, not everybody will do this, trying to avoid being disrespectful or simply not having enough permission.
In the end, no formal acceptance—no quality.</p>

<p>Third, this leads to ticket <strong>duplication</strong>.
Most bug reporters won’t argue when you close their tickets without asking their permission.
Instead, they will open new tickets with exactly the same or a similar description.
The most disciplined will refer to the original ticket.
Others will fill up the backlog with duplicates, making it messy.</p>

<hr />

<p>There are a few exceptions, though.
If the ticket is an obvious duplicate, you close it right away.
No need to ask its author for permission.
If it’s a question—not a bug report—you close it with an answer.
Also, if you aren’t planning to fix it, attach the <code class="language-plaintext highlighter-rouge">won't fix</code> badge to it and close.</p>

<p>P.S. I suggest avoiding <a href="https://docs.github.com/en/issues/tracking-your-work-with-issues/using-issues/linking-a-pull-request-to-an-issue">automatic issue closing</a> on pull request merge.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="oss" /><category term="etiquette" /><summary type="html"><![CDATA[Even if the fix looks obvious to you, don't close the bug report; instead, let its author do this after your request.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/04/analyze-this.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/04/analyze-this.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">We Don’t Merge into a Broken Master Branch</title><link href="https://www.yegor256.com/2025/04/19/dont-merge-into-broken-master.html" rel="alternate" type="text/html" title="We Don’t Merge into a Broken Master Branch" /><published>2025-04-19T00:00:00+00:00</published><updated>2025-04-19T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/04/19/dont-merge-into-broken-master</id><content type="html" xml:base="https://www.yegor256.com/2025/04/19/dont-merge-into-broken-master.html"><![CDATA[<p>What do you think is the most typical reason for delays in pull request reviews?
A <a href="https://doi.org/10.1145/3183519.3183525">study</a> at Google confirms that it’s the size—the more changes, the slower the review.
Another <a href="https://doi.org/10.1109/ACCESS.2020.3002663">study</a> shows that it’s the emotional tone—anger and dominance expressed in comments are linked to a lower likelihood of a pull request being merged.
A more recent <a href="https://doi.org/10.1016/j.jss.2020.110806">study</a> finds that it’s the author’s reputation: we merge PRs faster if we know the author.
All of the above is true.
In our projects, though, what often slows down PR reviews is the message: <strong>“CI failures are not related to my changes!”</strong></p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="Eye of the Beholder (1999) by Stephan Elliott" src="/images/2025/04/eye-of-the-beholder.jpg" longdesc="#343da90e" /><figcaption id="343da90e">Eye of the Beholder (1999) by Stephan Elliott</figcaption></figure>

<p>Here’s how it happens:
You fork a repo.
You make changes to fix a bug or introduce a new feature.
You commit them and push.
You submit a pull request.
You realize that some GitHub CI jobs fail.
You read the logs.
You don’t see any relevance between the error messages and your edits.
You post a comment: “CI failures are not related to my changes!”
You expect us to merge your pull request.</p>

<p>Why shouldn’t we?</p>

<p>We don’t merge them.
We ask you to step back—to the point before you started making changes.
Don’t make them yet.
Instead, check the build status of the repository.
Pay attention to all CI jobs, not just the one running Maven.
They all must be green.
Only when all jobs are green should you start editing the code.
If any job is red, report a bug and wait until the team gets everything passing.</p>

<p>Why?
Because we try to reduce the effort required to fix the build.
The more changes we pile onto a broken build, the higher the cost of cleaning it up.
When the build is broken, we accept no new changes—except those that fix the build.</p>

<p>What if the team takes too long to fix it?
What if the build never becomes green?
Still—you wait.
You don’t submit a pull request to a repository with a broken build.</p>

<hr />

<p>You may fix the build yourself.
If you do, submit it in a <strong>separate</strong> pull request.
Don’t mix build-fixing changes with any other edits.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="oss" /><category term="etiquette" /><summary type="html"><![CDATA[If the build is broken, don't send any pull requests until it's fixed. You're welcome to fix it yourself---just don't mix build-fixing changes with anything else.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/04/eye-of-the-beholder.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/04/eye-of-the-beholder.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Four Builds: A Balance Between Quality and Joy</title><link href="https://www.yegor256.com/2025/04/12/four-builds.html" rel="alternate" type="text/html" title="Four Builds: A Balance Between Quality and Joy" /><published>2025-04-12T00:00:00+00:00</published><updated>2025-04-12T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/04/12/four-builds</id><content type="html" xml:base="https://www.yegor256.com/2025/04/12/four-builds.html"><![CDATA[<p>How long should it take to know if your code is safe?
Martin Fowler once <a href="http://martinfowler.com/articles/continuousIntegration.html">said</a>: 10 minutes.
Ten years later, five hundred developers <a href="https://doi.org/10.1145/3106237.3106270">agreed</a>.
I disagree—with all of them.
First, ten minutes is not enough for a proper build, even for a small software system.
Second, ten minutes is too much for a build that we run from the IDE after every one-line edit.
We need a finer-grained classification of builds: from bullet-fast to thorough and dead slow.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="Trainspotting (1996) by Danny Boyle" src="/images/2025/04/trainspotting.jpg" longdesc="#b6b862c3" /><figcaption id="b6b862c3">Trainspotting (1996) by Danny Boyle</figcaption></figure>

<p>How long should a build be?</p>

<p>As long as it needs to be, in order to run all necessary tests.
Wrong.
Imagine a build that takes an hour.
The speed of development will be close to zero.
Programmers will complain.
A lot.</p>

<p>How about a build that takes a few seconds?
The speed of coding will be high—but not for long.
The quality of code will be jeopardized, because a quick build means weak testing, full of mocks.</p>

<p>So, how long should a build be?
The right answer is: between a few seconds and a few hours.
But the builds must be different.</p>

<h2 id="fast-build">Fast Build</h2>

<p>The first build is the one we run on our laptops.
It is <strong>fast</strong>.
It only includes unit tests.
Every one of them takes a few milliseconds.
Even if we have many, all together they can take less than a few seconds.
We also check test coverage thresholds.</p>

<p>If a local build takes longer than a few seconds, it starts being an obligation instead of a help.
We don’t run such a build because we enjoy the confidence it provides.
Instead, we run it because it’s “the right thing to do.”
Such a build is no fun, and is only an annoying routine.
A long build breaks the rhythm of energetic coding.</p>

<p>What about compilation?
The ten seconds include the time to compile the sources.
What if the project has hundreds of large C++ files that need a few minutes to compile?
We break such a project into smaller components—each with its own build and its own repository.
We don’t tolerate large codebases and <a href="/2018/09/05/monolithic-repositories.html">monolith</a> repositories.</p>

<h2 id="cheap-build">Cheap Build</h2>

<p>Finally, after running the fast build a few dozen times, we have enough confidence to submit a pull request.
Once submitted, GitHub picks it up and starts our workflows.</p>

<p>We have many of them, in different YAML files.
On top of unit tests, they run integration tests and all sorts of style checks.
We understand that the likelihood of failure is high,
because unit tests—those we ran in the fast build—are only a fraction of all tests.</p>

<p>We wait for a few minutes and see some workflows fail.
We investigate the failure, asking unit tests a question: “Why didn’t you catch this?”
When the answer is found, we patch the tests or create additional ones.
Then, we push and, again, wait a few minutes.
We see a new failure and repeat the cycle, which normally occurs a few times per branch.
Eventually, we see all GitHub workflows green.</p>

<p>We pay for this exercise.
First, GitHub charges per minute.
Second, the project pays us while we sit idle waiting for the answer from GitHub Actions.
That’s why we want the build to take less than ten minutes—it must be <strong>cheap</strong>.</p>

<h2 id="preflight-build">Preflight Build</h2>

<p>When all GitHub workflows are green, we hit the button, asking <a href="/2014/07/24/rultor-automated-merging.html">Rultor</a>—or GitHub <a href="https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/configuring-pull-request-merges/managing-a-merge-queue">Merge Queue</a>—to merge it.
A <strong>preflight</strong> build starts and takes up to an hour, at an on-demand AWS EC2 instance.
It takes so long because, on top of unit and integration tests, it runs, for example, mutation testing.
Even in a small codebase, ten minutes may not be enough.</p>

<p>Preflight builds may also run load, stress, performance, in-browser, and security penetration tests.
We don’t expect them to break after a green cheap build.
They do, however—but not often.
If they break, we get back to the fast build, blaming the safety net for negligence.
We reproduce the failure with a new unit test and make another merge attempt, expecting preflight to pass this time.
Eventually, it does, and the code goes to the <code class="language-plaintext highlighter-rouge">master</code> branch.</p>

<h2 id="proper-build">Proper Build</h2>

<p>Once in a while, we release a new version of the product—be it a library or a microservice.
This is when quality is the priority, while the duration of the build is irrelevant.
We hit the button and wait, for as long as necessary.
Sometimes a few hours.</p>

<p>Unlike all previous builds, this build is <strong>proper</strong>.
On top of all the tests mentioned above, it runs, for example, in-cloud multi-browser tests, automated A/B tests, and all sorts of regression tests.
In the future, most definitely, we’ll run LLM-based tests to detect design inconsistencies and security flaws.</p>

<p>Why didn’t we run these tests during the preflight build?
In order to avoid merge queue overflow.
A productive programmer may submit up to five pull requests per day.
With ten active contributors on a team, we may get a few dozen merges per day.
Since a merge queue can’t be parallelized, even one hour for a preflight may be too long.
A proper build definitely won’t fit.</p>

<p>Also, the integration with the production environment is time-consuming.
We enroll database changes, apply data migrations, update AWS configs, and switch between “green” and “blue” environments.</p>

<hr />

<p>In smaller projects, cheap and preflight builds may be similar.
In tiny projects, all three builds—cheap, preflight, and proper—may be identical.
However, we always keep the fast build different from the others.
The “four builds” framework may be reduced to a “two builds” one, but never to “one build fits all.”</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="devops" /><summary type="html"><![CDATA[Instead of trying to shorten the time that our builds take, we order and chain them by complexity, thus gradually reducing the risk.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/04/trainspotting.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/04/trainspotting.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Advice for First-Time Open Source Contributors</title><link href="https://www.yegor256.com/2024/12/15/open-source-beginner-advice.html" rel="alternate" type="text/html" title="Advice for First-Time Open Source Contributors" /><published>2024-12-15T00:00:00+00:00</published><updated>2024-12-15T00:00:00+00:00</updated><id>https://www.yegor256.com/2024/12/15/open-source-beginner-advice</id><content type="html" xml:base="https://www.yegor256.com/2024/12/15/open-source-beginner-advice.html"><![CDATA[<p>My <a href="https://github.com/eclipse-ee4j/jersey/blob/b2c7ba6d388cb9722f39073d7e82aa818fec49d5/core-common/src/test/java/org/glassfish/jersey/uri/internal/PathTemplateTest.java#L26">first attempt</a> to contribute to an open source repository was a miserable failure.
I picked a Java repository I was already using (<a href="https://en.wikipedia.org/wiki/Eclipse_Jersey">Glassfish Jersey</a>), created a unit test for an existing class, submitted a
patch (there were no pull requests at that time), and… it was merged.
I got excited and submitted another unit test in a new patch.
No surprise, the repository owners asked me to stop fooling around: apparently, they didn’t need unit tests just for the sake of it.
I quickly lost interest in making changes to anyone else’s code bases and started working on my own stuff instead.
Don’t repeat my mistake!
Becoming a contributor to an existing code base is a much faster path into the open source world and is far more rewarding.
Here are some things to keep in mind to make your journey to success even faster—especially if you are just a beginner making your first pull requests.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="Белое солнце пустыни (1970) by Владимир Мотыль" src="/images/2024/12/white-sun.jpg" longdesc="#78e09fd4" /><figcaption id="78e09fd4">Белое солнце пустыни (1970) by Владимир Мотыль</figcaption></figure>

<p><strong>Study Existing Files</strong>.
  Repository owners are usually proud of their code, no matter how ugly it might look.
  Don’t try to impress them with your unique formatting or naming style; this will only annoy them.
  Instead, study a few files they wrote and try to emulate their style as closely as possible.
  It’s safer.
  Once you’ve merged a few dozen pull requests, you can become more creative.
  But not now.</p>

<p><strong>Don’t Ask, Submit Issues</strong>.
  You are not the first contributor, nor will you be the last.
  Many people before you asked countless questions but wrote zero lines of code.
  Repository owners, especially in large projects, are not enthusiastic about teaching you or explaining how their code works.
  <a href="/2024/04/01/ping-me-please.html">Don’t bother them</a> with questions in Telegram.
  This will only demonstrate a lack of discipline.
  Instead, formulate every question as a <a href="/2025/05/25/bug-driven-development.html">new issue</a>, pointing out, for example: 1) lack of documentation, 2) inconsistent design, 3) high complexity, or anything else preventing you from quickly understanding the code and contributing.
  Such an issue is a valuable contribution in itself.
  Read more about <a href="/2025/05/25/bug-driven-development.html">bug driven development</a>.</p>

<p><strong>Blame the Code Base</strong>.
  If <code class="language-plaintext highlighter-rouge">master</code> branch is broken (you can’t build it locally due to some errors), don’t get frustrated.
  It’s not your fault.
  Instead, submit an issue and ask the team to fix it.
  They will respect such a bug report, because you’re, in this case, their tester, working for free.
  Don’t to start your own branch if master is broken.
  Wait <a href="/2025/04/19/dont-merge-into-broken-master.html">until it’s fixed</a>.</p>

<p><strong>Ping Them</strong>.
  When you submit a pull request, an issue, or a comment to existing pull requests and issues, make sure you mention the person whose attention you need.
  <a href="/2024/04/01/ping-me-please.html">Ping them</a>, without any hesitation.
  Otherwise, they simply will miss your message.</p>

<p><strong>Make Small Changes</strong>.
  There is nothing more frustrating for a maintainer than a large pull request from a stranger.
  The reasons are simple: first, strangers usually write bad code; second, they often become disappointed when told their code is bad.
  Thus, investing time in reviewing a large pull request from a new contributor is risky.
  At the same time, it’s sad to see potentially good code end up in the trash.
  Do everyone a favor and start small—less than 50 <a href="/2014/11/14/hits-of-code.html">hits-of-code</a> per pull request.
  This approach will lead to higher-quality reviews and faster merges.</p>

<p><strong>Pick Easiest Problems</strong>.
  Not sure what to contribute?
  Scan their backlog of tickets and find the easiest ones to fix.
  Don’t try to impress anyone with your first pull request by showing off how smart you are.
  Instead, impress them by quickly finding a low-hanging fruit, fixing it, and getting it merged.
  In large, high-quality projects, what really matters is your ability to get your code through the pipeline of checkers, linters, and reviewers.
  The simpler the problem you solve, the faster your solution will be accepted.
  This is all you care about at the beginning: being accepted.</p>

<p><strong>Write Tests</strong>.
  As simple as it sounds: every change you make should be motivated by a failing unit test that proves the code was broken before.
  If you, as a newcomer, modify code written by the owners, you must have a good reason.
  When they review your contribution, their first question will be: “Why did you do this?”
  The strongest argument is a failing unit test.
  You might even consider submitting a pull request with only a failing test first (disabled), getting it merged, and then submitting another pull request that fixes the test.</p>

<p><strong>Look Like a Human</strong>.
  Your pull request looks suspicious because you are a stranger.
  In the age of AI, some pull requests might be coming from bots, and this trend will only grow.
  You must prove you’re a <a href="/2020/07/29/open-source-etiquette.html">trustworthy</a> human being: set a decent avatar, put your real name in your profile, fill in all the required fields, and so forth.</p>

<p><strong>Explain Your Changes</strong>.
  When submitting a pull request, there is a text area for a description.
  If you leave it empty or write just a few words, it sounds like this:
    “<em>Hey guys, I wrote some code.
    Now it’s your job to figure out what it does, why it matters, and how it works.
    I’m off to bed because I’m sick of your codebase.
    Cheers!</em>”
  Needless to say, this won’t help your pull request get merged anytime soon.</p>

<p><strong>Aim for Quality</strong>.
  Studies <a href="https://ieeexplore.ieee.org/document/7202946/">show</a> that most rejections of open source pull requests happen due to formatting and stylistic mistakes, not incorrect functionality.
  Keep this in mind.
  Pay attention to how you format your code, how you document your changes, and how many comments you add to every new method or class.
  This is what reviewers will look at first.
  It will form their initial impression of you.</p>

<p><strong>Be Polite and Persistent</strong>.
  The people you submit code to <a href="https://dl.acm.org/doi/10.1145/3377816.3381732">may be rude</a>.
  Don’t take it personally.
  They deal with hundreds of newcomers who write poor-quality code and assume it’s beautiful.
  No matter how <a href="https://dl.acm.org/doi/10.1145/3510003.3510111">aggressive</a> or resentful they sound, remain polite and professional.
  Don’t walk away after the first <a href="https://dl.acm.org/doi/10.1145/3479497">negative</a> comment.
  Keep insisting that your pull request deserves a merge.
  Pay attention to what they say, not how they say it.
  In the end, you want to get your code through.
  You don’t want to become their friend; you want your code to be merged.
  Read about <a href="/2020/07/29/open-source-etiquette.html">open source etiquette</a> too.</p>

<hr />

<p>You may also want to watch my course <a href="https://github.com/yegor256/osbp">“Open Source Best Practices”</a> recently taught to BSc students of <a href="https://innopolis.university/">Innopolis University</a>:
<a href="https://www.youtube.com/playlist?list=PLaIsQH4uc08zjutyoBOtoa6fnxzrCQK2Q">eight video lectures</a>.
At the lectures, most of the topics mentioned above are discussed in details.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="oss" /><category term="etiquette" /><summary type="html"><![CDATA[Making first steps in open source is hard. Submitting pull requests to big and popular repositories is very hard. These recommendations may help you simplify this task.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2024/12/white-sun.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2024/12/white-sun.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>