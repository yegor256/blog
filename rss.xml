<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://www.yegor256.com/rss.xml" rel="self" type="application/atom+xml" /><link href="https://www.yegor256.com/" rel="alternate" type="text/html" /><updated>2026-01-11T20:43:37+00:00</updated><id>https://www.yegor256.com/rss.xml</id><title type="html">Yegor Bugayenko</title><subtitle>Yegor Bugayenko</subtitle><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><entry><title type="html">Comments Considered Harmful in the Age of LLMs</title><link href="https://www.yegor256.com/2026/01/11/no-documentation-comments.html" rel="alternate" type="text/html" title="Comments Considered Harmful in the Age of LLMs" /><published>2026-01-11T00:00:00+00:00</published><updated>2026-01-11T00:00:00+00:00</updated><id>https://www.yegor256.com/2026/01/11/no-documentation-comments</id><content type="html" xml:base="https://www.yegor256.com/2026/01/11/no-documentation-comments.html"><![CDATA[<p>Writing code documentation is a pain.
Not writing it leads to even bigger pain—we can’t comprehend the code.
However, writing it and then forgetting to update it causes the ultimate pain: it lies and confuses us.
How about we cure all three pains at once: <em>prohibit all comments!</em>
How do we know what the intent of the code is if we don’t have any comments?
We ask an LLM to explain it to us.
What if the LLM fails to explain and confesses its inability?
Then, we automatically fail the build and blame the author of the code.
Thus, we introduce a new quality gate: <em>Code Interpretability Score</em>.
The build passes only if this score is high enough.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="Full Metal Jacket (1987) by Stanley Kubrick" src="/images/2026/01/full-metal-jacket.jpg" longdesc="#dc7c81cb" /><figcaption id="dc7c81cb">Full Metal Jacket (1987) by Stanley Kubrick</figcaption></figure>

<p>The best minds in software engineering have long dreamed of self-documenting code.
In 1974, <a href="https://en.wikipedia.org/wiki/Brian_W._Kernighan">Brian Kernighan</a> and <a href="https://en.wikipedia.org/wiki/P._J._Plauger">Phillip James Plauger</a> <a href="https://en.wikipedia.org/wiki/The_Elements_of_Programming_Style">said</a> that
  “the only reliable documentation of a computer program is the code itself.”
In 2004, <a href="https://en.wikipedia.org/wiki/Steve_McConnell">Steven McConnell</a> in <a href="https://amzn.to/2cs4cXW"><em>Code Complete</em></a> claimed that
  “the main contributor to code-level documentation isn’t comments, but good programming style.”
In 2008, <a href="https://en.wikipedia.org/wiki/Robert_C._Martin">Robert Martin</a> in <a href="https://amzn.to/2m7LmaA"><em>Clean Code</em></a> suggested that
  “if our programming languages were expressive enough, or if we had the talent to subtly wield those languages to express our intent,
  we would not need comments very much—perhaps not at all.”
They all wanted the same thing: code that explains itself.
They just lacked the tools to enforce it.</p>

<p>Why do we write comments at all?
A Java method of a hundred lines may take hours to understand.
A tiny Javadoc block saves this time:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Recursively finds the shortest
 * path between two nodes in the graph.
 */</span>
<span class="kt">int</span><span class="o">[]</span> <span class="nf">shortest</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">g</span><span class="o">,</span> <span class="kt">int</span> <span class="n">a</span><span class="o">,</span> <span class="kt">int</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// A hundred lines of code go</span>
  <span class="c1">// here, which we have no desire</span>
  <span class="c1">// to read and understand.</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Comments promise to help us but fail in two distinct ways.</p>

<p>First, they are <em>unclear</em>.
<a href="https://en.wikipedia.org/wiki/David_Parnas">David Parnas</a> once <a href="https://doi.org/10.1109/icse.1994.296790">said</a> that
  “documentation that seems clear and adequate to its authors is often about <em>as clear as mud</em> to the
  programmer who must maintain the code six months or six years later.”
What the author considers obvious, the reader finds cryptic.</p>

<p>Second, they <em>decay</em>.
Being static metadata, comments do not evolve automatically with the code.
If the implementation of the <code class="language-plaintext highlighter-rouge">shortest()</code> function stops being recursive, we may forget to update the Javadoc block.
Such negligence leads to <em>hallucinating documentation</em> that causes bugs, broken trust, and wasted debugging time.
In 1999, <a href="https://en.wikipedia.org/wiki/Andy_Hunt_(author)">Andrew Hunt</a> and <a href="https://en.wikipedia.org/wiki/Dave_Thomas_(programmer)">Dave Thomas</a> in <a href="https://en.wikipedia.org/wiki/The_Pragmatic_Programmer"><em>The Pragmatic Programmer</em></a> warned that
  “<em>untrustworthy</em> comments are <em>worse</em> than no comments at all.”
A recent <a href="https://doi.org/10.1145/3663529.3664458">analysis</a> of 13 open source projects
  demonstrated that out-of-date comments are not rare but common.</p>

<p>Now we have a tool that solves both problems: the LLM.</p>

<p>Instead of writing the Javadoc block manually, we let the IDE generate it on-demand.
The LLM reads the hundred lines of code, comprehends it, and summarizes the intent in a single English sentence.
Modern models accomplish this task better than most humans.
The documentation is always fresh because it is generated from the current code, not from a stale comment written months ago.</p>

<p>But we can go further.
We can integrate an LLM into the build pipeline and ask it to assess the <em>Code Interpretability Score</em> (CIS) of every function.
If the model has low confidence in explaining the logic, this signals that the code is too clever or convoluted.
The compiler can enforce a threshold: if the CIS is too low, the build fails.
This transforms readability from a subjective preference into an objective, measurable quality gate.</p>

<p>Once this gate exists, manual comments become not just unnecessary but <em>harmful</em>.
They introduce a second source of truth that can contradict the code.
The logical conclusion: prohibit them entirely.
This forces developers to write clean, structured logic that is inherently machine-interpretable.</p>

<p>Robert Martin wished for more expressive languages.
He didn’t know about LLMs.
Today, we don’t need better languages—we need an LLM that can interpret any language.
If the LLM can’t explain the code, we blame the programmer and stop the build.</p>

<hr />

<p>We are thinking about making <a href="https://www.eolang.org">EO</a>, our experimental object-oriented language, this restrictive.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="quality" /><summary type="html"><![CDATA[Instead of writing code comments that decay and mislead, let LLMs generate documentation on-demand and fail the build when code is too obscure for them to explain.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2026/01/full-metal-jacket.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2026/01/full-metal-jacket.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">The Fall of JavaScript</title><link href="https://www.yegor256.com/2025/12/28/fall-of-javascript.html" rel="alternate" type="text/html" title="The Fall of JavaScript" /><published>2025-12-28T00:00:00+00:00</published><updated>2025-12-28T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/12/28/fall-of-javascript</id><content type="html" xml:base="https://www.yegor256.com/2025/12/28/fall-of-javascript.html"><![CDATA[<p>In 1995, <a href="https://github.com/BrendanEich">Brendan Eich</a> was hired by <a href="https://en.wikipedia.org/wiki/Netscape">Netscape</a> and asked to create a language for their HTML browser.
Rumors say, he designed Mocha in <a href="https://exploringjs.com/es5/ch04.html">10 days</a>, later renamed to <a href="https://stackoverflow.com/questions/2018731">LiveScript</a>, and then to <a href="https://en.wikipedia.org/wiki/JavaScript">JavaScript</a>.
It was <a href="https://brendaneich.com/2008/04/popularity/">planned</a> to make it similar to <a href="https://www.scheme.org/">Scheme</a>, a LISP-syntax language.
Instead, to <a href="https://brendaneich.com/2008/04/popularity/">please</a> the crowd of C++/Java coders, it was made syntactically similar to Java.
In 2008, Brendan made a tragic mistake: he <a href="https://www.theguardian.com/technology/2014/apr/02/controversial-mozilla-ceo-made-donations-right-wing-candidates-brendan-eich">donated</a> $1,000 in support of Californian anti-gay marriage <a href="https://en.wikipedia.org/wiki/2008_California_Proposition_8">law</a>.
In 2014, he joined <a href="https://www.mozilla.org/">Mozilla</a> as a CEO and the crowd <a href="https://www.cbc.ca/news/science/okcupid-protests-new-mozilla-ceo-s-anti-gay-marriage-donation-1.2593629">remembered</a> his anti-diversity gesture.
He had to <a href="https://blog.mozilla.org/en/mozilla/brendan-eich-steps-down-as-mozilla-ceo/">step down</a> and founded Brave Software, the developer of the <a href="https://brave.com/">Brave</a> browser.
Somewhere around that time they started to kill JavaScript.
Still doing it pretty good, thanks to recent <a href="https://en.wikipedia.org/wiki/ECMAScript">ECMAScript</a> updates and <a href="https://www.typescriptlang.org/">TypeScript</a>.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="Platoon (1986) by Oliver Stone" src="/images/2025/12/platoon.jpg" longdesc="#aeacd232" /><figcaption id="aeacd232">Platoon (1986) by Oliver Stone</figcaption></figure>

<p>In the JavaScript created 30 years ago, objects were primitive associative arrays of properties.
Either data, a function, or another object may be attached to a property of an object.
Let’s see what Brendan <a href="https://brendaneich.com/2008/04/popularity/">said</a> about JS in 2008:</p>

<blockquote>
  <p>I’m happy that I chose Scheme-ish first-class functions and Self-ish prototypes as the main ingredients.</p>
</blockquote>

<p>First-class functions mean that it’s possible to use a function as a value assignable to a variable.
And then he <a href="https://brendaneich.com/2008/04/popularity/">concluded</a> (pay attention, it’s C not C++):</p>

<blockquote>
  <p>Yet many curse it, including me. I still think of it as a quickie love-child of C and Self.</p>
</blockquote>

<p><a href="https://selflanguage.org/">Self</a>, which he refers to a few times, is a prototype-based object-oriented language
  designed by <a href="https://en.wikipedia.org/wiki/David_Ungar">David Ungar</a> and <a href="https://www.linkedin.com/in/randallsmith1/">Randall Smith</a> in <a href="https://en.wikipedia.org/wiki/PARC_(company)">Xerox PARC</a>, then <a href="https://www.stanford.edu/">Stanford University</a>, and then <a href="https://en.wikipedia.org/wiki/Sun_Microsystems">Sun Microsystems</a>.
Self doesn’t have classes, unlike Java or C++.
Instead, it only has objects.
To create a new object in Self we make a copy of an existing object, known as prototype, and then modify some of its slots (attributes).</p>

<p>In Self, objects don’t have types: all method calls are dispatched in runtime.
For example, we ask a book to rename itself:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>book rename: "Object Thinking".
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">rename</code> is the method of the <code class="language-plaintext highlighter-rouge">book</code> that we call with a single string argument.
The computer doesn’t know anything about the <code class="language-plaintext highlighter-rouge">book</code> until it’s time to call the <code class="language-plaintext highlighter-rouge">rename</code> method.
Obviously, such a <a href="https://en.wikipedia.org/wiki/Duck_typing">duck typing</a> has its performance drawback.
Every <code class="language-plaintext highlighter-rouge">rename</code> leads to a search in a <a href="https://en.wikipedia.org/wiki/Dispatch_table">virtual table</a> of <code class="language-plaintext highlighter-rouge">book</code>.
To the contrary, C++, where types are known in compile time, can dispatch <code class="language-plaintext highlighter-rouge">rename()</code> instantly:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Book b;
b.rename("Object Thinking");
</code></pre></div></div>

<p>Types (classes in C++ and interfaces in Java) and <a href="/2025/08/17/type-annotations.html">type annotations</a> are helpful—to the compiler.
To us humans they are a burden.
They require us to do the work of the compiler.
We have to pollute our code with messages like: “This object <code class="language-plaintext highlighter-rouge">b</code> is of type <code class="language-plaintext highlighter-rouge">Book</code>, please remember.”
The compiler must be smart enough to understand it without our hints.</p>

<p>This is a debatable topic though.
Some believe that type annotations help programmers better understand the code and make fewer mistakes.
I’m also in favor of fewer mistakes, but would rather expect the compiler to infer types automatically, without my annotations.
If I do <code class="language-plaintext highlighter-rouge">b.rename()</code> and <code class="language-plaintext highlighter-rouge">b</code> is known to be a car instead of a book, I would expect the compiler to figure this out on its own and refuse to compile.</p>

<p>Anyway, JavaScript was designed as a prototype-based dynamically typed language with a minimalistic syntax that resembles Java.
It worked perfectly fine until the industry decided to “fix” it.</p>

<aside class="quote">JavaScript worked perfectly fine until the industry decided to fix it.
</aside>

<p>In 2008, <a href="https://www.mozilla.org/">Mozilla</a> and others <a href="https://auth0.com/blog/the-real-story-behind-es4/">proposed</a> ECMAScript 4, which included classes, modules, and other features.
<a href="https://www.microsoft.com/">Microsoft</a> took an <a href="https://www.theregister.com/2008/08/15/adobe_microsoft_ecma_javascript/">extreme position</a>, refusing to accept any part of ES4.
Chris Wilson, Microsoft’s Internet Explorer platform architect, <a href="https://www.theregister.com/2008/08/15/adobe_microsoft_ecma_javascript/">criticized</a> ES4 for trying to introduce too many changes.
Brendan Eich <a href="https://www.theregister.com/2008/08/15/adobe_microsoft_ecma_javascript/">accused</a> Wilson of spreading falsehoods and playing political games.
ES4 was <a href="https://auth0.com/blog/the-real-story-behind-es4/">abandoned</a>, and classes were dropped.</p>

<p>Then, in 2012, Microsoft created <a href="https://www.typescriptlang.org/">TypeScript</a>, a JavaScript with type annotations and classes.
Since classes weren’t in the standard, Microsoft made their own.</p>

<p>Finally, in 2015, <a href="https://262.ecma-international.org/6.0/">ECMAScript 6</a> added classes (among other features) to the JavaScript specification.
Many ES4 features, including classes, were <a href="https://auth0.com/blog/the-real-story-behind-es4/">revived</a> in a “maximally minimal” form.
The crowd of Java/C++ developers got what they wanted.</p>

<p>Let’s hear what <a href="https://www.crockford.com/pronto.html">Douglas Crockford</a>, the creator of <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> and <a href="https://github.com/jslint-org/jslint">JSLint</a>, <a href="https://www.youtube.com/watch?v=PSGEjv3Tqo0&amp;t=360s">said</a> in 2014:</p>

<blockquote>
  <p>Class-free programming is JavaScript’s contribution to humanity.</p>
</blockquote>

<p>Unfortunately, not anymore.
It looks like the developers of recent versions of JS believe in something else.
Or maybe they don’t want to make a contribution to humanity anymore.
Maybe they just want to make the crowd happy.</p>

<p>Type annotations and classes don’t match with the concept of class-free object-based programming of JavaScript.
They came from Java or C++ but don’t fit in.
Some programmers may find them helpful, but only because they are used to seeing them in other languages.
JavaScript is not Java, even though the names look similar.</p>

<p>Java, with its
  <a href="/2016/09/20/oop-without-classes.html">classes</a>,
  <a href="/2016/09/13/inheritance-is-procedural.html">implementation inheritance</a>,
  and
  <a href="/2014/05/05/oop-alternative-to-utility-classes.html">static methods</a>,
  is OOP for dummies.
It’s object-oriented programming for those who, according to <a href="https://www.youtube.com/watch?v=PSGEjv3Tqo0&amp;t=360s">Douglas Crockford</a>, don’t know what
  <a href="/2016/08/15/what-is-wrong-object-oriented-programming.html">object-oriented programming</a> is.
JavaScript, on the other hand, is a member of conceptually solid OO languages, like <a href="https://en.wikipedia.org/wiki/Smalltalk">Smalltalk</a> and Self.
Blending Java flavors into JavaScript only ruins the flavor of the latter.</p>

<p>It’s sad to see how a once straight object-centric language paradigm turned into a diversity of unmatchable and suboptimal features.</p>

<p>P.S. JavaScript is still a great language if you ignore classes and type annotations.
When I write in JavaScript, I don’t use them.
Look at the code in the <a href="https://github.com/yegor256/jo">yegor256/jo</a> repository.
It illustrates the <a href="/junior-objects.html">Junior Objects</a> book of mine.
I’m proud of this code.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="oop" /><summary type="html"><![CDATA[JavaScript was an elegant prototype-based class-free language until TypeScript and ES6 classes ruined it.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/12/platoon.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/12/platoon.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">You Are the Low-Hanging Fruit</title><link href="https://www.yegor256.com/2025/11/30/internal-vs-external-obstacles.html" rel="alternate" type="text/html" title="You Are the Low-Hanging Fruit" /><published>2025-11-30T00:00:00+00:00</published><updated>2025-11-30T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/11/30/internal-vs-external-obstacles</id><content type="html" xml:base="https://www.yegor256.com/2025/11/30/internal-vs-external-obstacles.html"><![CDATA[<p>Let’s say, you are a startup founder, like <a href="https://www.zerocracy.com">myself</a>.
Try to hire a sales guy.
Offer him a commission-only payment scheme.
Listen to his reaction: he will demand that you pay a fixed salary too, on top of commission.
Try to convince him that commission-only is a more reasonable and <a href="/2014/09/24/why-monetary-awards-dont-work.html">motivating</a> setup.
Goto 1.
After a number of iterations you realize that the mission is impossible.
Sales people are good at selling and the best thing they sell is the idea that their <em>time</em> must be compensated.
Even if they don’t sell the product to your customers.
If you don’t buy the idea, they go find another loser who will.
Something similar happens when you try to pay programmers by result.
They easily convince you to pay for <a href="/2015/07/21/hourly-pay-modern-slavery.html">their time</a>.
And you do.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="City of God (2002) by Kátia Lund" src="/images/2025/11/city-of-god.jpg" longdesc="#1e31b0ff" /><figcaption id="1e31b0ff">City of God (2002) by Kátia Lund</figcaption></figure>

<p>A sales rep doesn’t know how to write code.
Most of them don’t even know how computers work.
However, he <em>perfectly</em> knows how to bullshit people.
That’s exactly why we need him.
Because we don’t know how to bullshit people and we don’t want to learn it.</p>

<p>Now, two strategies lie in front of him.
He can use the skill against the prospects on the market and turn them into paying customers.
He can also use the same selling skill against you, the owner of the startup.
Instead of selling the product to the market he can sell <em>himself</em> to you.
He can sell the idea that even if he fails to sell the product to the customers he still deserves a decent weekly paycheck.</p>

<p>What do you think, which sale is easier to make?
What would you do in his shoes?
The answer is obvious.
The customers are far away and they have no mercy.
If they don’t like the offer, they simply hang up on him and that’s it.
You, on the other hand, sit next to him in the same office and can’t hang up.
You are the <em>low-hanging fruit</em>.
You are the <em>weakest</em> prey he can reach out to.</p>

<aside class="quote">In order to make him focus on external obstacles, you should make internal ones harder to overcome.
</aside>

<p>A customer is an <em>external</em> obstacle that he must overcome in order to get paid, as a sales commission.
You are an <em>internal</em> obstacle, which he may also overcome to get a fixed weekly payment.
You need him to fight the external obstacle.
However, he is free to choose the <em>easiest</em> path.</p>

<p>In order to make him focus on external obstacles, you should make internal ones <em>harder</em> to overcome.
Joseph Stalin once <a href="https://www.goodreads.com/quotes/338750-in-the-soviet-army-it-takes-more-courage-to-retreat">said</a> that “in the Soviet army it takes more courage to retreat than advance.”
This war-time concept seems relevant to the sales guys you hire.
It must be harder for them to talk you into paying them a fixed salary than to convince a prospect to buy your product.</p>

<p>Emotionally, for you it may be rather challenging to constantly push him back.
Just like it’s often hard to say “No” to a vagrant begging for a dollar at the corner.
Beggars, unless they are physically disabled, also, just like sales people, have two possible life strategies.
Either find a job or beg at the corner.
The begging strategy, for the vagrant and for the sales rep, is <em>easier</em> to pursue.</p>

<p>Programmers are not much different.
They also have two strategies.
They can solve technical problems by merging qualified pull requests.
They can also persuade you that you must pay for their time, not their pull requests.
Which obstacle is going to be harder for them to overcome depends on <em>you</em>.</p>

<p>First, you set up a formula for measuring their contribution.
Second, you bind their paychecks to it: they get paid <a href="/2016/05/24/who-is-project-manager.html">not by you</a>,
  but by <em>merged pull requests</em>.
Finally, you taboo the very possibility of discussing time-based compensation.</p>

<aside class="quote">Taboo the very possibility of discussing time-based compensation.
</aside>

<p>What you get is a technical team focused on resolving external problems.
The team will <em>advance</em> because it will be <a href="/2018/07/24/bugs-or-pull-requests.html">pointless</a> to <em>retreat</em>.
You simply <a href="/2015/07/21/hourly-pay-modern-slavery.html">won’t pay</a> them for their time.
No matter how many times they repeat “I was working hard the entire weekend.”</p>

<p>Incentives shape behavior.
If you reward excuses, you buy excuses.
If you reward results, you get results.
As a founder, your job is to eliminate the temptation for your team to <a href="/2019/07/10/inversive-management.html">sell you</a>
  anything other than tangible artifacts.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="management" /><summary type="html"><![CDATA[Sales reps and programmers can either fight external obstacles to earn their pay, or convince you, the founder, to pay for their time regardless of results; make the internal path harder.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/11/city-of-god.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/11/city-of-god.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Small Repo, High Quality</title><link href="https://www.yegor256.com/2025/11/16/smaller-repository-higher-quality.html" rel="alternate" type="text/html" title="Small Repo, High Quality" /><published>2025-11-16T00:00:00+00:00</published><updated>2025-11-16T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/11/16/smaller-repository-higher-quality</id><content type="html" xml:base="https://www.yegor256.com/2025/11/16/smaller-repository-higher-quality.html"><![CDATA[<p>I don’t like <a href="/2018/09/05/monolithic-repositories.html">monolithic repositories</a>.
They keep multiple projects together, often written in different languages, by different teams.
Unfortunately, <a href="https://dl.acm.org/doi/pdf/10.1145/2854146">Google</a>, <a href="https://engineering.fb.com/2025/10/16/developer-tools/branching-in-a-sapling-monorepo/">Facebook</a>, and <a href="https://shiftmag.dev/mono-repo-infrastructure-yandex-1011/">Yandex</a> favor them.
Primarily, according to them, <a href="https://monorepo.tools/">monorepos</a> reduce integration <a href="https://www.sonarsource.com/resources/library/monorepo/">overhead</a>.
They do, but at the cost of quality.
In smaller repositories we can develop better code.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="Морфий (2008) by Алексей Балабанов" src="/images/2025/11/morphine.jpg" longdesc="#04b3173e" /><figcaption id="04b3173e">Морфий (2008) by Алексей Балабанов</figcaption></figure>

<p>When a repository is smaller you can achieve higher quality, for a number of reasons:</p>

<ul>
  <li>
    <p><strong>You can be stricter on style.</strong>
It’s easier to keep a thousand lines consistently formatted than a million.
With a thousand lines, you can configure <a href="https://eslint.org/">ESLint</a> to its maximum, enabling as many rules as you can find.
Stricter <a href="/2014/08/13/strict-code-quality-control.html">control</a> over code stylistics leads to cleaner code.</p>
  </li>
  <li>
    <p><strong>You can write deeper tests.</strong>
Integration (or <a href="/2023/08/22/fast-vs-deep-testing.html">deep</a>) tests are inevitably slow.
In a smaller repository, a good integration test coverage doesn’t mean a slow build.
In a larger repository—it does.
A slow build is something a team tries to avoid, thus jeopardizing the coverage.</p>
  </li>
  <li>
    <p><strong>You can review more pedantically.</strong>
In a larger repository it may be harder to remember all the aspects of design.
A pull request that affects different seemingly unrelated code parts
may be a challenge to <a href="/2015/02/09/serious-code-reviewer.html">review</a>.
Even if you are the <a href="/2014/10/12/who-is-software-architect.html">architect</a>.</p>
  </li>
  <li>
    <p><strong>You can write a README.</strong>
Maybe you have noticed already: large open source projects have short and sketchy <a href="/2019/04/23/elegant-readme.html">README</a> files.
They can’t make them much longer without them becoming as large as a book.
All they can do is redirect the reader to the documentation website.
The inability to explain the entire scope in a single file leads to scope creep.
Contributors struggle to understand the borders of the project.
This leads, among other bad things, to code duplication.</p>
  </li>
  <li>
    <p><strong>You can release frequently.</strong>
In a larger repository, frequent reintegration may be expensive, in both time and money.
In a small repo, a <a href="/2025/04/12/four-builds.html">build</a> of a few seconds is not a dream of programmers, it’s their reality.
Not only CI is cheap, but also CD.
After every small change you can publish a new release, with its own <a href="https://semver.org/">version</a>.
In a monorepo, we tend to wait until a portion of changes accumulate.</p>
  </li>
  <li>
    <p><strong>You can use AI agents effectively.</strong>
It is no secret that modern LLMs have limited <a href="https://docs.claude.com/en/docs/build-with-claude/context-windows">context windows</a>.
A million lines of code can’t fit into even the largest of them.
Even ten thousand lines, let alone a million, is more than an LLM can digest.
By keeping a repository small we do a big favor to our little friends: AI agents.</p>
  </li>
  <li>
    <p><strong>You can on-board faster.</strong>
Larger codebases are usually older and more <a href="/2018/09/12/clear-code.html">chaotic</a>, full of legacy code.
It takes longer to start making meaningful contribution to such a repository.
Monorepos attract
<a href="/2015/12/29/turnover-is-good-for-maintainability.html">long-term</a>
<a href="/2017/05/02/remote-slaves.html">office-based</a>
contributors
who care about job security more than about code quality.</p>
  </li>
  <li>
    <p><strong>You can expect responsibility.</strong>
In larger codebases, the very idea of code ownership is hard to maintain.
Programmers can hardly feel responsible for the code written and modified by others.
Smaller repositories, on the other hand, emotionally attach people to code.</p>
  </li>
  <li>
    <p><strong>You can go open source.</strong>
No matter how much your boss <a href="/2020/05/05/open-source-arms-race.html">loves</a>
open source, you can’t put your entire enterprise monorepo on GitHub.
However, if you extract a small part of it, you can.
The code that is open, visible and criticized by many people,
is <a href="/2015/12/22/why-dont-you-contribute-to-open-source.html">allegedly</a> of a higher quality.</p>
  </li>
</ul>

<p>In summary, you should look for an opportunity to extract a piece of code as a standalone package.
Then, insist on making it <a href="/2017/05/30/why-contribute-to-open-source.html">open source</a>.
Then, promote it in the community.
Then, quit your office job and join <a href="https://www.zerocracy.com">Zerocracy</a>.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="oss" /><summary type="html"><![CDATA[By breaking your software into small open-source packages, you make the entire product easier to maintain—and significantly higher in quality.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/11/morphine.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/11/morphine.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Can’t Merge? Don’t Despair.</title><link href="https://www.yegor256.com/2025/11/09/help-me-cant-merge.html" rel="alternate" type="text/html" title="Can’t Merge? Don’t Despair." /><published>2025-11-09T00:00:00+00:00</published><updated>2025-11-09T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/11/09/help-me-cant-merge</id><content type="html" xml:base="https://www.yegor256.com/2025/11/09/help-me-cant-merge.html"><![CDATA[<p>You’ve made a pull request, but it won’t merge.
A reviewer says it’s not good or the tests don’t pass.
No matter what, you can’t get it into the master branch.
You keep fixing the branch, keep convincing the reviewer, keep hating the tests.
Stop.
Try <em>smarter</em> tactics.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="Amores Perros (2000) by Alejandro González Iñárritu" src="/images/2025/11/amores-perros.jpg" longdesc="#d0b0373b" /><figcaption id="d0b0373b">Amores Perros (2000) by Alejandro González Iñárritu</figcaption></figure>

<h2 id="1-give-up-instantly">1. Give Up Instantly</h2>

<p>First, <a href="https://en.wikipedia.org/wiki/Fail_fast">fail fast</a>.
Give up quickly.
If it doesn’t go through smoothly, <em>close it</em>.
If the reviewers’ complaints are more than stylistic issues, your understanding of the architecture is flawed.</p>

<p>Ask yourself, how did this happen?
Why did you, a smart programmer, get a wrong understanding of the architecture?
Obviously, it’s <a href="/2015/02/16/it-is-not-a-school.html">not your mistake</a>.
It’s a bug in the repository.
Its <a href="/2019/04/23/elegant-readme.html">README</a> isn’t complete, its code isn’t clean enough, its documentation is outdated.</p>

<p>What do you do?
You <a href="/2025/05/25/bug-driven-development.html">blame</a> them by submitting <a href="/2014/04/13/bugs-are-welcome.html">bug reports</a>.
Then, when they fix the repository, you try again, with a new pull request.</p>

<h2 id="2-take-a-smaller-bite">2. Take a Smaller Bite</h2>

<p>Most likely they don’t complain about all the changes you’ve made.
Something looks good to them, while they refuse to accept something else.
Good, remove the bad parts from your pull request.</p>

<p>Don’t waste time trying to sell the entire package in one go.
Instead, give them as much as they’re <em>ready to accept</em>.
In the end, you will merge a few pull requests instead of one.
The more, the better, at least for us in <a href="https://www.zerocracy.com">Zerocracy</a>, where we <a href="/2018/07/24/bugs-or-pull-requests.html">reward</a> each merged pull request.</p>

<h2 id="3-blame-them-wisely">3. Blame Them Wisely</h2>

<p>This may be a defect in their existing codebase.
Pretty often it is.
Your code can’t merge, not because it’s broken, but because one of the existing tests is flaky.
This is tricky and it may get ugly.</p>

<p>Don’t get negative or frustrated.
You know that it’s not your fault.
But they don’t.
They believe that your code is defective and their code is perfect.
Moreover, all CI workflows are <a href="/2014/07/21/read-only-master-branch.html">green</a> on master, while your branch is red.
Who do we <a href="/2025/04/19/dont-merge-into-broken-master.html">blame</a>?
Obviously, you.</p>

<aside class="quote">They won’t listen if you blame them for the failure in your pull request.
</aside>

<p>You have to collect <em>enough evidence</em> and submit a bug report.
It should explain what’s wrong in their master branch.
Don’t ever mention your pull request.
It’s a trap!
If you try to use your pull request as a proof of their mistakes, they won’t listen.</p>

<p>Forget about your pull request for a while.
Submit a bug report as if you were a stranger who just found a <em>bug in master</em>.</p>

<p>It may be hard, since master is green.
However, there is no other way around it.
Again, they won’t listen if you blame them for the failure in your pull request.
At best, they will explain to you the basics of continuous integration.</p>

<h2 id="4-move-on">4. Move On</h2>

<p>Just as poker fish (immature players) try to win every hand, junior developers try to merge every pull request.
This is a mistake.
Some problems simply can’t be fixed and some features can’t be implemented right now.
There will be time for them later.</p>

<p>It’s perfectly all right to <em>close</em> a pull request after a negative review.
There’s no need to feel obliged to finish it.
It’s better to spend time on easier bugs to fix and simpler functionality to implement.</p>

<h2 id="5-dont-call-for-help">5. Don’t Call for Help</h2>

<p>No matter how hard it is, don’t ask them to help you.
“I can’t understand why it doesn’t merge!”
Don’t say this.</p>

<p>They <a href="/2015/02/16/it-is-not-a-school.html">may help</a>, but it will be annoying for them.
You won’t look like a reliable programmer.
The more you ask for help, the more you ruin your reputation.
You must know how to solve issues on your own.</p>

<p>A failed PR isn’t a setback.
It’s a <em>lesson</em>.
Fail fast, blame smart, and move on stronger.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="oss" /><category term="etiquette" /><summary type="html"><![CDATA[When your pull request won’t merge, don't fight it—fail fast, split your changes, file bugs, and move on smarter.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/11/amores-perros.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/11/amores-perros.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Programmers, Don’t Use Windows!</title><link href="https://www.yegor256.com/2025/10/05/windows-vs-macos.html" rel="alternate" type="text/html" title="Programmers, Don’t Use Windows!" /><published>2025-10-05T00:00:00+00:00</published><updated>2025-10-05T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/10/05/windows-vs-macos</id><content type="html" xml:base="https://www.yegor256.com/2025/10/05/windows-vs-macos.html"><![CDATA[<p>In 2020, in the <a href="/junior-objects.html">Junior Objects</a> book I wrote this:
  “<em>Windows is not suitable for programmers.
  If you meet anyone who will tell you otherwise, you must know that you deal with a bad programmer, or a poor one, which are the same things.
  Your computer has to be MacBook.</em>”
Now, five years later, I still hold the same opinion.
This blog post is supposed to be less opinionated and, because of this, more convincing.
The point is still the same: you either use Windows or you are a professional programmer.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="Das Experiment (2001) by Oliver Hirschbiegel" src="/images/2025/10/das-experiment.jpg" longdesc="#f88f9b9a" /><figcaption id="f88f9b9a">Das Experiment (2001) by Oliver Hirschbiegel</figcaption></figure>

<p>First things first.
This is what ChatGPT <a href="https://chatgpt.com/share/68e2770a-79d8-8007-96d1-3722d4d3cfcd">thinks</a> about macOS vs. Windows (I toned it down a bit and sorted by importance, keeping what matters most at the top):</p>

<ul>
  <li>It’s <a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a>-compliant</li>
  <li>Tools like <code class="language-plaintext highlighter-rouge">grep</code>, <code class="language-plaintext highlighter-rouge">awk</code>, <code class="language-plaintext highlighter-rouge">sed</code>, <code class="language-plaintext highlighter-rouge">ssh</code>, and <code class="language-plaintext highlighter-rouge">make</code> work natively</li>
  <li>Proper compiler toolchain: Clang, LLVM, make, <a href="https://git-scm.com/">git</a></li>
  <li>Install everything with <a href="https://brew.sh/">HomeBrew</a>, one command away</li>
  <li>Node, Python, Ruby, Go, Java—just work without PATH hell</li>
  <li>The <a href="https://iterm2.com/">iTerm2</a> doesn’t look like it was built in 1998</li>
  <li><a href="https://www.docker.com/">Docker</a> runs faster and cleaner than on Windows</li>
  <li>SSH keys integrate smoothly with the system keychain</li>
  <li><a href="https://git-scm.com/">Git</a> behaves predictably; no <a href="https://stackoverflow.com/questions/1552749/difference-between-cr-lf-lf-and-cr-line-break-types">CRLF vs LF nightmares</a></li>
</ul>

<p>I can hear you saying:
What do I need it to be POSIX-compliant, and what is POSIX?
Why do I need <code class="language-plaintext highlighter-rouge">grep</code>, <code class="language-plaintext highlighter-rouge">sed</code>, and <code class="language-plaintext highlighter-rouge">awk</code>?
Am I a 60 years old Unix admin?
Why would I ever need <code class="language-plaintext highlighter-rouge">git</code> and <code class="language-plaintext highlighter-rouge">make</code> in the command line?
I don’t use command line at all.
I stay in the <a href="https://code.visualstudio.com/">VS Code</a> that works like a charm and helps me make a living.</p>

<p>I hear you. I do.</p>

<p>Now, hear me out.
You are not a programmer.
You look like one.
You walk like one.
You click the same buttons programmers click.
You even make the same salary they make.
But you are not one of them.
Yet.
Now, read on.</p>

<h2 id="what-is-unix">What Is Unix?</h2>

<p>Programmers are the masters of computers.
They tell machines what to do.
To simplify the task of managing a complex hardware, programmers invented a few layers of abstractions.
The first layer is an operating system.
Instead of dealing with the hard drive and the pixels on the screen directly, programmers invented files and stdout.</p>

<p>They did it in the <a href="https://en.wikipedia.org/wiki/Bell_Labs">Bell Labs</a>, during the late 1960s and early 1970s.
Earlier operating systems, like <a href="https://en.wikipedia.org/wiki/Compatible_Time-Sharing_System">CTSS</a> and <a href="https://en.wikipedia.org/wiki/OS/360_and_successors">OS/360</a>, gave them a good start.
Unix was the first OS to say that <em>everything is a file</em>, including devices, directories, sockets, and processes.
They also invented <em>pipelines</em> and the philosophy: “Write programs that do one thing well, and work together.”
They also invented <em>processes</em> and their forking mechanism.</p>

<p>Their names were <a href="https://en.wikipedia.org/wiki/Ken_Thompson">Ken Thompson</a> and <a href="https://en.wikipedia.org/wiki/Dennis_Ritchie">Dennis Ritchie</a>.</p>

<h2 id="what-is-windows">What Is Windows?</h2>

<p>Five years later, another operating system was created, with different abstractions.
Not everything was a file anymore, processes were not parallel, and there were no pipelines.
The name of the system was <a href="https://en.wikipedia.org/wiki/CP/M">CP/M</a> and the name of the inventor was <a href="https://en.wikipedia.org/wiki/Gary_Kildall">Gary Kildall</a>.
Then, five years later, 24-year-old <a href="https://en.wikipedia.org/wiki/Tim_Paterson">Tim Paterson</a> has made a copy of CP/M and called it <a href="https://en.wikipedia.org/wiki/86-DOS">86-DOS</a>.
<a href="https://www.microsoft.com/">Microsoft</a> purchased a non-exclusive license, rebranded it <a href="https://en.wikipedia.org/wiki/MS-DOS">MS-DOS</a>, and sold it to IBM.
That’s how Windows was born, in 1981.</p>

<p>Why were there no proper files, no processes, and no pipelines?
Because they weren’t trying to build a “real” operating system.
CP/M and MS-DOS were designed for tiny, single-user, single-task microcomputers, not multi-user minicomputers or mainframes.
Unix came out of Bell Labs—researchers, not hobbyists.
CP/M and MS-DOS were made for personal computers: offices and home users.
In other words, <em>MS-DOS never meant to be a proper OS</em>.
It was something that can boot up a small machine and run a single program.</p>

<p>Then, in 1985, <a href="https://en.wikipedia.org/wiki/Windows_1.0">Windows 1.0</a> was built.
It was a fancy <a href="https://en.wikipedia.org/wiki/Graphical_user_interface">GUI</a> on top of MS-DOS, not a new OS.
Later, in 1995, Microsoft introduced 32-bit APIs (<a href="https://en.wikipedia.org/wiki/Windows_API">Win32</a>) and preemptive multitasking.
However, the DOS subsystem was still lurking underneath.
Windows 95 looked modern but was still a half-DOS zombie.</p>

<p>At the same time, in 1993, the team of <a href="https://en.wikipedia.org/wiki/Dave_Cutler">Dave Cutler</a> has built <a href="https://en.wikipedia.org/wiki/Windows_NT">Windows NT</a> that was not based on DOS at all.
Latest Windows versions are descendants of NT, not MS-DOS.
Under the hood it’s conceptually closer to Unix than to CP/M.
There are features like protected memory, kernel/user separation, and file handles.
However, still it’s not Unix.</p>

<h2 id="what-is-macos">What Is macOS?</h2>

<p>In 1984, <a href="https://www.apple.com/">Apple</a> shipped their first <a href="https://en.wikipedia.org/wiki/Macintosh_128K">Macintosh</a> with the “System 1” operating system.
It was no better than MS-DOS: no multitasking, no memory protection, and primitive file system.
No surprise, it didn’t fly.</p>

<p>In 1997, Apple bought <a href="https://en.wikipedia.org/wiki/NeXT">NeXT</a> and adopted <a href="https://en.wikipedia.org/wiki/NeXTSTEP">NeXTSTEP</a> operating system.
They made it the foundation for the new <a href="https://en.wikipedia.org/wiki/MacOS">Mac OS</a>—codenamed <a href="https://en.wikipedia.org/wiki/Rhapsody_(operating_system)">Rhapsody</a>, later “Mac OS X”.</p>

<p>In 2001 they shipped Mac OS X 10.0 (“<a href="https://en.wikipedia.org/wiki/Mac_OS_X_10.0">Cheetah</a>”).
Five years later I threw away my ThinkPad with Windows and bought my first MacBook with <a href="https://en.wikipedia.org/wiki/Mac_OS_X_Leopard">Mac OS X Leopard</a>.</p>

<p>Modern macOS (Catalina, Ventura, Sequoia, etc.) is still built on that NeXT foundation.
It is POSIX-compliant and, of course, it has processes and pipelines.
In other words, it is Unix with a pretty GUI.</p>

<h2 id="abstractions">Abstractions</h2>

<p>Both Windows and macOS, in their current versions, are solid operating systems.
The difference is in the abstractions inside them: files, sockets, processes, memory blocks, users, permissions, and so on.
In Unix (macOS), everything is a <em>file</em>, while in Windows, everything is an <em>object</em>.
Files in Unix are a uniform abstraction, that’s why they can be chained via pipes.
In Windows objects are not unified in practice, they have different interfaces.</p>

<p>This is why <a href="https://en.wikipedia.org/wiki/Unix_shell">Unix shells</a> and small composable tools became so powerful.
The uniformity of “everything is a file” made composition natural.
You can build complex workflows from simple programs.</p>

<p>Windows, on the other hand, evolved around GUI apps and message loops, not shell pipelines.</p>

<h2 id="pipelines">Pipelines</h2>

<p><a href="https://en.wikipedia.org/wiki/Unix">Unix</a> was built around pipelines.
In Unix, everything is a small tool reading stdin, writing stdout.
At the same time, everything is a file, including sockets, devices, and processes.
Programmers, in Unix, see every process as a <em>composition</em> of smaller processes, glued together via pipelines.
This mindset, since 1970s, has proven to be effective, amongst a few generations of software engineering elite.</p>

<p>Say, you want to know which parts of your codebase change the most—maybe for refactoring, testing focus, or bug-hotspot analysis.
This is how you do it Unix-style:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git log <span class="nt">--pretty</span><span class="o">=</span>format: <span class="nt">--name-only</span> | <span class="se">\</span>
  <span class="nb">grep</span> <span class="s1">'\.java$'</span> | <span class="se">\</span>
  <span class="nb">sort</span> | <span class="se">\</span>
  <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="se">\</span>
  <span class="nb">sort</span> <span class="nt">-nr</span> | <span class="se">\</span>
  <span class="nb">head</span> <span class="nt">-20</span>
</code></pre></div></div>

<p>Does this syntax make sense to you?
If it does, I bet you use <a href="https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux">WSL</a>.
Most serious Windows developers end up doing exactly that.</p>

<p>The command line is the bare metal interface to Unix.
The heart of the command line is pipelines.
Thanks to pipelines, command-line tools are inherently composable.
You can chain them and automate tasks in seconds that would take hours by hand.
No <a href="https://en.wikipedia.org/wiki/Integrated_development_environment">IDE</a> plugin can replace this power.</p>

<h2 id="what-are-you">What Are You?</h2>

<p>Now, you know what the difference is between Windows and macOS.
In both of them you can code, browse Internet, and watch movies.
However, in macOS you interact with the computer through Unix abstractions in a <a href="https://en.wikipedia.org/wiki/Unix_shell">shell</a>.
You don’t just use macOS—you inherit <em>fifty years of disciplined abstraction</em>.</p>

<p>In Windows you interact with the computer through draggable GUI elements.
A GUI makes you a consumer; a CLI makes you a creator.
A GUI hides the logic behind gestures and icons; a CLI exposes it as text you can reason about, automate, and combine.
You can’t pipe a button click into another program, you can’t grep a progress bar, and you can’t version-control a mouse movement.
Every click you make dies the moment you make it; every command you write can live forever.</p>

<p>Oh, wait.
In macOS you can’t really play games.
Bummer…
Maybe you shouldn’t, since you are a programmer?</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="mood" /><summary type="html"><![CDATA[Windows turns programmers into mouse operators. macOS, built on Unix, keeps the command line alive—where everything is a file, tools connect through pipelines, and real programmers stay in control.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/10/das-experiment.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/10/das-experiment.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Red vs. Black</title><link href="https://www.yegor256.com/2025/09/14/red-and-black.html" rel="alternate" type="text/html" title="Red vs. Black" /><published>2025-09-14T00:00:00+00:00</published><updated>2025-09-14T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/09/14/red-and-black</id><content type="html" xml:base="https://www.yegor256.com/2025/09/14/red-and-black.html"><![CDATA[<p>In Soviet Russia, prisoner camps were divided into two categories: red and black.
In a red camp, the power belonged to the prisoners who cooperated with the administration and helped it maintain discipline.
In a black one, the power was in the hands of criminals who resented the rules, in permanent confrontation with the administration.
It seems that in software companies we may also categorize employees into red and black.
A <strong>red employee</strong> enjoys obeying the rules and climbs up the career ladder by <a href="/2015/01/26/happy-boss-false-objective.html">making the boss happy</a>.
To the contrary, a <strong>black employee</strong>, while understanding the inevitability, despises the necessity to obey.
Their career growth is driven by <a href="/2015/02/23/haircut.html">making the customer happy</a>.
Which one are you?</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="Холодное лето пятьдесят третьего (1987) by Александр Прошкин" src="/images/2025/09/cold-summer-1953.jpg" longdesc="#ded7ba65" /><figcaption id="ded7ba65">Холодное лето пятьдесят третьего (1987) by Александр Прошкин</figcaption></figure>

<p>An organization cannot exist without policies and regulations.
Especially if it’s a large organization where the percentage of underperformers is highest.
The clock-watchers must be disciplined so that they produce at least something.
Let’s assume you are not one of them.</p>

<p>However, even if you are not a nine-to-five clock-watcher, you can’t ignore the policies.
A few examples of the rules you may need to obey:</p>

<ul>
  <li>All reports must follow the official PowerPoint template</li>
  <li>Every meeting requires written minutes sent to all participants</li>
  <li>Job candidates must pass through the full HR pipeline</li>
  <li>Employees must re-certify their skills on a fixed schedule</li>
</ul>

<p>All of the above seem reasonable—just like prison rules.
The difference is your attitude toward them.</p>

<p>They are either a <strong>framework</strong> for your career or an inevitable <strong>evil</strong>.
You either feel happy when you do what’s required, or feel annoyed and do it just because it’s required.
You either fill out all the forms completely, or you cut every possible corner to get back to the real work.
You either read an email copied to 25 people to not miss anything or immediately delete it.
You either attend all meetings or learn to be creative in finding reasons why you can’t.</p>

<p>You are either red or black.
Once you find your <strong>identity</strong>, you start despising the other side.</p>

<aside class="quote">Minimize contact, keep your head down when necessary, and focus on delivering real value where it matters.
</aside>

<p>If you are red, you don’t understand the black employees who are constantly rebelling.
They rebel against the rules you so much enjoy following.
You see them as dishonest, disloyal, and selfish sociopaths.</p>

<p>If you are black, you despise the red employees who are trying so hard to associate themselves with the system.
They study the rules and compete against each other—who knows them better.
You see them as <a href="/2017/08/22/to-be-nice-or-not.html">shallow</a> and incompetent <a href="/2021/03/03/imposters-to-win.html">impostors</a>.</p>

<p>Peace is not possible.
In any large organization, reds will always dominate—it’s inevitable.
The system needs them, and they thrive inside it.
Blacks will always be a minority, surviving at the edges.</p>

<p>If you are black, don’t waste energy trying to convert or fight the reds.
You won’t win.
The only strategy is distance.
Minimize contact, keep your head down when necessary, and focus on delivering real value where it matters.
Reds will spend their lives climbing the corporate ladder.
Blacks must learn to survive in the shadows of that ladder, working for the customer, not the boss.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="management" /><category term="mood" /><summary type="html"><![CDATA[In big organizations, reds obey bosses while blacks serve customers—and blacks survive only by keeping their distance.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/09/cold-summer-1953.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/09/cold-summer-1953.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">The End of Type Annotations</title><link href="https://www.yegor256.com/2025/08/17/type-annotations.html" rel="alternate" type="text/html" title="The End of Type Annotations" /><published>2025-08-17T00:00:00+00:00</published><updated>2025-08-17T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/08/17/type-annotations</id><content type="html" xml:base="https://www.yegor256.com/2025/08/17/type-annotations.html"><![CDATA[<p>Type annotations are what make statically typed object-oriented languages like Java run <strong>faster</strong> and <strong>safer</strong>.
Without annotations, every variable would effectively collapse to <code class="language-plaintext highlighter-rouge">Object</code>, forcing runtime casts.
The code would work, but slower and with more runtime errors.
Some type annotations may be inferred instead of being explicitly specified by a programmer.
Not all though.
In Java, for example, a number of hard-to-resolve challenges prevent us from inferring types of all objects.
This is not a fundamental limitation of OOP itself.
It’s a result of design trade-offs in Java and similar languages.
In a perfect object-oriented language, all variable types would be inferrable.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="Swingers (1996) by Doug Liman" src="/images/2025/08/swingers.jpg" longdesc="#4225221a" /><figcaption id="4225221a">Swingers (1996) by Doug Liman</figcaption></figure>

<p>Imagine a simple Java method:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Price priceOfDelivery(Book book, City city) {
  Price price = book.price();
  Delivery delivery = new Delivery(price, city);
  return delivery.price();
}
</code></pre></div></div>

<p>Two reasons justify the usage of <code class="language-plaintext highlighter-rouge">Book</code>, <code class="language-plaintext highlighter-rouge">City</code>, <code class="language-plaintext highlighter-rouge">Price</code>, and <code class="language-plaintext highlighter-rouge">Delivery</code> type annotations:
Compilers and programmers need help.</p>

<h2 id="type-annotations-are-helpful">Type Annotations Are Helpful</h2>

<p>First, we help the compiler eliminate some <strong>dynamic dispatches</strong> in favor of static calls.
If the <code class="language-plaintext highlighter-rouge">Book</code> is a class, not an interface, the <code class="language-plaintext highlighter-rouge">book.price()</code> call may be compiled into a jump to an absolute address.
Without information about the <code class="language-plaintext highlighter-rouge">book</code>’s class, <code class="language-plaintext highlighter-rouge">.price()</code> goes to a virtual table first, finds the address, and only then jumps.
The second scenario is more expensive.
The type annotation attached to <code class="language-plaintext highlighter-rouge">book</code> helps avoid it.</p>

<p>Second, we help ourselves write safe code, avoiding “Method not found” <strong>runtime errors</strong>.
If <code class="language-plaintext highlighter-rouge">book</code> is not annotated as <code class="language-plaintext highlighter-rouge">Book</code>, we may mistakenly pass <code class="language-plaintext highlighter-rouge">Integer</code>, meaning the book’s ID in the database.
At compile time, that would lead to no errors.
Later, at runtime, we get an error when <code class="language-plaintext highlighter-rouge">.price()</code> is not found in the virtual table of the <code class="language-plaintext highlighter-rouge">Integer</code> class.</p>

<p>However, both compilers and programmers can improve.</p>

<h2 id="compilers-can-do-better">Compilers Can Do Better</h2>

<p>Sometimes, a compiler can infer the type of a variable, without an explicit annotation.
For example, this code compiles in Java, starting from version 10:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Price priceOfDelivery(Book book, City city) {
  var price = book.price();
  var delivery = new Delivery(price, city);
  return delivery.price();
}
</code></pre></div></div>

<p>The type annotation used in earlier Java versions is replaced with the <code class="language-plaintext highlighter-rouge">var</code> keyword.</p>

<p>In a small piece of code such as this one, the compiler can <strong>infer</strong> types.
However, it may fall short with the <code class="language-plaintext highlighter-rouge">book</code> and <code class="language-plaintext highlighter-rouge">city</code> parameters.
In the general case, type inference is not decidable for Java programs.
Because of generics, method overloading, reflection, and … complexity.</p>

<p>The complexity is the technical obstacle.
The compiler can’t infer types for all variables because it would be too expensive to analyze the whole program.
Instead, it compiles file by file.
Even if the compiler had the whole program, inference in Java would still hit undecidability in the general case.
File-by-file compilation makes this even more restrictive.</p>

<p>All other barriers, such as generics, the compiler can’t overcome:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void print(List&lt;?&gt; items) {
  var x = items.get(0); // What is the type?
}
</code></pre></div></div>

<p>No matter how hard the compiler tries, in the general case, this question doesn’t have an answer.</p>

<h2 id="programmers-can-do-better">Programmers Can Do Better</h2>

<p>We, programmers, can help the compiler infer types.</p>

<p>For example, we can stop using generics.
Instead of <code class="language-plaintext highlighter-rouge">List&lt;Book&gt;</code> we can have a <code class="language-plaintext highlighter-rouge">Library</code> and instead of <code class="language-plaintext highlighter-rouge">Map&lt;User, Phone&gt;</code> we can have a <code class="language-plaintext highlighter-rouge">PhoneBook</code>.
It’s easier to infer the type of the object taken from a <code class="language-plaintext highlighter-rouge">Library</code> versus the object taken from a generic <code class="language-plaintext highlighter-rouge">List</code>.</p>

<p>We can also stop using method overloading.
Instead of <code class="language-plaintext highlighter-rouge">print(String x)</code> and <code class="language-plaintext highlighter-rouge">print(Integer x)</code> we can create <code class="language-plaintext highlighter-rouge">printString(x)</code> and <code class="language-plaintext highlighter-rouge">printInteger(x)</code>.
Types of parameters are easier to infer in more specialized methods.</p>

<p>We can also stop using reflection.</p>

<aside class="quote">The easier it is to infer the type of a variable for a compiler, the faster the programmer gets the semantics of it too.
</aside>

<p>Java programmers may not be ready for such a <strong>radical move</strong>.
However, if they were, they would not only help the compiler but themselves too.
Eliminating type annotations makes code shorter and, because of that, cleaner.
This is why <code class="language-plaintext highlighter-rouge">var</code> syntax was introduced in Java 10.</p>

<p>In the code above, variable names are nouns.
In well-written code, nouns as names are <a href="/2015/01/12/compound-name-is-code-smell.html">sufficient</a> to disambiguate variables.
No need to call it <code class="language-plaintext highlighter-rouge">cityOfDelivery</code> or <code class="language-plaintext highlighter-rouge">bookToDeliver</code>.
Just <code class="language-plaintext highlighter-rouge">book</code> and <code class="language-plaintext highlighter-rouge">city</code> are enough.</p>

<p>We also named variables by their types: a <code class="language-plaintext highlighter-rouge">book</code> is of type <code class="language-plaintext highlighter-rouge">Book</code>, and so on.
By looking at the name of the variable we can tell its type.
The <code class="language-plaintext highlighter-rouge">Book</code> type annotation looks like a syntactical redundancy.
It only leads to lower code readability, by making it longer.
It’s reasonable to expect type inference to free our programs from this redundancy.</p>

<p>Thus, better type inference means better <strong>readability</strong> of the code.</p>

<h2 id="languages-can-do-better">Languages Can Do Better</h2>

<p>Languages like Haskell and the ML family prove that full type inference is achievable.
However, they still need annotations for edge cases.
Rust takes a middle ground.
It infers local variable types but enforces explicit annotations at public interfaces.
Go, until recently, avoided generics, operator overloading, and heavy reflection, making inference straightforward.
However, it forces programmers to annotate all public boundaries—function signatures, struct fields, and interfaces.</p>

<aside class="quote">If the type of a variable can’t be inferred, compilation fails.
</aside>

<p>I suggest taking one step forward and designing a language that doesn’t have any type annotations.
Such a language should not have generics, method overloading, reflection, and everything else that prevents 100% type inference.
Then, we must design a compiler for this language that compiles the entire program, not single files.</p>

<p>The language may be as strict as this:
If the type of a variable can’t be inferred, compilation fails.</p>

<p>This is how the book price snippet would look in such a language:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>priceOfDelivery(book, city) {
  p = book.price();
  d = new Delivery(p, city);
  return d.price();
}
</code></pre></div></div>

<p>To me, this seems to be much more readable than the original code in Java.</p>

<p>Compilation time remains a limitation though.
We turn this issue into an opportunity.
Programmers are forced, by the timing limitations of the compiler, to write smaller modules.
When they need larger programs, they break them into modules that communicate via <a href="https://en.wikipedia.org/wiki/Inter-process_communication">IPC</a> instead of staying in a monolithic binary.</p>

<p>We’re experimenting with this approach in <a href="https://www.eolang.org">EOLANG</a>, a language designed to maximize inference by eliminating features that make it undecidable.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="oop" /><summary type="html"><![CDATA[Type annotations are a workaround for compiler limitations, not a feature—a well-designed language should infer all types automatically, forcing programmers to write smaller, cleaner modules.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/08/swingers.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/08/swingers.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">remove(42) vs. find(42).remove()</title><link href="https://www.yegor256.com/2025/06/22/retrieve-or-remove.html" rel="alternate" type="text/html" title="remove(42) vs. find(42).remove()" /><published>2025-06-22T00:00:00+00:00</published><updated>2025-06-22T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/06/22/retrieve-or-remove</id><content type="html" xml:base="https://www.yegor256.com/2025/06/22/retrieve-or-remove.html"><![CDATA[<p>We have a list of books in the <code class="language-plaintext highlighter-rouge">books</code> object.
How do we remove a single book from it, given that we know its ID?
We can do <code class="language-plaintext highlighter-rouge">books.removeById(42)</code>.
Alternatively, we can find it with <code class="language-plaintext highlighter-rouge">books.findById(42)</code> and then call <code class="language-plaintext highlighter-rouge">b.remove()</code>.
Which option should we prefer, and why?
The second choice is the better one.
Not only because it’s more object-oriented, but also due to several practical advantages.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="8 Femmes (2002) by François Ozon" src="/images/2025/06/8-femmes.jpg" longdesc="#d7e21337" /><figcaption id="d7e21337">8 Femmes (2002) by François Ozon</figcaption></figure>

<h2 id="extending-the-deletion-behavior">Extending the Deletion Behavior</h2>

<p>What if we want to extend the deletion algorithm?
For example, suppose we want to print a log message every time a book is deleted.</p>

<p>If we follow the <a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">open-closed principle</a>, we should avoid modifying the existing <code class="language-plaintext highlighter-rouge">Book</code> or <code class="language-plaintext highlighter-rouge">Books</code> classes.
Instead, we want to either <a href="/2016/09/13/inheritance-is-procedural.html">extend</a> or <a href="/2015/02/26/composable-decorators.html">decorate</a> them.
A decorator is the ideal choice if we want to avoid <a href="/2016/09/13/inheritance-is-procedural.html">implementation inheritance</a>.</p>

<p>If we use <code class="language-plaintext highlighter-rouge">removeById()</code>, we must decorate the <code class="language-plaintext highlighter-rouge">books</code> object.
If we use <code class="language-plaintext highlighter-rouge">remove()</code>, we can decorate the individual book retrieved via <code class="language-plaintext highlighter-rouge">findById()</code>.
The latter approach may be more <strong>cohesive</strong>, since its decoratee is likely <strong>smaller</strong> and more <strong>focused</strong>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="nf">findById</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="no">Logged</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">b</span><span class="p">.</span><span class="nf">remove!</span>
</code></pre></div></div>

<h2 id="handling-missing-or-non-deletable-books">Handling Missing or Non-Deletable Books</h2>

<p>What if the book isn’t found, or can’t be deleted?
The <code class="language-plaintext highlighter-rouge">removeById()</code> approach doesn’t support the <a href="https://en.wikipedia.org/wiki/Null_object_pattern">Null Object</a> pattern well.
It forces us to throw an exception—or worse, return <code class="language-plaintext highlighter-rouge">false</code>, which goes <a href="/2018/08/22/builders-and-manipulators.html">against</a> the <a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation">CQS</a> principle.</p>

<p>On the other hand, returning an object, even a <a href="https://en.wikipedia.org/wiki/Null_object_pattern">null</a> or <a href="/2014/09/23/built-in-fake-objects.html">fake</a> object, offers more <strong>flexible error handling</strong>.
For instance, we can access <code class="language-plaintext highlighter-rouge">title()</code> safely, knowing that the book was found successfully—or catch and <a href="https://en.wikipedia.org/wiki/Exception_chaining">re-raise exceptions</a> with <a href="/2015/12/01/rethrow-exceptions.html">more context</a>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="nf">findById</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="k">begin</span>
  <span class="n">b</span><span class="p">.</span><span class="nf">remove!</span>
<span class="k">rescue</span> <span class="n">e</span>
  <span class="k">raise</span> <span class="n">e</span><span class="p">,</span> <span class="s2">"Can't delete book </span><span class="si">#{</span><span class="n">b</span><span class="p">.</span><span class="nf">title</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="decoupling-retrieval-and-deletion">Decoupling Retrieval and Deletion</h2>

<p>What if the retrieval and deletion of the object happen far apart in the code?</p>

<p>If <code class="language-plaintext highlighter-rouge">books</code> knows how to find, and a <code class="language-plaintext highlighter-rouge">book</code> knows how to delete, we keep responsibilities nicely separated.
It also allows the book to be immutable and encapsulate its own ID, reducing <a href="/2016/11/21/naked-data.html">leakage</a> of internal data:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="nf">findById</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="c1"># +100 lines here...</span>
<span class="n">b</span><span class="p">.</span><span class="nf">remove!</span>  <span class="c1"># DELETE FROM book WHERE id = 42</span>
<span class="c1"># +200 lines here...</span>
<span class="k">if</span> <span class="n">b</span><span class="p">.</span><span class="nf">exists?</span>  <span class="c1"># SELECT * FROM book WHERE id = 42</span>
  <span class="nb">puts</span> <span class="s2">"The book is back to the library!"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Once the ID is wrapped inside the book by <code class="language-plaintext highlighter-rouge">findById()</code>, it never has to <strong>leak out</strong> again.
This reduces the amount of <a href="/2016/11/21/naked-data.html">naked data</a> exposed to parts of the code that don’t need it.</p>

<p>The less data is visible, the <a href="/2016/11/21/naked-data.html">better</a> the design—at least from an OOP perspective.</p>

<p>Thus, using <code class="language-plaintext highlighter-rouge">findById()</code> followed by <code class="language-plaintext highlighter-rouge">remove()</code> embraces object-oriented principles more fully.
It allows for cleaner extension, better error handling, and tighter encapsulation.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="oop" /><summary type="html"><![CDATA[Delegating behavior to objects rather than invoking utility methods leads to cleaner, more extensible, and properly encapsulated object-oriented design.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/06/8-femmes.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/06/8-femmes.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Write Unit Tests, Don’t Waste Our Money!</title><link href="https://www.yegor256.com/2025/06/08/pull-request-without-test.html" rel="alternate" type="text/html" title="Write Unit Tests, Don’t Waste Our Money!" /><published>2025-06-08T00:00:00+00:00</published><updated>2025-06-08T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/06/08/pull-request-without-test</id><content type="html" xml:base="https://www.yegor256.com/2025/06/08/pull-request-without-test.html"><![CDATA[<p>Automated tests help us write code <a href="/angry-tests.html">faster</a>.
Unit tests immediately <a href="/2022/07/05/safety-net.html">tell us</a> when we break something.
Integration tests calm us down, reducing the fear of shipping a failure to a user.
But who are “us”?
Programmers.
What about our employers?
How do automated tests help them?
Automated tests protect their <strong>investments</strong>.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="La Femme Nikita (1990) by Luc Besson" src="/images/2025/06/la-femme-nikita.jpg" longdesc="#ccb58518" /><figcaption id="ccb58518">La Femme Nikita (1990) by Luc Besson</figcaption></figure>

<p>Every change we make to a codebase costs our employer money.
Whether they pay us <a href="/2015/07/21/hourly-pay-modern-slavery.html">monthly</a>
  or <a href="/2014/04/11/cost-of-loc.html">per line of code</a>, the bottom line is the same:
  it’s the code that reaches the repository and is eventually released to the end user.</p>

<p>That’s what the business is investing in—new features <a href="/2018/07/24/bugs-or-pull-requests.html">or</a> bug fixes.
The code that’s written and shipped is what matters to them.</p>

<p>Even when they say they’re investing in people, what they really want is the code.
People are merely an intermediate by-product.
The ultimate asset is the codebase.</p>

<p>They want to <strong>protect</strong> that <strong>asset</strong>.</p>

<p>A loss of investment could be a hundred lines written today not working tomorrow.
Think about it this way: we expect a car to work after paying the body shop to fix it.
We don’t mind paying again if something else breaks—but not if it’s the exact same part they fixed yesterday.
We expect the repaired part to function properly while driving.
We want a warranty on what’s already been fixed.</p>

<aside class="quote">People are merely an intermediate by-product—the ultimate asset is the codebase.
</aside>

<p>Similarly, our employers expect our code to work once we’ve committed it and collected our paycheck.
They want a warranty that the code won’t break again once it’s been fixed.
Automated tests can offer that <strong>warranty</strong>.</p>

<p>Continuing the metaphor: “driving” a codebase means actively modifying its parts—refactoring or extending.
The more aggressively we drive it, the higher the risk of breaking something.
The parts of the code not covered by tests are the first to break.</p>

<p>Test coverage guarantees that what worked before—and was already paid for—continues to work even under the stress of refactoring.</p>

<p>So, any contribution to a codebase without a <strong>supporting</strong> test is a waste of the employer’s money.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="etiquette" /><category term="testing" /><summary type="html"><![CDATA[If you write code without tests, you're probably wasting your employer's money---because it'll break again right where you "fixed" it.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/06/la-femme-nikita.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/06/la-femme-nikita.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>