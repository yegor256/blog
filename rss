<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://www.yegor256.com/rss.xml" rel="self" type="application/atom+xml" /><link href="https://www.yegor256.com/" rel="alternate" type="text/html" /><updated>2025-12-15T01:26:21+00:00</updated><id>https://www.yegor256.com/rss.xml</id><title type="html">Yegor Bugayenko</title><subtitle>Yegor Bugayenko</subtitle><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><entry><title type="html">You Are the Low-Hanging Fruit</title><link href="https://www.yegor256.com/2025/11/30/internal-vs-external-obstacles.html" rel="alternate" type="text/html" title="You Are the Low-Hanging Fruit" /><published>2025-11-30T00:00:00+00:00</published><updated>2025-11-30T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/11/30/internal-vs-external-obstacles</id><content type="html" xml:base="https://www.yegor256.com/2025/11/30/internal-vs-external-obstacles.html"><![CDATA[<p>Let’s say, you are a startup founder, like <a href="https://www.zerocracy.com">myself</a>.
Try to hire a sales guy.
Offer him a commission-only payment scheme.
Listen to his reaction: he will demand that you pay a fixed salary too, on top of commission.
Try to convince him that commission-only is a more reasonable and <a href="/2014/09/24/why-monetary-awards-dont-work.html">motivating</a> setup.
Goto 1.
After a number of iterations you realize that the mission is impossible.
Sales people are good at selling and the best thing they sell is the idea that their <em>time</em> must be compensated.
Even if they don’t sell the product to your customers.
If you don’t buy the idea, they go find another loser who will.
Something similar happens when you try to pay programmers by result.
They easily convince you to pay for <a href="/2015/07/21/hourly-pay-modern-slavery.html">their time</a>.
And you do.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="City of God (2002) by Kátia Lund" src="/images/2025/11/city-of-god.jpg" longdesc="#1e31b0ff" /><figcaption id="1e31b0ff">City of God (2002) by Kátia Lund</figcaption></figure>

<p>A sales rep doesn’t know how to write code.
Most of them don’t even know how computers work.
However, he <em>perfectly</em> knows how to bullshit people.
That’s exactly why we need him.
Because we don’t know how to bullshit people and we don’t want to learn it.</p>

<p>Now, two strategies lie in front of him.
He can use the skill against the prospects on the market and turn them into paying customers.
He can also use the same selling skill against you, the owner of the startup.
Instead of selling the product to the market he can sell <em>himself</em> to you.
He can sell the idea that even if he fails to sell the product to the customers he still deserves a decent weekly paycheck.</p>

<p>What do you think, which sale is easier to make?
What would you do in his shoes?
The answer is obvious.
The customers are far away and they have no mercy.
If they don’t like the offer, they simply hang up on him and that’s it.
You, on the other hand, sit next to him in the same office and can’t hang up.
You are the <em>low-hanging fruit</em>.
You are the <em>weakest</em> prey he can reach out to.</p>

<aside class="quote">In order to make him focus on external obstacles, you should make internal ones harder to overcome.
</aside>

<p>A customer is an <em>external</em> obstacle that he must overcome in order to get paid, as a sales commission.
You are an <em>internal</em> obstacle, which he may also overcome to get a fixed weekly payment.
You need him to fight the external obstacle.
However, he is free to choose the <em>easiest</em> path.</p>

<p>In order to make him focus on external obstacles, you should make internal ones <em>harder</em> to overcome.
Joseph Stalin once <a href="https://www.goodreads.com/quotes/338750-in-the-soviet-army-it-takes-more-courage-to-retreat">said</a> that “in the Soviet army it takes more courage to retreat than advance.”
This war-time concept seems relevant to the sales guys you hire.
It must be harder for them to talk you into paying them a fixed salary than to convince a prospect to buy your product.</p>

<p>Emotionally, for you it may be rather challenging to constantly push him back.
Just like it’s often hard to say “No” to a vagrant begging for a dollar at the corner.
Beggars, unless they are physically disabled, also, just like sales people, have two possible life strategies.
Either find a job or beg at the corner.
The begging strategy, for the vagrant and for the sales rep, is <em>easier</em> to pursue.</p>

<p>Programmers are not much different.
They also have two strategies.
They can solve technical problems by merging qualified pull requests.
They can also persuade you that you must pay for their time, not their pull requests.
Which obstacle is going to be harder for them to overcome depends on <em>you</em>.</p>

<p>First, you set up a formula for measuring their contribution.
Second, you bind their paychecks to it: they get paid <a href="/2016/05/24/who-is-project-manager.html">not by you</a>,
  but by <em>merged pull requests</em>.
Finally, you taboo the very possibility of discussing time-based compensation.</p>

<aside class="quote">Taboo the very possibility of discussing time-based compensation.
</aside>

<p>What you get is a technical team focused on resolving external problems.
The team will <em>advance</em> because it will be <a href="/2018/07/24/bugs-or-pull-requests.html">pointless</a> to <em>retreat</em>.
You simply <a href="/2015/07/21/hourly-pay-modern-slavery.html">won’t pay</a> them for their time.
No matter how many times they repeat “I was working hard the entire weekend.”</p>

<p>Incentives shape behavior.
If you reward excuses, you buy excuses.
If you reward results, you get results.
As a founder, your job is to eliminate the temptation for your team to <a href="/2019/07/10/inversive-management.html">sell you</a>
  anything other than tangible artifacts.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="management" /><summary type="html"><![CDATA[Sales reps and programmers can either fight external obstacles to earn their pay, or convince you, the founder, to pay for their time regardless of results; make the internal path harder.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/11/city-of-god.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/11/city-of-god.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Small Repo, High Quality</title><link href="https://www.yegor256.com/2025/11/16/smaller-repository-higher-quality.html" rel="alternate" type="text/html" title="Small Repo, High Quality" /><published>2025-11-16T00:00:00+00:00</published><updated>2025-11-16T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/11/16/smaller-repository-higher-quality</id><content type="html" xml:base="https://www.yegor256.com/2025/11/16/smaller-repository-higher-quality.html"><![CDATA[<p>I don’t like <a href="/2018/09/05/monolithic-repositories.html">monolithic repositories</a>.
They keep multiple projects together, often written in different languages, by different teams.
Unfortunately, <a href="https://dl.acm.org/doi/pdf/10.1145/2854146">Google</a>, <a href="https://engineering.fb.com/2025/10/16/developer-tools/branching-in-a-sapling-monorepo/">Facebook</a>, and <a href="https://shiftmag.dev/mono-repo-infrastructure-yandex-1011/">Yandex</a> favor them.
Primarily, according to them, <a href="https://monorepo.tools/">monorepos</a> reduce integration <a href="https://www.sonarsource.com/resources/library/monorepo/">overhead</a>.
They do, but at the cost of quality.
In smaller repositories we can develop better code.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="Морфий (2008) by Алексей Балабанов" src="/images/2025/11/morphine.jpg" longdesc="#04b3173e" /><figcaption id="04b3173e">Морфий (2008) by Алексей Балабанов</figcaption></figure>

<p>When a repository is smaller you can achieve higher quality, for a number of reasons:</p>

<ul>
  <li>
    <p><strong>You can be stricter on style.</strong>
It’s easier to keep a thousand lines consistently formatted than a million.
With a thousand lines, you can configure <a href="https://eslint.org/">ESLint</a> to its maximum, enabling as many rules as you can find.
Stricter <a href="/2014/08/13/strict-code-quality-control.html">control</a> over code stylistics leads to cleaner code.</p>
  </li>
  <li>
    <p><strong>You can write deeper tests.</strong>
Integration (or <a href="/2023/08/22/fast-vs-deep-testing.html">deep</a>) tests are inevitably slow.
In a smaller repository, a good integration test coverage doesn’t mean a slow build.
In a larger repository—it does.
A slow build is something a team tries to avoid, thus jeopardizing the coverage.</p>
  </li>
  <li>
    <p><strong>You can review more pedantically.</strong>
In a larger repository it may be harder to remember all the aspects of design.
A pull request that affects different seemingly unrelated code parts
may be a challenge to <a href="/2015/02/09/serious-code-reviewer.html">review</a>.
Even if you are the <a href="/2014/10/12/who-is-software-architect.html">architect</a>.</p>
  </li>
  <li>
    <p><strong>You can write a README.</strong>
Maybe you have noticed already: large open source projects have short and sketchy <a href="/2019/04/23/elegant-readme.html">README</a> files.
They can’t make them much longer without them becoming as large as a book.
All they can do is redirect the reader to the documentation website.
The inability to explain the entire scope in a single file leads to scope creep.
Contributors struggle to understand the borders of the project.
This leads, among other bad things, to code duplication.</p>
  </li>
  <li>
    <p><strong>You can release frequently.</strong>
In a larger repository, frequent reintegration may be expensive, in both time and money.
In a small repo, a <a href="/2025/04/12/four-builds.html">build</a> of a few seconds is not a dream of programmers, it’s their reality.
Not only CI is cheap, but also CD.
After every small change you can publish a new release, with its own <a href="https://semver.org/">version</a>.
In a monorepo, we tend to wait until a portion of changes accumulate.</p>
  </li>
  <li>
    <p><strong>You can use AI agents effectively.</strong>
It is no secret that modern LLMs have limited <a href="https://docs.claude.com/en/docs/build-with-claude/context-windows">context windows</a>.
A million lines of code can’t fit into even the largest of them.
Even ten thousand lines, let alone a million, is more than an LLM can digest.
By keeping a repository small we do a big favor to our little friends: AI agents.</p>
  </li>
  <li>
    <p><strong>You can on-board faster.</strong>
Larger codebases are usually older and more <a href="/2018/09/12/clear-code.html">chaotic</a>, full of legacy code.
It takes longer to start making meaningful contribution to such a repository.
Monorepos attract
<a href="/2015/12/29/turnover-is-good-for-maintainability.html">long-term</a>
<a href="/2017/05/02/remote-slaves.html">office-based</a>
contributors
who care about job security more than about code quality.</p>
  </li>
  <li>
    <p><strong>You can expect responsibility.</strong>
In larger codebases, the very idea of code ownership is hard to maintain.
Programmers can hardly feel responsible for the code written and modified by others.
Smaller repositories, on the other hand, emotionally attach people to code.</p>
  </li>
  <li>
    <p><strong>You can go open source.</strong>
No matter how much your boss <a href="/2020/05/05/open-source-arms-race.html">loves</a>
open source, you can’t put your entire enterprise monorepo on GitHub.
However, if you extract a small part of it, you can.
The code that is open, visible and criticized by many people,
is <a href="/2015/12/22/why-dont-you-contribute-to-open-source.html">allegedly</a> of a higher quality.</p>
  </li>
</ul>

<p>In summary, you should look for an opportunity to extract a piece of code as a standalone package.
Then, insist on making it <a href="/2017/05/30/why-contribute-to-open-source.html">open source</a>.
Then, promote it in the community.
Then, quit your office job and join <a href="https://www.zerocracy.com">Zerocracy</a>.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="oss" /><summary type="html"><![CDATA[By breaking your software into small open-source packages, you make the entire product easier to maintain—and significantly higher in quality.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/11/morphine.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/11/morphine.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Can’t Merge? Don’t Despair.</title><link href="https://www.yegor256.com/2025/11/09/help-me-cant-merge.html" rel="alternate" type="text/html" title="Can’t Merge? Don’t Despair." /><published>2025-11-09T00:00:00+00:00</published><updated>2025-11-09T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/11/09/help-me-cant-merge</id><content type="html" xml:base="https://www.yegor256.com/2025/11/09/help-me-cant-merge.html"><![CDATA[<p>You’ve made a pull request, but it won’t merge.
A reviewer says it’s not good or the tests don’t pass.
No matter what, you can’t get it into the master branch.
You keep fixing the branch, keep convincing the reviewer, keep hating the tests.
Stop.
Try <em>smarter</em> tactics.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="Amores Perros (2000) by Alejandro González Iñárritu" src="/images/2025/11/amores-perros.jpg" longdesc="#d0b0373b" /><figcaption id="d0b0373b">Amores Perros (2000) by Alejandro González Iñárritu</figcaption></figure>

<h2 id="1-give-up-instantly">1. Give Up Instantly</h2>

<p>First, <a href="https://en.wikipedia.org/wiki/Fail_fast">fail fast</a>.
Give up quickly.
If it doesn’t go through smoothly, <em>close it</em>.
If the reviewers’ complaints are more than stylistic issues, your understanding of the architecture is flawed.</p>

<p>Ask yourself, how did this happen?
Why did you, a smart programmer, get a wrong understanding of the architecture?
Obviously, it’s <a href="/2015/02/16/it-is-not-a-school.html">not your mistake</a>.
It’s a bug in the repository.
Its <a href="/2019/04/23/elegant-readme.html">README</a> isn’t complete, its code isn’t clean enough, its documentation is outdated.</p>

<p>What do you do?
You <a href="/2025/05/25/bug-driven-development.html">blame</a> them by submitting <a href="/2014/04/13/bugs-are-welcome.html">bug reports</a>.
Then, when they fix the repository, you try again, with a new pull request.</p>

<h2 id="2-take-a-smaller-bite">2. Take a Smaller Bite</h2>

<p>Most likely they don’t complain about all the changes you’ve made.
Something looks good to them, while they refuse to accept something else.
Good, remove the bad parts from your pull request.</p>

<p>Don’t waste time trying to sell the entire package in one go.
Instead, give them as much as they’re <em>ready to accept</em>.
In the end, you will merge a few pull requests instead of one.
The more, the better, at least for us in <a href="https://www.zerocracy.com">Zerocracy</a>, where we <a href="/2018/07/24/bugs-or-pull-requests.html">reward</a> each merged pull request.</p>

<h2 id="3-blame-them-wisely">3. Blame Them Wisely</h2>

<p>This may be a defect in their existing codebase.
Pretty often it is.
Your code can’t merge, not because it’s broken, but because one of the existing tests is flaky.
This is tricky and it may get ugly.</p>

<p>Don’t get negative or frustrated.
You know that it’s not your fault.
But they don’t.
They believe that your code is defective and their code is perfect.
Moreover, all CI workflows are <a href="/2014/07/21/read-only-master-branch.html">green</a> on master, while your branch is red.
Who do we <a href="/2025/04/19/dont-merge-into-broken-master.html">blame</a>?
Obviously, you.</p>

<aside class="quote">They won’t listen if you blame them for the failure in your pull request.
</aside>

<p>You have to collect <em>enough evidence</em> and submit a bug report.
It should explain what’s wrong in their master branch.
Don’t ever mention your pull request.
It’s a trap!
If you try to use your pull request as a proof of their mistakes, they won’t listen.</p>

<p>Forget about your pull request for a while.
Submit a bug report as if you were a stranger who just found a <em>bug in master</em>.</p>

<p>It may be hard, since master is green.
However, there is no other way around it.
Again, they won’t listen if you blame them for the failure in your pull request.
At best, they will explain to you the basics of continuous integration.</p>

<h2 id="4-move-on">4. Move On</h2>

<p>Just as poker fish (immature players) try to win every hand, junior developers try to merge every pull request.
This is a mistake.
Some problems simply can’t be fixed and some features can’t be implemented right now.
There will be time for them later.</p>

<p>It’s perfectly all right to <em>close</em> a pull request after a negative review.
There’s no need to feel obliged to finish it.
It’s better to spend time on easier bugs to fix and simpler functionality to implement.</p>

<h2 id="5-dont-call-for-help">5. Don’t Call for Help</h2>

<p>No matter how hard it is, don’t ask them to help you.
“I can’t understand why it doesn’t merge!”
Don’t say this.</p>

<p>They <a href="/2015/02/16/it-is-not-a-school.html">may help</a>, but it will be annoying for them.
You won’t look like a reliable programmer.
The more you ask for help, the more you ruin your reputation.
You must know how to solve issues on your own.</p>

<p>A failed PR isn’t a setback.
It’s a <em>lesson</em>.
Fail fast, blame smart, and move on stronger.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="oss" /><category term="etiquette" /><summary type="html"><![CDATA[When your pull request won’t merge, don't fight it—fail fast, split your changes, file bugs, and move on smarter.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/11/amores-perros.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/11/amores-perros.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Programmers, Don’t Use Windows!</title><link href="https://www.yegor256.com/2025/10/05/windows-vs-macos.html" rel="alternate" type="text/html" title="Programmers, Don’t Use Windows!" /><published>2025-10-05T00:00:00+00:00</published><updated>2025-10-05T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/10/05/windows-vs-macos</id><content type="html" xml:base="https://www.yegor256.com/2025/10/05/windows-vs-macos.html"><![CDATA[<p>In 2020, in the <a href="/books/junior-objects">Junior Objects</a> book I wrote this:
  “<em>Windows is not suitable for programmers.
  If you meet anyone who will tell you otherwise, you must know that you deal with a bad programmer, or a poor one, which are the same things.
  Your computer has to be MacBook.</em>”
Now, five years later, I still hold the same opinion.
This blog post is supposed to be less opinionated and, because of this, more convincing.
The point is still the same: you either use Windows or you are a professional programmer.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="Das Experiment (2001) by Oliver Hirschbiegel" src="/images/2025/10/das-experiment.jpg" longdesc="#f88f9b9a" /><figcaption id="f88f9b9a">Das Experiment (2001) by Oliver Hirschbiegel</figcaption></figure>

<p>First things first.
This is what ChatGPT <a href="https://chatgpt.com/share/68e2770a-79d8-8007-96d1-3722d4d3cfcd">thinks</a> about macOS vs. Windows (I toned it down a bit and sorted by importance, keeping what matters most at the top):</p>

<ul>
  <li>It’s <a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a>-compliant</li>
  <li>Tools like <code class="language-plaintext highlighter-rouge">grep</code>, <code class="language-plaintext highlighter-rouge">awk</code>, <code class="language-plaintext highlighter-rouge">sed</code>, <code class="language-plaintext highlighter-rouge">ssh</code>, and <code class="language-plaintext highlighter-rouge">make</code> work natively</li>
  <li>Proper compiler toolchain: Clang, LLVM, make, <a href="https://git-scm.com/">git</a></li>
  <li>Install everything with <a href="https://brew.sh/">HomeBrew</a>, one command away</li>
  <li>Node, Python, Ruby, Go, Java—just work without PATH hell</li>
  <li>The <a href="https://iterm2.com/">iTerm2</a> doesn’t look like it was built in 1998</li>
  <li><a href="https://www.docker.com/">Docker</a> runs faster and cleaner than on Windows</li>
  <li>SSH keys integrate smoothly with the system keychain</li>
  <li><a href="https://git-scm.com/">Git</a> behaves predictably; no <a href="https://stackoverflow.com/questions/1552749/difference-between-cr-lf-lf-and-cr-line-break-types">CRLF vs LF nightmares</a></li>
</ul>

<p>I can hear you saying:
What do I need it to be POSIX-compliant, and what is POSIX?
Why do I need <code class="language-plaintext highlighter-rouge">grep</code>, <code class="language-plaintext highlighter-rouge">sed</code>, and <code class="language-plaintext highlighter-rouge">awk</code>?
Am I a 60 years old Unix admin?
Why would I ever need <code class="language-plaintext highlighter-rouge">git</code> and <code class="language-plaintext highlighter-rouge">make</code> in the command line?
I don’t use command line at all.
I stay in the <a href="https://code.visualstudio.com/">VS Code</a> that works like a charm and helps me make a living.</p>

<p>I hear you. I do.</p>

<p>Now, hear me out.
You are not a programmer.
You look like one.
You walk like one.
You click the same buttons programmers click.
You even make the same salary they make.
But you are not one of them.
Yet.
Now, read on.</p>

<h2 id="what-is-unix">What Is Unix?</h2>

<p>Programmers are the masters of computers.
They tell machines what to do.
To simplify the task of managing a complex hardware, programmers invented a few layers of abstractions.
The first layer is an operating system.
Instead of dealing with the hard drive and the pixels on the screen directly, programmers invented files and stdout.</p>

<p>They did it in the <a href="https://en.wikipedia.org/wiki/Bell_Labs">Bell Labs</a>, during the late 1960s and early 1970s.
Earlier operating systems, like <a href="https://en.wikipedia.org/wiki/Compatible_Time-Sharing_System">CTSS</a> and <a href="https://en.wikipedia.org/wiki/OS/360_and_successors">OS/360</a>, gave them a good start.
Unix was the first OS to say that <em>everything is a file</em>, including devices, directories, sockets, and processes.
They also invented <em>pipelines</em> and the philosophy: “Write programs that do one thing well, and work together.”
They also invented <em>processes</em> and their forking mechanism.</p>

<p>Their names were <a href="https://en.wikipedia.org/wiki/Ken_Thompson">Ken Thompson</a> and <a href="https://en.wikipedia.org/wiki/Dennis_Ritchie">Dennis Ritchie</a>.</p>

<h2 id="what-is-windows">What Is Windows?</h2>

<p>Five years later, another operating system was created, with different abstractions.
Not everything was a file anymore, processes were not parallel, and there were no pipelines.
The name of the system was <a href="https://en.wikipedia.org/wiki/CP/M">CP/M</a> and the name of the inventor was <a href="https://en.wikipedia.org/wiki/Gary_Kildall">Gary Kildall</a>.
Then, five years later, 24-year-old <a href="https://en.wikipedia.org/wiki/Tim_Paterson">Tim Paterson</a> has made a copy of CP/M and called it <a href="https://en.wikipedia.org/wiki/86-DOS">86-DOS</a>.
<a href="https://www.microsoft.com/">Microsoft</a> purchased a non-exclusive license, rebranded it <a href="https://en.wikipedia.org/wiki/MS-DOS">MS-DOS</a>, and sold it to IBM.
That’s how Windows was born, in 1981.</p>

<p>Why were there no proper files, no processes, and no pipelines?
Because they weren’t trying to build a “real” operating system.
CP/M and MS-DOS were designed for tiny, single-user, single-task microcomputers, not multi-user minicomputers or mainframes.
Unix came out of Bell Labs—researchers, not hobbyists.
CP/M and MS-DOS were made for personal computers: offices and home users.
In other words, <em>MS-DOS never meant to be a proper OS</em>.
It was something that can boot up a small machine and run a single program.</p>

<p>Then, in 1985, <a href="https://en.wikipedia.org/wiki/Windows_1.0">Windows 1.0</a> was built.
It was a fancy <a href="https://en.wikipedia.org/wiki/Graphical_user_interface">GUI</a> on top of MS-DOS, not a new OS.
Later, in 1995, Microsoft introduced 32-bit APIs (<a href="https://en.wikipedia.org/wiki/Windows_API">Win32</a>) and preemptive multitasking.
However, the DOS subsystem was still lurking underneath.
Windows 95 looked modern but was still a half-DOS zombie.</p>

<p>At the same time, in 1993, the team of <a href="https://en.wikipedia.org/wiki/Dave_Cutler">Dave Cutler</a> has built <a href="https://en.wikipedia.org/wiki/Windows_NT">Windows NT</a> that was not based on DOS at all.
Latest Windows versions are descendants of NT, not MS-DOS.
Under the hood it’s conceptually closer to Unix than to CP/M.
There are features like protected memory, kernel/user separation, and file handles.
However, still it’s not Unix.</p>

<h2 id="what-is-macos">What Is macOS?</h2>

<p>In 1984, <a href="https://www.apple.com/">Apple</a> shipped their first <a href="https://en.wikipedia.org/wiki/Macintosh_128K">Macintosh</a> with the “System 1” operating system.
It was no better than MS-DOS: no multitasking, no memory protection, and primitive file system.
No surprise, it didn’t fly.</p>

<p>In 1997, Apple bought <a href="https://en.wikipedia.org/wiki/NeXT">NeXT</a> and adopted <a href="https://en.wikipedia.org/wiki/NeXTSTEP">NeXTSTEP</a> operating system.
They made it the foundation for the new <a href="https://en.wikipedia.org/wiki/MacOS">Mac OS</a>—codenamed <a href="https://en.wikipedia.org/wiki/Rhapsody_(operating_system)">Rhapsody</a>, later “Mac OS X”.</p>

<p>In 2001 they shipped Mac OS X 10.0 (“<a href="https://en.wikipedia.org/wiki/Mac_OS_X_10.0">Cheetah</a>”).
Five years later I threw away my ThinkPad with Windows and bought my first MacBook with <a href="https://en.wikipedia.org/wiki/Mac_OS_X_Leopard">Mac OS X Leopard</a>.</p>

<p>Modern macOS (Catalina, Ventura, Sequoia, etc.) is still built on that NeXT foundation.
It is POSIX-compliant and, of course, it has processes and pipelines.
In other words, it is Unix with a pretty GUI.</p>

<h2 id="abstractions">Abstractions</h2>

<p>Both Windows and macOS, in their current versions, are solid operating systems.
The difference is in the abstractions inside them: files, sockets, processes, memory blocks, users, permissions, and so on.
In Unix (macOS), everything is a <em>file</em>, while in Windows, everything is an <em>object</em>.
Files in Unix are a uniform abstraction, that’s why they can be chained via pipes.
In Windows objects are not unified in practice, they have different interfaces.</p>

<p>This is why <a href="https://en.wikipedia.org/wiki/Unix_shell">Unix shells</a> and small composable tools became so powerful.
The uniformity of “everything is a file” made composition natural.
You can build complex workflows from simple programs.</p>

<p>Windows, on the other hand, evolved around GUI apps and message loops, not shell pipelines.</p>

<h2 id="pipelines">Pipelines</h2>

<p><a href="https://en.wikipedia.org/wiki/Unix">Unix</a> was built around pipelines.
In Unix, everything is a small tool reading stdin, writing stdout.
At the same time, everything is a file, including sockets, devices, and processes.
Programmers, in Unix, see every process as a <em>composition</em> of smaller processes, glued together via pipelines.
This mindset, since 1970s, has proven to be effective, amongst a few generations of software engineering elite.</p>

<p>Say, you want to know which parts of your codebase change the most—maybe for refactoring, testing focus, or bug-hotspot analysis.
This is how you do it Unix-style:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git log <span class="nt">--pretty</span><span class="o">=</span>format: <span class="nt">--name-only</span> | <span class="se">\</span>
  <span class="nb">grep</span> <span class="s1">'\.java$'</span> | <span class="se">\</span>
  <span class="nb">sort</span> | <span class="se">\</span>
  <span class="nb">uniq</span> <span class="nt">-c</span> | <span class="se">\</span>
  <span class="nb">sort</span> <span class="nt">-nr</span> | <span class="se">\</span>
  <span class="nb">head</span> <span class="nt">-20</span>
</code></pre></div></div>

<p>Does this syntax make sense to you?
If it does, I bet you use <a href="https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux">WSL</a>.
Most serious Windows developers end up doing exactly that.</p>

<p>The command line is the bare metal interface to Unix.
The heart of the command line is pipelines.
Thanks to pipelines, command-line tools are inherently composable.
You can chain them and automate tasks in seconds that would take hours by hand.
No <a href="https://en.wikipedia.org/wiki/Integrated_development_environment">IDE</a> plugin can replace this power.</p>

<h2 id="what-are-you">What Are You?</h2>

<p>Now, you know what the difference is between Windows and macOS.
In both of them you can code, browse Internet, and watch movies.
However, in macOS you interact with the computer through Unix abstractions in a <a href="https://en.wikipedia.org/wiki/Unix_shell">shell</a>.
You don’t just use macOS—you inherit <em>fifty years of disciplined abstraction</em>.</p>

<p>In Windows you interact with the computer through draggable GUI elements.
A GUI makes you a consumer; a CLI makes you a creator.
A GUI hides the logic behind gestures and icons; a CLI exposes it as text you can reason about, automate, and combine.
You can’t pipe a button click into another program, you can’t grep a progress bar, and you can’t version-control a mouse movement.
Every click you make dies the moment you make it; every command you write can live forever.</p>

<p>Oh, wait.
In macOS you can’t really play games.
Bummer…
Maybe you shouldn’t, since you are a programmer?</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="mood" /><summary type="html"><![CDATA[Windows turns programmers into mouse operators. macOS, built on Unix, keeps the command line alive—where everything is a file, tools connect through pipelines, and real programmers stay in control.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/10/das-experiment.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/10/das-experiment.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Red vs. Black</title><link href="https://www.yegor256.com/2025/09/14/red-and-black.html" rel="alternate" type="text/html" title="Red vs. Black" /><published>2025-09-14T00:00:00+00:00</published><updated>2025-09-14T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/09/14/red-and-black</id><content type="html" xml:base="https://www.yegor256.com/2025/09/14/red-and-black.html"><![CDATA[<p>In Soviet Russia, prisoner camps were divided into two categories: red and black.
In a red camp, the power belonged to the prisoners who cooperated with the administration and helped it maintain discipline.
In a black one, the power was in the hands of criminals who resented the rules, in permanent confrontation with the administration.
It seems that in software companies we may also categorize employees into red and black.
A <strong>red employee</strong> enjoys obeying the rules and climbs up the career ladder by <a href="/2015/01/26/happy-boss-false-objective.html">making the boss happy</a>.
To the contrary, a <strong>black employee</strong>, while understanding the inevitability, despises the necessity to obey.
Their career growth is driven by <a href="/2015/02/23/haircut.html">making the customer happy</a>.
Which one are you?</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="Холодное лето пятьдесят третьего (1987) by Александр Прошкин" src="/images/2025/09/cold-summer-1953.jpg" longdesc="#ded7ba65" /><figcaption id="ded7ba65">Холодное лето пятьдесят третьего (1987) by Александр Прошкин</figcaption></figure>

<p>An organization cannot exist without policies and regulations.
Especially if it’s a large organization where the percentage of underperformers is highest.
The clock-watchers must be disciplined so that they produce at least something.
Let’s assume you are not one of them.</p>

<p>However, even if you are not a nine-to-five clock-watcher, you can’t ignore the policies.
A few examples of the rules you may need to obey:</p>

<ul>
  <li>All reports must follow the official PowerPoint template</li>
  <li>Every meeting requires written minutes sent to all participants</li>
  <li>Job candidates must pass through the full HR pipeline</li>
  <li>Employees must re-certify their skills on a fixed schedule</li>
</ul>

<p>All of the above seem reasonable—just like prison rules.
The difference is your attitude toward them.</p>

<p>They are either a <strong>framework</strong> for your career or an inevitable <strong>evil</strong>.
You either feel happy when you do what’s required, or feel annoyed and do it just because it’s required.
You either fill out all the forms completely, or you cut every possible corner to get back to the real work.
You either read an email copied to 25 people to not miss anything or immediately delete it.
You either attend all meetings or learn to be creative in finding reasons why you can’t.</p>

<p>You are either red or black.
Once you find your <strong>identity</strong>, you start despising the other side.</p>

<aside class="quote">Minimize contact, keep your head down when necessary, and focus on delivering real value where it matters.
</aside>

<p>If you are red, you don’t understand the black employees who are constantly rebelling.
They rebel against the rules you so much enjoy following.
You see them as dishonest, disloyal, and selfish sociopaths.</p>

<p>If you are black, you despise the red employees who are trying so hard to associate themselves with the system.
They study the rules and compete against each other—who knows them better.
You see them as <a href="/2017/08/22/to-be-nice-or-not.html">shallow</a> and incompetent <a href="/2021/03/03/imposters-to-win.html">impostors</a>.</p>

<p>Peace is not possible.
In any large organization, reds will always dominate—it’s inevitable.
The system needs them, and they thrive inside it.
Blacks will always be a minority, surviving at the edges.</p>

<p>If you are black, don’t waste energy trying to convert or fight the reds.
You won’t win.
The only strategy is distance.
Minimize contact, keep your head down when necessary, and focus on delivering real value where it matters.
Reds will spend their lives climbing the corporate ladder.
Blacks must learn to survive in the shadows of that ladder, working for the customer, not the boss.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="management" /><category term="mood" /><summary type="html"><![CDATA[In big organizations, reds obey bosses while blacks serve customers—and blacks survive only by keeping their distance.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/09/cold-summer-1953.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/09/cold-summer-1953.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">The End of Type Annotations</title><link href="https://www.yegor256.com/2025/08/17/type-annotations.html" rel="alternate" type="text/html" title="The End of Type Annotations" /><published>2025-08-17T00:00:00+00:00</published><updated>2025-08-17T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/08/17/type-annotations</id><content type="html" xml:base="https://www.yegor256.com/2025/08/17/type-annotations.html"><![CDATA[<p>Type annotations are what make statically typed object-oriented languages like Java run <strong>faster</strong> and <strong>safer</strong>.
Without annotations, every variable would effectively collapse to <code class="language-plaintext highlighter-rouge">Object</code>, forcing runtime casts.
The code would work, but slower and with more runtime errors.
Some type annotations may be inferred instead of being explicitly specified by a programmer.
Not all though.
In Java, for example, a number of hard-to-resolve challenges prevent us from inferring types of all objects.
This is not a fundamental limitation of OOP itself.
It’s a result of design trade-offs in Java and similar languages.
In a perfect object-oriented language, all variable types would be inferrable.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="Swingers (1996) by Doug Liman" src="/images/2025/08/swingers.jpg" longdesc="#4225221a" /><figcaption id="4225221a">Swingers (1996) by Doug Liman</figcaption></figure>

<p>Imagine a simple Java method:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Price priceOfDelivery(Book book, City city) {
  Price price = book.price();
  Delivery delivery = new Delivery(price, city);
  return delivery.price();
}
</code></pre></div></div>

<p>Two reasons justify the usage of <code class="language-plaintext highlighter-rouge">Book</code>, <code class="language-plaintext highlighter-rouge">City</code>, <code class="language-plaintext highlighter-rouge">Price</code>, and <code class="language-plaintext highlighter-rouge">Delivery</code> type annotations:
Compilers and programmers need help.</p>

<h2 id="type-annotations-are-helpful">Type Annotations Are Helpful</h2>

<p>First, we help the compiler eliminate some <strong>dynamic dispatches</strong> in favor of static calls.
If the <code class="language-plaintext highlighter-rouge">Book</code> is a class, not an interface, the <code class="language-plaintext highlighter-rouge">book.price()</code> call may be compiled into a jump to an absolute address.
Without information about the <code class="language-plaintext highlighter-rouge">book</code>’s class, <code class="language-plaintext highlighter-rouge">.price()</code> goes to a virtual table first, finds the address, and only then jumps.
The second scenario is more expensive.
The type annotation attached to <code class="language-plaintext highlighter-rouge">book</code> helps avoid it.</p>

<p>Second, we help ourselves write safe code, avoiding “Method not found” <strong>runtime errors</strong>.
If <code class="language-plaintext highlighter-rouge">book</code> is not annotated as <code class="language-plaintext highlighter-rouge">Book</code>, we may mistakenly pass <code class="language-plaintext highlighter-rouge">Integer</code>, meaning the book’s ID in the database.
At compile time, that would lead to no errors.
Later, at runtime, we get an error when <code class="language-plaintext highlighter-rouge">.price()</code> is not found in the virtual table of the <code class="language-plaintext highlighter-rouge">Integer</code> class.</p>

<p>However, both compilers and programmers can improve.</p>

<h2 id="compilers-can-do-better">Compilers Can Do Better</h2>

<p>Sometimes, a compiler can infer the type of a variable, without an explicit annotation.
For example, this code compiles in Java, starting from version 10:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Price priceOfDelivery(Book book, City city) {
  var price = book.price();
  var delivery = new Delivery(price, city);
  return delivery.price();
}
</code></pre></div></div>

<p>The type annotation used in earlier Java versions is replaced with the <code class="language-plaintext highlighter-rouge">var</code> keyword.</p>

<p>In a small piece of code such as this one, the compiler can <strong>infer</strong> types.
However, it may fall short with the <code class="language-plaintext highlighter-rouge">book</code> and <code class="language-plaintext highlighter-rouge">city</code> parameters.
In the general case, type inference is not decidable for Java programs.
Because of generics, method overloading, reflection, and … complexity.</p>

<p>The complexity is the technical obstacle.
The compiler can’t infer types for all variables because it would be too expensive to analyze the whole program.
Instead, it compiles file by file.
Even if the compiler had the whole program, inference in Java would still hit undecidability in the general case.
File-by-file compilation makes this even more restrictive.</p>

<p>All other barriers, such as generics, the compiler can’t overcome:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void print(List&lt;?&gt; items) {
  var x = items.get(0); // What is the type?
}
</code></pre></div></div>

<p>No matter how hard the compiler tries, in the general case, this question doesn’t have an answer.</p>

<h2 id="programmers-can-do-better">Programmers Can Do Better</h2>

<p>We, programmers, can help the compiler infer types.</p>

<p>For example, we can stop using generics.
Instead of <code class="language-plaintext highlighter-rouge">List&lt;Book&gt;</code> we can have a <code class="language-plaintext highlighter-rouge">Library</code> and instead of <code class="language-plaintext highlighter-rouge">Map&lt;User, Phone&gt;</code> we can have a <code class="language-plaintext highlighter-rouge">PhoneBook</code>.
It’s easier to infer the type of the object taken from a <code class="language-plaintext highlighter-rouge">Library</code> versus the object taken from a generic <code class="language-plaintext highlighter-rouge">List</code>.</p>

<p>We can also stop using method overloading.
Instead of <code class="language-plaintext highlighter-rouge">print(String x)</code> and <code class="language-plaintext highlighter-rouge">print(Integer x)</code> we can create <code class="language-plaintext highlighter-rouge">printString(x)</code> and <code class="language-plaintext highlighter-rouge">printInteger(x)</code>.
Types of parameters are easier to infer in more specialized methods.</p>

<p>We can also stop using reflection.</p>

<aside class="quote">The easier it is to infer the type of a variable for a compiler, the faster the programmer gets the semantics of it too.
</aside>

<p>Java programmers may not be ready for such a <strong>radical move</strong>.
However, if they were, they would not only help the compiler but themselves too.
Eliminating type annotations makes code shorter and, because of that, cleaner.
This is why <code class="language-plaintext highlighter-rouge">var</code> syntax was introduced in Java 10.</p>

<p>In the code above, variable names are nouns.
In well-written code, nouns as names are <a href="/2015/01/12/compound-name-is-code-smell.html">sufficient</a> to disambiguate variables.
No need to call it <code class="language-plaintext highlighter-rouge">cityOfDelivery</code> or <code class="language-plaintext highlighter-rouge">bookToDeliver</code>.
Just <code class="language-plaintext highlighter-rouge">book</code> and <code class="language-plaintext highlighter-rouge">city</code> are enough.</p>

<p>We also named variables by their types: a <code class="language-plaintext highlighter-rouge">book</code> is of type <code class="language-plaintext highlighter-rouge">Book</code>, and so on.
By looking at the name of the variable we can tell its type.
The <code class="language-plaintext highlighter-rouge">Book</code> type annotation looks like a syntactical redundancy.
It only leads to lower code readability, by making it longer.
It’s reasonable to expect type inference to free our programs from this redundancy.</p>

<p>Thus, better type inference means better <strong>readability</strong> of the code.</p>

<h2 id="languages-can-do-better">Languages Can Do Better</h2>

<p>Languages like Haskell and the ML family prove that full type inference is achievable.
However, they still need annotations for edge cases.
Rust takes a middle ground.
It infers local variable types but enforces explicit annotations at public interfaces.
Go, until recently, avoided generics, operator overloading, and heavy reflection, making inference straightforward.
However, it forces programmers to annotate all public boundaries—function signatures, struct fields, and interfaces.</p>

<aside class="quote">If the type of a variable can’t be inferred, compilation fails.
</aside>

<p>I suggest taking one step forward and designing a language that doesn’t have any type annotations.
Such a language should not have generics, method overloading, reflection, and everything else that prevents 100% type inference.
Then, we must design a compiler for this language that compiles the entire program, not single files.</p>

<p>The language may be as strict as this:
If the type of a variable can’t be inferred, compilation fails.</p>

<p>This is how the book price snippet would look in such a language:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>priceOfDelivery(book, city) {
  p = book.price();
  d = new Delivery(p, city);
  return d.price();
}
</code></pre></div></div>

<p>To me, this seems to be much more readable than the original code in Java.</p>

<p>Compilation time remains a limitation though.
We turn this issue into an opportunity.
Programmers are forced, by the timing limitations of the compiler, to write smaller modules.
When they need larger programs, they break them into modules that communicate via <a href="https://en.wikipedia.org/wiki/Inter-process_communication">IPC</a> instead of staying in a monolithic binary.</p>

<p>We’re experimenting with this approach in <a href="https://www.eolang.org">EOLANG</a>, a language designed to maximize inference by eliminating features that make it undecidable.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="oop" /><summary type="html"><![CDATA[Type annotations are a workaround for compiler limitations, not a feature—a well-designed language should infer all types automatically, forcing programmers to write smaller, cleaner modules.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/08/swingers.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/08/swingers.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">remove(42) vs. find(42).remove()</title><link href="https://www.yegor256.com/2025/06/22/retrieve-or-remove.html" rel="alternate" type="text/html" title="remove(42) vs. find(42).remove()" /><published>2025-06-22T00:00:00+00:00</published><updated>2025-06-22T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/06/22/retrieve-or-remove</id><content type="html" xml:base="https://www.yegor256.com/2025/06/22/retrieve-or-remove.html"><![CDATA[<p>We have a list of books in the <code class="language-plaintext highlighter-rouge">books</code> object.
How do we remove a single book from it, given that we know its ID?
We can do <code class="language-plaintext highlighter-rouge">books.removeById(42)</code>.
Alternatively, we can find it with <code class="language-plaintext highlighter-rouge">books.findById(42)</code> and then call <code class="language-plaintext highlighter-rouge">b.remove()</code>.
Which option should we prefer, and why?
The second choice is the better one.
Not only because it’s more object-oriented, but also due to several practical advantages.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="8 Femmes (2002) by François Ozon" src="/images/2025/06/8-femmes.jpg" longdesc="#d7e21337" /><figcaption id="d7e21337">8 Femmes (2002) by François Ozon</figcaption></figure>

<h2 id="extending-the-deletion-behavior">Extending the Deletion Behavior</h2>

<p>What if we want to extend the deletion algorithm?
For example, suppose we want to print a log message every time a book is deleted.</p>

<p>If we follow the <a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">open-closed principle</a>, we should avoid modifying the existing <code class="language-plaintext highlighter-rouge">Book</code> or <code class="language-plaintext highlighter-rouge">Books</code> classes.
Instead, we want to either <a href="/2016/09/13/inheritance-is-procedural.html">extend</a> or <a href="/2015/02/26/composable-decorators.html">decorate</a> them.
A decorator is the ideal choice if we want to avoid <a href="/2016/09/13/inheritance-is-procedural.html">implementation inheritance</a>.</p>

<p>If we use <code class="language-plaintext highlighter-rouge">removeById()</code>, we must decorate the <code class="language-plaintext highlighter-rouge">books</code> object.
If we use <code class="language-plaintext highlighter-rouge">remove()</code>, we can decorate the individual book retrieved via <code class="language-plaintext highlighter-rouge">findById()</code>.
The latter approach may be more <strong>cohesive</strong>, since its decoratee is likely <strong>smaller</strong> and more <strong>focused</strong>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="nf">findById</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="no">Logged</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">b</span><span class="p">.</span><span class="nf">remove!</span>
</code></pre></div></div>

<h2 id="handling-missing-or-non-deletable-books">Handling Missing or Non-Deletable Books</h2>

<p>What if the book isn’t found, or can’t be deleted?
The <code class="language-plaintext highlighter-rouge">removeById()</code> approach doesn’t support the <a href="https://en.wikipedia.org/wiki/Null_object_pattern">Null Object</a> pattern well.
It forces us to throw an exception—or worse, return <code class="language-plaintext highlighter-rouge">false</code>, which goes <a href="/2018/08/22/builders-and-manipulators.html">against</a> the <a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation">CQS</a> principle.</p>

<p>On the other hand, returning an object, even a <a href="https://en.wikipedia.org/wiki/Null_object_pattern">null</a> or <a href="/2014/09/23/built-in-fake-objects.html">fake</a> object, offers more <strong>flexible error handling</strong>.
For instance, we can access <code class="language-plaintext highlighter-rouge">title()</code> safely, knowing that the book was found successfully—or catch and <a href="https://en.wikipedia.org/wiki/Exception_chaining">re-raise exceptions</a> with <a href="/2015/12/01/rethrow-exceptions.html">more context</a>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="nf">findById</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="k">begin</span>
  <span class="n">b</span><span class="p">.</span><span class="nf">remove!</span>
<span class="k">rescue</span> <span class="n">e</span>
  <span class="k">raise</span> <span class="n">e</span><span class="p">,</span> <span class="s2">"Can't delete book </span><span class="si">#{</span><span class="n">b</span><span class="p">.</span><span class="nf">title</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="decoupling-retrieval-and-deletion">Decoupling Retrieval and Deletion</h2>

<p>What if the retrieval and deletion of the object happen far apart in the code?</p>

<p>If <code class="language-plaintext highlighter-rouge">books</code> knows how to find, and a <code class="language-plaintext highlighter-rouge">book</code> knows how to delete, we keep responsibilities nicely separated.
It also allows the book to be immutable and encapsulate its own ID, reducing <a href="/2016/11/21/naked-data.html">leakage</a> of internal data:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">b</span> <span class="o">=</span> <span class="n">books</span><span class="p">.</span><span class="nf">findById</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="c1"># +100 lines here...</span>
<span class="n">b</span><span class="p">.</span><span class="nf">remove!</span>  <span class="c1"># DELETE FROM book WHERE id = 42</span>
<span class="c1"># +200 lines here...</span>
<span class="k">if</span> <span class="n">b</span><span class="p">.</span><span class="nf">exists?</span>  <span class="c1"># SELECT * FROM book WHERE id = 42</span>
  <span class="nb">puts</span> <span class="s2">"The book is back to the library!"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Once the ID is wrapped inside the book by <code class="language-plaintext highlighter-rouge">findById()</code>, it never has to <strong>leak out</strong> again.
This reduces the amount of <a href="/2016/11/21/naked-data.html">naked data</a> exposed to parts of the code that don’t need it.</p>

<p>The less data is visible, the <a href="/2016/11/21/naked-data.html">better</a> the design—at least from an OOP perspective.</p>

<p>Thus, using <code class="language-plaintext highlighter-rouge">findById()</code> followed by <code class="language-plaintext highlighter-rouge">remove()</code> embraces object-oriented principles more fully.
It allows for cleaner extension, better error handling, and tighter encapsulation.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="oop" /><summary type="html"><![CDATA[Delegating behavior to objects rather than invoking utility methods leads to cleaner, more extensible, and properly encapsulated object-oriented design.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/06/8-femmes.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/06/8-femmes.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Write Unit Tests, Don’t Waste Our Money!</title><link href="https://www.yegor256.com/2025/06/08/pull-request-without-test.html" rel="alternate" type="text/html" title="Write Unit Tests, Don’t Waste Our Money!" /><published>2025-06-08T00:00:00+00:00</published><updated>2025-06-08T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/06/08/pull-request-without-test</id><content type="html" xml:base="https://www.yegor256.com/2025/06/08/pull-request-without-test.html"><![CDATA[<p>Automated tests help us write code <a href="/angry-tests.html">faster</a>.
Unit tests immediately <a href="/2022/07/05/safety-net.html">tell us</a> when we break something.
Integration tests calm us down, reducing the fear of shipping a failure to a user.
But who are “us”?
Programmers.
What about our employers?
How do automated tests help them?
Automated tests protect their <strong>investments</strong>.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="La Femme Nikita (1990) by Luc Besson" src="/images/2025/06/la-femme-nikita.jpg" longdesc="#ccb58518" /><figcaption id="ccb58518">La Femme Nikita (1990) by Luc Besson</figcaption></figure>

<p>Every change we make to a codebase costs our employer money.
Whether they pay us <a href="/2015/07/21/hourly-pay-modern-slavery.html">monthly</a>
  or <a href="/2014/04/11/cost-of-loc.html">per line of code</a>, the bottom line is the same:
  it’s the code that reaches the repository and is eventually released to the end user.</p>

<p>That’s what the business is investing in—new features <a href="/2018/07/24/bugs-or-pull-requests.html">or</a> bug fixes.
The code that’s written and shipped is what matters to them.</p>

<p>Even when they say they’re investing in people, what they really want is the code.
People are merely an intermediate by-product.
The ultimate asset is the codebase.</p>

<p>They want to <strong>protect</strong> that <strong>asset</strong>.</p>

<p>A loss of investment could be a hundred lines written today not working tomorrow.
Think about it this way: we expect a car to work after paying the body shop to fix it.
We don’t mind paying again if something else breaks—but not if it’s the exact same part they fixed yesterday.
We expect the repaired part to function properly while driving.
We want a warranty on what’s already been fixed.</p>

<aside class="quote">People are merely an intermediate by-product—the ultimate asset is the codebase.
</aside>

<p>Similarly, our employers expect our code to work once we’ve committed it and collected our paycheck.
They want a warranty that the code won’t break again once it’s been fixed.
Automated tests can offer that <strong>warranty</strong>.</p>

<p>Continuing the metaphor: “driving” a codebase means actively modifying its parts—refactoring or extending.
The more aggressively we drive it, the higher the risk of breaking something.
The parts of the code not covered by tests are the first to break.</p>

<p>Test coverage guarantees that what worked before—and was already paid for—continues to work even under the stress of refactoring.</p>

<p>So, any contribution to a codebase without a <strong>supporting</strong> test is a waste of the employer’s money.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="etiquette" /><category term="testing" /><summary type="html"><![CDATA[If you write code without tests, you're probably wasting your employer's money---because it'll break again right where you "fixed" it.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/06/la-femme-nikita.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/06/la-femme-nikita.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Good Title — Good Bug Report</title><link href="https://www.yegor256.com/2025/05/31/good-bug-title.html" rel="alternate" type="text/html" title="Good Title — Good Bug Report" /><published>2025-05-31T00:00:00+00:00</published><updated>2025-05-31T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/05/31/good-bug-title</id><content type="html" xml:base="https://www.yegor256.com/2025/05/31/good-bug-title.html"><![CDATA[<p>A few weeks ago, <a href="https://github.com/horw">@horw</a> released a new GitHub plugin that fixes GitHub issue titles: <a href="https://github.com/horw/issue-title-ai">issue-title-ai</a>.
Once an issue is created, the plugin asks <a href="https://chatgpt.com">ChatGPT</a>—or <a href="https://www.deepseek.com/">DeepSeek</a>, or <a href="https://claude.ai/">Claude</a>—to improve its title.
We’ve already integrated the plugin into <a href="https://github.com/objectionary/eo">objectionary/eo</a> and a few other repositories.
Works like a charm.
What’s wrong with the titles the way they are, you may ask?
Why do we need to ask ChatGPT to make them “better”?
Because we want every issue—either a bug report, a feature request, or a question—to be formulated as a <a href="/2025/05/25/bug-driven-development.html">complaint</a>.
It seems that very few of us can do it on the first try.
The help of AI is appreciated.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="Flawless (1999) by Joel Schumacher" src="/images/2025/05/flawless.jpg" longdesc="#6699c6ab" /><figcaption id="6699c6ab">Flawless (1999) by Joel Schumacher</figcaption></figure>

<p>Let’s say, you try to download a PNG file from a web app, but get a text file instead.
You want to report this problem to the team.
How would you title such a bug report?
Pick one, out of these eight:</p>

<ul>
  <li>“CSV”</li>
  <li>“CSV file downloading”</li>
  <li>“Please, fix CSV-file downloading”</li>
  <li>“CSV downloading must be fixed”</li>
  <li>“Why I get text file instead of PNG?”</li>
  <li>“How can I download PNG file?”</li>
  <li>“I need text file, not PNG”</li>
  <li>“PNG downloading is broken, getting CSV instead”</li>
</ul>

<p>There may be even more variations… but the best is the last one.
It clearly states that something is <strong>broken</strong>.
It demands a fix.</p>

<p>Even if it’s a feature request or a question, it should be filed as a complaint.
This rule—known as <a href="/2025/05/25/bug-driven-development.html">bug driven development</a>—increases our productivity.
In every request made to the team we have to explain the difference between our expectations and reality.
The lack of such an explanation seems to be the primary source of confusion and frustration in task tracking.</p>

<p>Apparently, very few programmers have this skill: formulating a problem as a complaint.
AI should help us.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="etiquette" /><category term="testing" /><summary type="html"><![CDATA[ChatGPT helps us re-format GitHub issue titles after their authors submit them --- helping developers understand their tasks better.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/05/flawless.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/05/flawless.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Stop Asking and Suggesting — Just Complain</title><link href="https://www.yegor256.com/2025/05/25/bug-driven-development.html" rel="alternate" type="text/html" title="Stop Asking and Suggesting — Just Complain" /><published>2025-05-25T00:00:00+00:00</published><updated>2025-05-25T00:00:00+00:00</updated><id>https://www.yegor256.com/2025/05/25/bug-driven-development</id><content type="html" xml:base="https://www.yegor256.com/2025/05/25/bug-driven-development.html"><![CDATA[<p>Wikipedia <a href="https://en.wikipedia.org/wiki/Tester-driven_development">says</a> that Bug Driven Development (BDD) is an anti-pattern.
<a href="https://github.com/rajakolluru">Raja Shankar Kolluru</a> perfectly <a href="https://itmusings.com/bug-driven-development/">explains</a> why.
However, <a href="https://github.com/FlorianRappl">Florian Rappl</a> <a href="https://www.florian-rappl.de/News/Page/227/bug-driven-development">argues</a> that it’s not.
<a href="https://github.com/benwinding">Ben Winding</a> <a href="https://blog.benwinding.com/bug-driven-development-sometimes-its-the-best-choice/">believes</a> that it’s better than TDD.
In simple words, BDD is kind of like trying to build a plane while it’s flying, based on passenger complaints.
Nobody builds planes like that (well, maybe <a href="https://spectrum.ieee.org/how-the-boeing-737-max-disaster-looks-to-a-software-developer">Boeing</a> and <a href="https://www.theguardian.com/technology/2015/may/20/airbus-issues-alert-software-bug-fatal-plane-crash">Airbus</a>).
However, a software team that practices BDD might demonstrate higher productivity.</p>

<!--more-->

<figure class="jb_picture"><img itemprop="image" alt="Ghost Dog (1999) by Jim Jarmush" src="/images/2025/05/ghost-dog.jpg" longdesc="#32d0d0e9" /><figcaption id="32d0d0e9">Ghost Dog (1999) by Jim Jarmush</figcaption></figure>

<p>A software team does BDD if it follows one simple principle:
Every piece of work is formulated as a <strong>complaint</strong>.</p>

<p>It started <a href="https://www.researchgate.net/publication/2559439_An_Overview_of_the_Software_Engineering_Process_and_Tools_in_the_Mozilla_Project">in 2002</a>, by Mozilla:</p>

<blockquote>
  <p>Every code change in the Mozilla codebase is made as part of a “fix” for a uniquely numbered “bug.” Though it commonly has a pejorative connotation, in the Mozilla Project the term bug is used to refer to any filed request for modification in the software, be it an actual defect, an enhancement, or a change in functionality.</p>
</blockquote>

<p>If you listen to Mozilla’s advice, you won’t have feature requests, or questions, or tasks in your <a href="https://en.wikipedia.org/wiki/Issue_tracking_system">issue tracking system</a>.
Only bug reports.
They may sound like “The wing is on fire!”—a perfect complaint—or “A plane doesn’t have a jacuzzi!”—a perfect feature request in the form of a complaint.
Questions may also look like complaints: “It is unclear how to fasten the belt.”
Whether they are coming from testers or customers, the format is the same: “I don’t like it.”</p>

<p>The primary benefit that BDD can give to a project is <strong>noise reduction</strong>.
I can think of two reasons for that:</p>

<ol>
  <li>
    <p>Complaints, due to their rather aggressive nature, require their authors to provide strong arguments to back them up.
They must think twice before submitting a ticket that accuses the codebase of being broken or imperfect.
They must be specific and precise.
No noise.</p>
  </li>
  <li>
    <p>Similarly, programmers must convince a complainant that the problem is resolved.
They can’t close the ticket with just a text answer.
They need to demonstrate a reasonably significant contribution to the codebase.
No noise.</p>
  </li>
</ol>

<p>A good complaint identifies a <strong>flaw</strong> in something tangible.
A good resolution of a good complaint is a <strong>patch</strong> to that tangible something.
Obviously, in a software project, the <strong>source code</strong> is what is tangible.</p>

<aside class="quote">Bug tracker is not a support line for your coding troubles.
</aside>

<p>In a disciplined team, every ticket is a bug report that addresses a flaw in the source code.
Every bug report leads to a patch—a contribution to the source code.
No noise.
The team is focused and demonstrates the best possible productivity.</p>

<p>BDD also has a major drawback.
It may be hard to train the team to use it.
The adoption of BDD may require a change of their <strong>mindset</strong>.
They must switch from noise-makers to flaw-finders.</p>

<p><a href="https://blog.codinghorror.com/about-me/">Jeff Atwood</a>, in his blog post about <a href="https://blog.codinghorror.com/complaint-driven-development/">complaint-driven development</a>, explains it from a business point of view.
He suggests that instead of implementing what you believe is right, it’s better to give your customers a rough draft and let them complain.
You’re most often wrong about what they’ll actually complain about.
The more they complain, the better you listen, the bigger the value you deliver.</p>]]></content><author><name>Yegor Bugayenko</name><email>yegor256@gmail.com</email></author><category term="etiquette" /><category term="testing" /><summary type="html"><![CDATA[When every piece of work is framed as a bug report --- including feature requests and questions --- a software team may become more productive.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://www.yegor256.com/images/2025/05/ghost-dog.jpg" /><media:content medium="image" url="https://www.yegor256.com/images/2025/05/ghost-dog.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>