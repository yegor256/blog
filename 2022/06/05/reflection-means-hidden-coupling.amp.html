<!DOCTYPE html>
<html amp lang="en">
  <head>

    <meta charset="utf-8">
    <title>Reflection Means Hidden Coupling</title>
    <link rel="canonical" href="https://www.yegor256.com/2022/06/05/reflection-means-hidden-coupling.html">
    <link rel="icon" type="image/png" href="/favicon.ico">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2022/06/05/reflection-means-hidden-coupling.html"
        },
        "headline": "Reflection Means Hidden Coupling",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2022/02/wheelman.jpg",
          "height": 459,
          "width": 777
        },
        "datePublished": "2022-06-05",
        "dateModified": "2022-06-05",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Reflection in object-oriented programming languages like Java is
a powerful technique, but a very dangerous and harmful one.
",
        "keywords": ["reflection", "oop reflection", "reflection is bad", "what is reflection", "why reflection"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500">
    <style amp-custom="amp-custom">
      @font-face {
        font-family: 'Cambria';
        src: url('https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf');
      }
      body { font-family: 'Cambria', 'Times New Roman', serif; padding: .5em; font-size: 1.2em; }
      article { width: 600px; max-width: 100%; margin-left: auto; margin-right: auto; }
      pre, code { font-family: 'Source Code Pro', 'Courier New', monospace; font-size: .8em; }
      code { padding: 0 .3em; background-color: lightgray; }
      a, a:hover, a:visited { color: inherit; }
      .intro { color: red; font-size: .75em; }
      .photo { border-radius: 50%; }
      pre { overflow-x:scroll; }
    </style>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <article>
      <p class="intro">
        This is a mobile version, full one is
        <a href="https://www.yegor256.com/2022/06/05/reflection-means-hidden-coupling.html">here</a>.
      </p>
      <p>
        <amp-img src="/images/face-256x256.jpg" width="80" height="80" alt="Yegor Bugayenko" class="photo"></amp-img>
      </p>
      <p>Yegor Bugayenko<br>5 June 2022</p>
      <h1>Reflection Means Hidden Coupling</h1>
      <p><a href="https://en.wikipedia.org/wiki/Reflective_programming">Reflective programming</a> (or reflection) happens
when your code changes itself on the fly. For example, a method of a class, when we call it,
among other things adds a new method to the class
(also known as <a href="https://en.wikipedia.org/wiki/Monkey_patch">monkey patching</a>). 
Java, Python, PHP, JavaScript, you name it—they
all have this “powerful” feature. What’s 
<a href="https://softwareengineering.stackexchange.com/questions/193526">wrong</a> with it? 
Well, it’s 
<a href="https://mattwarren.org/2016/12/14/Why-is-Reflection-slow/">slow</a>, 
<a href="https://owasp.org/www-community/vulnerabilities/Unsafe_use_of_Reflection">dangerous</a>,
and hard to read and debug.
But all that is nothing compared with the <em>coupling</em> it introduces to the code.</p>



<amp-img src="/images/2022/02/wheelman.jpg" alt="Wheelman (2017) by Jeremy Rush" height="459" width="777" layout="responsive"></amp-img>

<p>There are many situations when reflection can “help” you.
Let’s go through all of them and see why the coupling they add to the code is
unnecessary and harmful.</p>

<h2 id="type-checking-and-casting">Type Checking and Casting</h2>

<p>Here is the code:</p>

<pre>public int sizeOf(Iterable items) {
  return ((Collection) items).size();
}</pre>

<p>I’m not sure everybody would agree that this is reflection, but I believe
it is: we check the structure of the class at runtime and then make
a call to the method <code class="highlighter-rouge">size()</code> which doesn’t exist in the <code class="highlighter-rouge">Iterable</code>. This method only
“shows up” at runtime, when we make
a <a href="https://stackoverflow.com/questions/19017258">dynamic shortcut</a>
to it in the bytecode.</p>

<p>Why is this bad, aside from the fact that
1) it’s <a href="http://www.buzdin.lv/2011/01/is-java-reflection-really-slow.html">slow</a>,
2) it’s more verbose and so <a href="https://armedia.com/blog/instanceof-avoid-in-code/">less readable</a>,
and
3) it introduces a new point of failure since the object <code class="highlighter-rouge">items</code> may not be
an instance of class <code class="highlighter-rouge">Collection</code>,
leading to <a href="https://docs.oracle.com/javaee/5/api/javax/el/MethodNotFoundException.html"><code class="highlighter-rouge">MethodNotFoundException</code></a>?</p>

<p>The biggest problem the code above causes to the entire program is the coupling
it introduces between itself and its clients, for example:</p>

<pre>public void calc(Iterable&lt;?&gt; list) {
  int s = sizeOf(list);
  System.out.println("The size is " + s);
}</pre>

<p>This method may work or it may not. It will depend on the actual class of <code class="highlighter-rouge">list</code>. If it is
<code class="highlighter-rouge">Collection</code>, the call to <code class="highlighter-rouge">sizeOf</code> will succeed. Otherwise, there will be a runtime failure.
By looking at the method <code class="highlighter-rouge">calc</code> we can’t tell what is the right way to handle <code class="highlighter-rouge">list</code> in order
to avoid runtime failure. We need to read the body of <code class="highlighter-rouge">sizeOf</code> and only then can we change <code class="highlighter-rouge">calc</code>
to something like this:</p>

<pre>public void calc(Iterable&lt;?&gt; list) {
  if (list instanceof Collection) {
    int s = sizeOf(list);
    System.out.println("The size is " + s);
  } else {
    System.out.println("The size is unknown");
  }
}</pre>

<p>This code seems to be OK so far. However, what will happen when <code class="highlighter-rouge">sizeOf</code> changes its implementation
to something like this (I took it from
<a href="/2015/04/02/class-casting-is-anti-pattern.html">this article</a>
about casting):</p>

<pre>public int sizeOf(Iterable items) {
  int size = 0;
  if (items instanceof Collection) {
    size = ((Collection) items).size();
  } else {
    for (Object item : items) {
      ++size;
    }
  }
  return size;
}</pre>

<p>Now, <code class="highlighter-rouge">sizeOf</code> perfectly handles any type that’s coming in, whether it’s an instance
of <code class="highlighter-rouge">Collection</code> or not. However, the method <code class="highlighter-rouge">calc</code> doesn’t know about the changes made in the method <code class="highlighter-rouge">sizeOf</code>.
Instead, it still believes that <code class="highlighter-rouge">sizeOf</code> will break if it gets anything aside from <code class="highlighter-rouge">Collection</code>.
To keep them in sync we have to remember that <code class="highlighter-rouge">calc</code> knows too much about <code class="highlighter-rouge">sizeOf</code>  and will
have to modify it when <code class="highlighter-rouge">sizeOf</code> changes. Thus, it’s valid to say that <code class="highlighter-rouge">calc</code> is
coupled with <code class="highlighter-rouge">sizeOf</code> and this coupling is <em>hidden</em>:
most probably, we will forget to modify <code class="highlighter-rouge">calc</code> when <code class="highlighter-rouge">sizeOf</code> gets a better implementation.
Moreover, there could be many other places in the program similar to <code class="highlighter-rouge">calc</code>,
which we must remember to modify when the method <code class="highlighter-rouge">sizeOf</code> changes.
Obviously, we will forget about most of them.</p>

<p>This coupling, which is a big maintainability issue, was introduced thanks to the
very existence of reflection in Java. If we had not been able to use <code class="highlighter-rouge">instanceof</code> operator
and class casting (or did not even have them), the coupling would not be possible in the first place.</p>

<h2 id="forceful-testing">Forceful Testing</h2>

<p>Consider this code:</p>

<pre>class Book {
  private String author;
  private String title;
  Book(String a, String t) {
    this.author = a;
    this.title = t;
  }
  public void print() {
    System.out.println(
      "The book is: " + this.name()
    );
  }
  private String name() {
    return this.title + " by " + this.author;
  }
}</pre>

<p>How would you write a unit test for this class and for its method <code class="highlighter-rouge">print()</code>?
Obviously, it’s almost impossible without refactoring the class.
The method <code class="highlighter-rouge">print</code> sends text to the console, which we can’t easily mock
since it’s “static.” The right way would be to make <code class="highlighter-rouge">System.out</code> injectable
as a dependency, but some of us
<a href="https://stackoverflow.com/questions/34571">believe</a> that reflection is a better option,
which would allow us to test the private method <code class="highlighter-rouge">name</code> directly, without
calling <code class="highlighter-rouge">print</code> first:</p>

<pre>class BookTest {
  @Test
  void testNamingWorks() {
    Book b = new Book(
      "David West", "Object Thinking"
    );
    Method m = book.getClass().getDeclaredMethod("name");
    m.setAccessible(true);
    assertThat(
      (String) m.invoke(book),
      equalTo("Object Thinking by David West")
    );
  }
}</pre>

<p>You can also use <a href="https://github.com/powermock/powermock">PowerMock</a> Java library
to do many “beautiful” things with private methods.</p>

<p>The problem with this test is that it is tightly coupled with the object it
tests: the test <em>knows</em> too much about the class <code class="highlighter-rouge">Book</code>. The test knows that the
class contains a private method <code class="highlighter-rouge">name</code>. The test also knows that the method <code class="highlighter-rouge">name</code>
will at some point be called by the method <code class="highlighter-rouge">print</code>. Instead of testing <code class="highlighter-rouge">print</code>
the test tests what it’s not supposed to be aware of: the internals of the class <code class="highlighter-rouge">Book</code>.</p>

<p>The main purpose of a unit test is to be a “safety net” for us
programmers trying to modify the code that was written earlier or much much earlier:
if we break anything, the tests give us a timely signal, “highlighting” the place
where the code was broken. If nothing is highlighted and the tests are green
I can continue modifying the code. I rely on the information from my tests. I trust them.</p>

<p>I take the class <code class="highlighter-rouge">Book</code> and want to modify it, simply making the method <code class="highlighter-rouge">name</code>
return <code class="highlighter-rouge">StringBuilder</code> instead of <code class="highlighter-rouge">String</code>. It’s a pretty
innocent modification, which may be necessary for performance considerations.
Before I start making any changes, I run all tests
(it’s a <a href="https://wiki.c2.com/?TestEveryRefactoring">good practice</a>) and they all pass.
Then I make my changes, expecting no tests to fail:</p>

<pre>class Book {
  // ...
  public void print() {
    System.out.println(
      "The book is: " + this.name().toString()
    );
  }
  private StringBuilder name() {
    return new StringBuilder()
      .append(this.title)
      .append(" by ")
      .append(this.author);
  }
}</pre>

<p>However, the test <code class="highlighter-rouge">BookTest</code> will fail, because it <em>expects</em> my class <code class="highlighter-rouge">Book</code> to have
method <code class="highlighter-rouge">name</code> which returns <code class="highlighter-rouge">String</code>. If it’s not my test or I wrote it a long time ago,
I would be frustrated to learn this fact: the test expects me to write my <em>private</em> methods
only one specific way. Why? What’s wrong with returning <code class="highlighter-rouge">StringBuilder</code>? I would think
that there is some hidden reason for this. Otherwise, why would a test demand anything
from a private implementation of a class? Very soon, after some investigation I would
find out that there is no reason. It’s just an assumption the test made about the
internals of <code class="highlighter-rouge">Book</code> and this assumption has no reasons aside from “We didn’t have time
to refactor the class and make <code class="highlighter-rouge">System.out</code> injectable.”</p>

<p>By the way, this testing approach is
<a href="/2018/12/11/unit-testing-anti-patterns.html">known</a>
as the “Inspector” test anti-pattern.</p>

<p>What would I do next? I would have to roll back my changes and then start refactoring
the test <em>and</em> the class, in order to get rid of this assumption. However, changing the
test and at the same time changing main code is,
<a href="https://twitter.com/yegor256/status/1525758255225528320">I believe</a>,
a <a href="https://stackoverflow.com/questions/1569168">dangerous practice</a>:
most probably I will introduce some new bugs.</p>

<p>The tests are not a “safety net” for me anymore. I can’t trust them.
I modify the code and I know that I didn’t break anything.
However, the test gives me a red signal.
How can I trust it if it lies in such a simple scenario?</p>

<p>This coupling between the unit test <code class="highlighter-rouge">BookTest</code> and the class <code class="highlighter-rouge">Book</code>
would not happen if it was not possible to use reflection in the first place.
If nobody had the ability to reach the private method in any way,
the Inspector anti-pattern in unit tests would not be possible.</p>

<p><a href="/2017/02/07/private-method-is-new-class.html">Of course</a>,
life would be even better if we also didn’t have private methods.</p>

<h2 id="factories">Factories</h2>

<p>Here is how a typical <a href="/2017/11/14/static-factory-methods.html">factory</a>
may work:</p>

<pre>interface Operator {
  int calc(int a, int b);
}
// This is a Factory Method:
Operator make(String name) {
  try {
    return Class.forName("Op" + name);
  } catch (ClassNotFoundException ex) {
    throw new IllegalStateException(ex);
  }
}</pre>

<p>The <a href="/2017/11/14/static-factory-methods.html">factory method</a>
is <code class="highlighter-rouge">make</code>. It expects the name of the “operator” to be provided
and then,
using <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#forName-java.lang.String-"><code class="highlighter-rouge">Class.forName()</code></a>
from the Java Reflection API, constructs the name of the class, finds it in the
<a href="https://docs.oracle.com/javase/tutorial/essential/environment/paths.html">classpath</a>,
and makes an instance of it. Now, say there are two classes both implementing the
interface <code class="highlighter-rouge">Operator</code>:</p>

<pre>class OpPlus implements Operator {
  int calc(int a, int b) {
    return a + b;
  }
}
class OpMinus implements Operator {
  int calc(int a, int b) {
    return a - b;
  }
}</pre>

<p>Then we use them, first asking our factory method to make objects from
operator names:</p>

<pre>int result = make("Plus").calc(
  make("Minus").calc(15, 3),
  make("Minus").calc(8, 7)
);</pre>

<p>The <code class="highlighter-rouge">result</code> will be 13.</p>

<p>We would not be able to do this without reflection. We would have to do this
instead:</p>

<pre>int result = new OpPlus().calc(
  new OpMinus().calc(15, 3),
  new OpMinus().calc(8, 7)
);</pre>

<p>If you ask me, this code looks much more readable and maintainable.
First of all, because in any IDE that enables
<a href="https://www.jetbrains.com/help/idea/navigating-through-the-source-code.html#go_to_declaration">code navigation</a>
it would be possible to click on <code class="highlighter-rouge">OpMinus</code> or <code class="highlighter-rouge">OpPlus</code> and immediately
jump to the body of the class. Second, the logic of class finding
is provided out-of-the-box by JVM: I don’t need to guess what happens when
<code class="highlighter-rouge">make("Plus")</code> is called.</p>

<p>There are a few reasons why people love static factories. I don’t agree with them.
This <a href="/2017/11/14/static-factory-methods.html">blog post</a>
explains why. Without reflection it wouldn’t be possible to
have static factories at all and the code would be better and more maintainable.</p>

<h2 id="annotations">Annotations</h2>

<p>In Java you can attach an annotation
(an instance of a <a href="/2016/07/06/data-transfer-object.html">DTO</a>-ish interface)
to a class (or an element of it like a method or an argument).
The information from the annotation can then be read at runtime or compile time.
In modern frameworks like <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html">Spring</a>
this feature is frequently used in order
to automate <a href="https://stackoverflow.com/questions/19414734">objects wiring</a>:
you just attach some annotations to your classes
and the framework will find them, instantiate them, place them into a
<a href="/2014/10/03/di-containers-are-evil.html">DI container</a>,
and assign to other objects’ attributes.</p>

<p>I’ve <a href="/2014/10/03/di-containers-are-evil.html">said it earlier</a>
that this very mechanism of discovering objects and <em>automatically</em>
wiring them together is an anti-pattern. I’ve also
<a href="/2016/04/12/java-annotations-are-evil.html">said earlier</a>
that annotations are an anti-pattern.
Neither dependency injection containers, not auto-wiring, nor annotations
would exist if there was no reflection. Life would be much better
and Java/OOP much cleaner.</p>

<p>The clients of annotated objects/classes are coupled with them, and
this coupling is <em>hidden</em>. An annotated object can change its interface or
modify annotations and the code will compile just fine. The problem will
surface only later at runtime, when the expectations of other objects
won’t be satisfied.</p>

<h2 id="serialization">Serialization</h2>

<p>When programmers don’t understand
<a href="/2016/08/15/what-is-wrong-object-oriented-programming.html">object-oriented paradigm</a>,
they make <a href="/2016/07/06/data-transfer-object.html">DTOs</a> instead of
<a href="/2016/07/14/who-is-object.html">proper objects</a>.
Then, in order to transfer a DTO over a network or save it to a file, they
<a href="https://en.wikipedia.org/wiki/Serialization">serialize</a> or
<a href="https://en.wikipedia.org/wiki/Marshalling_%28computer_science%29">marshall</a> them.
It’s usually done by a special serialization engine, which takes a DTO,
<a href="http://erights.org/data/serial/jhu-paper/intro.html">breaks</a>
all possible encapsulation barriers,
reads the values of all of its fields,
and packages them into, say, a piece of JSON.</p>

<p>In order to let the serialization engine break encapsulation barriers, a programming
language has to have reflection. First, because some fields of a DTO may be private
and thus accessible only through reflection.
Second, even if a DTO is designed “right” with all necessary
<a href="/2014/09/16/getters-and-setters-are-evil.html">getters</a>
for the private fields, still reflection is required in order to understand
which getters are present and can be called.</p>

<p>The attitude serialization expresses towards objects is very similar to what
<a href="/2014/12/01/orm-offensive-anti-pattern.html">ORM</a> does. Neither of them
talk to objects, but instead they pretty “offensively” tear them apart, taking away
what’s necessary, and leaving the poor objects unconscious. If in the future an
object decides to change its structure, rename some fields, or change the types
of returned values—other objects, which actually are coupled with the object through
serialization, won’t notice anything. They will notice, but only at runtime,
when “invalid data format” exceptions start floating up. The developers
of the object won’t have a chance to notice that their changes to the interface
of the object affect some other places in the code base.</p>

<p>We can say that serialization is a “perfect” method of coupling two objects
such that neither one will know about it.</p>

<p>The <a href="/2016/07/14/who-is-object.html">very idea</a>
of object-oriented programming is centered around the principle
that an object is king. An object and only an object may decide what
to do with the data it encapsulates. The existence of this principle and adherence
to it helps avoid runtime errors usually caused by a simple scenario:
A uses the data coming from B without telling B how it’s being used,
then B changes the format or semantics of the data, and A fails to understand it.</p>

<p>Obviously, serialization in such an “abusive” way would not be possible,
if there was no reflection in the first place. A more careful serialization
would be possible and would be used, not through reflection but via
<a href="/2016/04/05/printers-instead-of-getters.html">printers</a>
implemented by objects.</p>

<hr>

<p>To conclude, reflection introduces coupling, which is hidden. This is the
most dangerous type of coupling, because it’s hard to follow, it’s hard to find,
and it’s hard to remove. Without reflection object-oriented design would be
much cleaner and solid. But even if this feature does exist,
I suggest you never use reflection in your programming language.</p>

<blockquote class="twitter-tweet">
<p lang="en" dir="ltr">Do you use reflective programming (reflection)?</p>— Yegor Bugayenko (@yegor256) <a href="https://twitter.com/yegor256/status/1535919879886446592?ref_src=twsrc%5Etfw">June 12, 2022</a>
</blockquote>



    </article>
  </body>
</html>
