<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US" itemscope="" itemtype="http://schema.org/WebSite"> <head> <meta charset="utf-8"/> <meta name="description" content="What is the right way to keep test classes in a repository? There is no single canonical approach, but a few principles may help you keep test files in order." /> <meta name="keywords" content="" /> <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/> <meta name="google-site-verification" content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8" /> <meta name="author" content="Yegor Bugayenko"> <meta name="og:site_name" content="Yegor Bugayenko"/> <meta name="og:type" content="article" /> <meta name="og:locale" content="en_US" /> <meta name="twitter:account_id" content="4503599630178231" /> <meta name="twitter:creator" content="@yegor256"/> <meta name="twitter:site" content="@yegor256"/> <meta name="twitter:title" property="og:title" content="On the Layout of Tests"/> <meta name="twitter:description" property="og:description" content="What is the right way to keep test classes in a repository? There is no single canonical approach, but a few principles may help you keep test files in order."/> <meta name="twitter:url" property="og:url" content="https://www.yegor256.com/ru/2023/01/19/layout-of-tests.html"/> <meta name="telegram:channel" content="AAAAAEJFMRzsRTRxM3ec6A"/> <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="yegor256" /> <link rel="shortcut icon" href="/favicon.ico?d864995d304"/> <link rel="apple-touch-icon" href="/favicon.ico?d864995d304"/> <link rel="alternate" type="application/rss+xml" title="RSS for yegor256.com" href="https://www.yegor256.com/rss.xml"/> <link rel="stylesheet" href="/css/layout.css?d864995d304"/> <link rel="stylesheet" href="/css/icons.css?d864995d304"/> <link rel="canonical" href="https://www.yegor256.com/ru/2023/01/19/layout-of-tests.html" /> <title>On the Layout of Tests</title> </head> <body><div class="wrapper"> <aside class="header-toggle unprintable" id="header-toggle" title="Show the menu" onclick="$('#header').show();$('#header-toggle').hide();">&#9776;</aside> <header class="header" id="header"><div class="face"> <a href="/about-me.html#form" class="sub" title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html" style="position:relative;"> <img src="/images/face-256x256.jpg" class="photo" alt="Yegor Bugayenko"/> </a></div><nav><ul class="menu social notranslate"> <li><a href="https://twitter.com/intent/follow?screen_name=yegor256" rel="nofollow" title="Follow me on Twitter"><i class="icon icon-twitter notranslate" aria-hidden="true"></i></a></li> <li><a href="/rss.xml" rel="nofollow" title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://github.com/yegor256" rel="nofollow" title="My GitHub profile"><i class="icon icon-github notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="http://stackoverflow.com/users/187141/yegor256" rel="nofollow" title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.facebook.com/yegor256" rel="nofollow" title="Follow me on Facebook"><i class="icon icon-facebook notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://instagram.com/yegor256" rel="nofollow" title="Follow me on Instagram"><i class="icon icon-instagram notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.linkedin.com/in/yegor256" rel="nofollow" title="My LinkedIn profile"><i class="icon icon-linkedin notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.youtube.com/c/yegor256?sub_confirmation=1" rel="nofollow" title="My Youtube video channel"><i class="icon icon-youtube notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.pinterest.com/yegor256/" rel="nofollow" title="My Pinterest boards"><i class="icon icon-pinterest notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://angel.co/yegor256" rel="nofollow" title="My AngelList profile"><i class="icon icon-angellist notranslate" aria-hidden="true"></i></a></li> <li><a href="https://soundcloud.com/yegor256" rel="nofollow" title="My podcast"><i class="icon icon-podcast notranslate" aria-hidden="true"></i></a></li> <li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721" rel="nofollow" title="My iTunes podcast"><i class="icon icon-itunes notranslate" aria-hidden="true"></i></a></li> <li><a href="https://t.me/yegor256news" rel="nofollow" title="My Telegram public channel"><i class="icon icon-telegram notranslate" aria-hidden="true"></i></a></li> <li><a href="mailto:blog@yegor256.com" rel="nofollow" title="Email me any time"><i class="icon icon-mail notranslate" aria-hidden="true"></i></a></li></ul><ul class="menu"> <li><a href="/" title="Home page">Home</a></li> <li ><a href="/best.html" title="Best articles to read">12&#160;Best</a></li> <li ><a href="/contents.html" title="The contents of the entire blog">All&#160;391</a></li> <li ><a href="/teaching.html" title="My courses and lectures">Teaching</a></li> <li ><a href="/talks.html" title="Future and past conference talks">Talks</a></li> <li ><a href="/books.html" title="The books I wrote">Books</a></li> <li ><a href="/research.html" title="My research directions and progress">Research</a></li> <li ><a href="/pets.html" title="My loved pet projects">Pets</a></li> <li ><a href="/testimonials.html" title="What some people say about me">Testimonials</a></li> <li ><a href="/shift-m.html" title="Audio podcast about project management">Shift-M</a></li> <li ><a href="/paintings.html" title="My paintings for sale">Art</a></li> <li><a href="https://ru.yegor256.com/" title="Немного на русском языке о политике в России, Украине и мире">Политика</a></li></ul></nav><div class="search"> <form method="get" action="https://www.google.com/search" itemprop="potentialAction" itemscope="" itemtype="http://schema.org/SearchAction"> <meta itemprop="target" content="https://www.google.com/search?q={q}"/> <input name="sitesearch" value="yegor256.com" type="hidden"/> <input itemprop="query-input" type="text" id="search-query" class="field field-text" required="required" onfocus="$('.google').css('visibility', 'visible');" name="q" placeholder="Search..." autocomplete="off"/> <input type="image" src="/images/google-search-icon.svg" class="google" title="Search via Google" alt="Search via Google"/> </form></div><div class="hot"><ul></ul></div></header></div><section itemscope="" itemtype="http://schema.org/BlogPosting"><div class="wrapper"> <header><h1 itemprop="name headline mainEntityOfPage">On the Layout of Tests</h1></header> <article class="main" itemprop="articleBody" style="font-family: sans-serif; font-size: 0.9em; line-height: 1.2em;"><p style="color: #C42C00;">The following text is a <em>partial</em> translation of the <a href='https://www.yegor256.com/2023/01/19/layout-of-tests.html'>original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:</p><p>Я не знаю, на каком языке программирования вы работаете, но мой опыт работы с недавним кодированием на Java, Ruby, JavaScript, PHP, Python, C++ и Rust говорит мне, что принцип, которому я постараюсь убедить вас следовать, универсален для всех языков. Речь идет о названии файлов с тестами. Возможно, вам это покажется вопросом низкой важности, но позвольте мне показать, что это не так. Как вы называете свои файлы с тестовыми классами? Сколько из них вы создаете в каталоге src/test/java? Где размещать класс, который используется только в тесте, но сам по себе не является тестом? На большинство из этих вопросов большинство из вас ответит “Как угодно!” Итак, давайте попробуем найти лучший ответ.</p><p>Основная цель моих модульных тестов - помочь мне писать код. Они - сетка безопасности, которая “ловит” меня, когда я допускаю ошибку. Например, предположим, что я возвращаюсь и редактирую несколько файлов, которые редактировал несколько лет назад, и, конечно же, на этот раз я делаю это неправильно. Затем я запускаю все 500 модульных тестов в проекте, и… десять из них становятся красными. Обратите внимание, я не говорю “неудачно”, потому что, подобно сетке безопасности вокруг здания, неудавшиеся тесты - это те тесты, которые не поймали падающий молоток и не заметили только что появившуюся ошибку. Таким образом, 490 из них <em>неудачны</em>, но десять из них <em>удачны</em>.</p><p>Далее я почесываю голову и думаю - что именно я сделал не так? Какой файл я сломал? Я только что изменил несколько десятков строк кода. Где именно была ошибка? Чтобы выяснить это, я читаю вывод тестов. Я ожидаю, что сообщения, которые они выводят в консоль, будут достаточно описательными, чтобы помочь мне понять проблему. Я не хочу отменять все свои изменения и начинать с нуля, верно? Я хочу быстро перейти к строке с ошибкой, исправить ее, запустить все 500 тестов заново, увидеть их все зелеными, зафиксировать свои изменения и закончить на сегодня.</p><p>Само собой разумеется, что описательные сообщения проверок и правильное именование методов тестирования - рецепт успеха. Рассмотрим простой объект Фразы, куда мы добавляем несколько английских фраз, и он волшебным образом понимает, какие из них являются приветствиями (очевидно, с помощью ML). Для такого класса этот тест на Java/JUnit5 был бы очень плохим:</p><p>В то время как данный тест намного лучше благодаря утверждениям <a href="https://www.hamcrest.org">Hamcrest</a> (как назвать методы тестов - это отдельная история, подробно объясненная <a href="https://stackoverflow.com/questions/155436/">здесь</a>):</p><p>Первый фрагмент выведет довольно неясное сообщение об ошибке, тогда как второй очень поможет мне в борьбе с только что возникшей ошибкой: Сообщение будет само по себе понятным. Я быстро пойму, в чем проблема.</p><p>Описательные сообщения помогут мне понять, в чем проблема. Однако я узнаю <em>где</em> находится проблема? В каком классе Java? На самом деле нет. Она находится в <code class="language-plaintext highlighter-rouge">Phrases.java</code>, или, может быть, в <code class="language-plaintext highlighter-rouge">Greetings.java</code>, который возвращается <code class="language-plaintext highlighter-rouge">Phrases.greetings()</code>? Я могу узнать эту информацию только из <em>имени</em> тестового класса. Если он называется <code class="language-plaintext highlighter-rouge">PhrasesTest.java</code>, - все ошибки, которые он обнаруживает, <em>скорее всего</em> находятся в <code class="language-plaintext highlighter-rouge">Phrases.java</code>. Если он называется <code class="language-plaintext highlighter-rouge">GreetingsTest.java</code> - … ну, вы понимаете.</p><p>Моя точка зрения заключается в том, что имя тестового класса - это не просто имя. Это инструкция для поискающего программиста: “Посмотрите в исходный файл, имя которого можно получить из моего имени, удалив суффикс <code class="language-plaintext highlighter-rouge">Test</code>”. Если я попытаюсь следовать этой инструкции и она не приведет меня ни к чему, я очень разочаруюсь, особенно если проект не мой. Я не могу получить требуемую информацию ни откуда. Имя тестового класса - моя последняя надежда.</p><p>Что, если тестовый класс становится слишком длинным? Он может содержать несколько десятков или более тестовых методов. Нам не хочется, чтобы класс был слишком большим, верно? Неправда! Тестовый класс - это не класс. Это даже не утилитарный класс. Это контейнер для тестовых сценариев. Он называется классом только потому, что Java (и многие другие языки) не имеют альтернативных инструментов организации кода. Поэтому не беспокойтесь о том, что ваши тестовые классы становятся чрезмерно длинными. 5000 строк кода в тестовом классе - совсем <em>не проблема</em>. Еще раз, потому что это не класс, а только набор тестовых сценариев.</p><p>Очень часто некоторые классы или функции не являются тестами, но должны быть общими для тестов. (Я уверен, что вы знаете, что общие тесты - это антипаттерн. Вы знаете об этом?) Посмотрите, как я провел рефакторинг модульного теста выше (он не элегантен вовсе, но просите подождать меня немного!).</p><p>Здесь, в закрытом методе <code class="language-plaintext highlighter-rouge">prepare(),</code> у меня есть удобный конструктор объекта класса <code class="language-plaintext highlighter-rouge">Phrases.</code> Этот конструктор может быть полезен для других тестов, таких как <code class="language-plaintext highlighter-rouge">GreetingsTest.</code> Я не хочу копировать его из <code class="language-plaintext highlighter-rouge">PhrasesTest</code> в <code class="language-plaintext highlighter-rouge">GreetingsTest.</code> Вместо этого я хочу поместить его в место, где его можно будет повторно использовать. Это будет правильное место для него (<code class="language-plaintext highlighter-rouge">foo</code> - это пакет Java, к которому относятся все наши классы).</p><p>Статический метод <code class="language-plaintext highlighter-rouge">FooUtils.prepare()</code> теперь находится в утилитарном классе <code class="language-plaintext highlighter-rouge">FooUtils</code> (ужасное анти-паттерн!), который находится в пакете <code class="language-plaintext highlighter-rouge">foo.support</code>. Но обратите внимание, не в пакете <code class="language-plaintext highlighter-rouge">foo</code>, а в подпакете, которого нет в живом коде: здесь нет директории <code class="language-plaintext highlighter-rouge">src/main/java/foo/support.</code> Это ясное сообщение программисту, который встретит этот репозиторий через несколько лет: все классы, которые находятся в <code class="language-plaintext highlighter-rouge">foo.support</code>, принадлежат только тестовому конвейеру и сами по себе не являются тестами.</p><p>Как вы знаете, утилитарные классы и приватные статические методы являются рудиментами императивного программирования. В объектно-ориентированном мире существуют более хорошие альтернативы. JUnit5, в частности, предлагает довольно элегантные механизмы для создания предварительных условий для тестирования: <a href="https://junit.org/junit5/docs/current/user-guide/#extensions-registration">расширения тестов</a>. Все, что нужно для выполнения тестового метода, мы предоставляем через его параметры, которые инициализируются расширениями, например:</p><p>Затем, тест будет выглядеть таким образом:</p><p>Теперь тест и его предварительные требования находятся в двух разных местах и не так тесно связаны, как раньше. Более того, предварительные требования могут быть легко повторно использованы. Волшебная аннотация <code class="language-plaintext highlighter-rouge">@ExtendWith</code> может быть применена к другим тестам. Реализация <code class="language-plaintext highlighter-rouge">PhrasesExtension</code> может стать умнее: она может начать обращать внимание не только на тип аргумента метода теста, но и на пользовательскую аннотацию, примененную к нему (так работает <a href="https://junit.org/junit5/docs/5.4.1/api/org/junit/jupiter/api/io/TempDir.html"><code class="language-plaintext highlighter-rouge">@TempDir</code></a>).</p><p>Несмотря на красоту расширений JUnit, я не считаю их лучшим способом разделения требований к тестовым методам. Расширения JUnit все еще довольно связаны… не с тестовыми методами, а с полным набором тестов проекта. Если вы решите использовать их в другом месте, в другом проекте, вы не сможете сделать это.</p><p>Кроме того, если вы решите проверить ваши требования, вы не сможете сделать это элегантно. Конечно, вы можете написать для них тесты в том же каталоге, но в этом случае вы нарушите принцип: один тест на один живой класс.</p><p>Решение заключается в использовании фиктивных объектов. Они находятся вместе с другими живыми объектами, но имеют особое “фиктивное” поведение, например (кстати, я не люблю фабрики, но в этом случае это нормально):</p><p>Затем тест будет выглядеть так:</p><p>Расположение репозитория будет выглядеть следующим образом:</p><p>Обратите внимание на тест <code class="language-plaintext highlighter-rouge">FactoryOfPhrasesTest.</code> Он тестирует “фальшивый” объект <code class="language-plaintext highlighter-rouge">FactoryOfPhrases,</code> который является частью коллекции живых классов. Фабрика фраз поставляется вместе с остальными классами. Поэтому ее можно использовать другими проектами, а не только для тестовых целей.</p><p>В заключение, как правило, я предлагаю держать тестовые классы чистыми: там должны находиться только методы тестирования. Никаких атрибутов и, конечно же, никаких статических приватных методов. Все, что является предпосылкой, должно быть “фальшивым” объектом.</p><p>В мире Maven существуют классы модульных тестов (с суффиксом “Test”) и классы интеграционных тестов (с суффиксом “ITCase”). Разница между ними огромна. Оба компилируются в фазе “test-compile” с помощью плагина “maven-compiler-plugin”, но они не выполняются вместе. Вместо этого модульные тесты выполняются на фазе “test”. Сборка завершается с ошибкой немедленно, если хотя бы один модульный тест не проходит. Это довольно простой подход, который похож на другие средства автоматизации сборки.</p><p>Интеграционные тесты выполняются в четыре шага (это названия фаз Maven):</p><p>Сначала ресурсы, необходимые для интеграционного тестирования, получаются на этапе <code class="language-plaintext highlighter-rouge">pre-integration-test</code>. Например, может быть запущен тестовый экземпляр базы данных MySQL. Затем тесты с помощью <code class="language-plaintext highlighter-rouge">ITCase</code> выполняются на этапе «integration-test». Результат их выполнения игнорируется, но записывается в файл. Затем ресурсы освобождаются на этапе <code class="language-plaintext highlighter-rouge">post-integration-test</code>. Например, сервер MySQL останавливается. Наконец, на этапе <code class="language-plaintext highlighter-rouge">verify</code> результаты тестов проверяются, и сборка завершается с ошибкой, если некоторые из них не пройдены успешно.</p><p>Я храню файлы <code class="language-plaintext highlighter-rouge">ITCase</code> вместе с файлами <code class="language-plaintext highlighter-rouge">Test</code> только тогда, когда они являются интеграционными тестами для конкретных рабочих классов. Очень часто это не так - вот почему они и называются интеграционными тестами. Они могут интегрировать и тестировать несколько классов вместе. В этом случае я помещаю их в отдельный пакет и даю им произвольные имена, которые не совпадают с именами рабочих классов.</p><p>Здесь <code class="language-plaintext highlighter-rouge">GreetingsITCase.java</code> - это интеграционный тест для <code class="language-plaintext highlighter-rouge">Greetings.java</code>, в то время как <code class="language-plaintext highlighter-rouge">SimpleGuessingITCase.java</code> - это интеграционный тест без привязки к конкретному классу. Очевидно, что пакет <code class="language-plaintext highlighter-rouge">foo.it</code> существует только в тестах и отсутствует в <code class="language-plaintext highlighter-rouge">src/main/java</code>.</p><p>Таким образом, есть первое правило: класс теста может иметь только методы с аннотацией <code class="language-plaintext highlighter-rouge">@Test</code> (в случае Java).</p><p>Затем есть второе правило: пакет с тестами может содержать только классы с суффиксами <code class="language-plaintext highlighter-rouge">Test</code> или <code class="language-plaintext highlighter-rouge">ITCase</code>, которые однозначно соответствуют живым классам и ничему другому.</p><p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/42 on 2023-11-22 at 10:26</p></article></div><div class="wrapper"> <footer class="footer"><p> &copy; <span itemscope="" itemprop="copyrightHolder" itemtype="http://schema.org/Person"> <span itemprop="name">Yegor Bugayenko</span> </span> 2014&ndash;<span itemprop="copyrightYear">2023</span></p></footer></div></section><div class="wrapper unprintable" style="text-align:center;margin-top:2em;"> <a href="https://www.sixnines.io/h/3ba1652f"> <img src="//www.sixnines.io/b/3ba1652f?style=flat" alt="sixnines availability badge" /></a> &nbsp; <a href="https://github.com/yegor256/blog/stargazers"> <img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square" alt="GitHub stars" /></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script> <script src="/js/all.js?d864995d304"></script> <script>var disqus_shortname = 'yegor256';</script> <script id="dsq-count-scr" src="//yegor256.disqus.com/count.js" async="async"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-1963507-32', 'auto'); ga('send', 'pageview'); </script> <script> Cd=document;Cr="&"+Math.random();Cp="&s=1"; Cd.cookie="b=b";if(Cd.cookie)Cp+="&c=1"; Cp+="&t="+(new Date()).getTimezoneOffset(); if(self!=top)Cp+="&f=1"; </script> <script> if(navigator.javaEnabled())Cp+="&j=1"; </script> <script> if(typeof(screen)!='undefined')Cp+="&w="+screen.width+"&h="+ screen.height+"&d="+(screen.colorDepth?screen.colorDepth:screen.pixelDepth); </script> <script> Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+ "&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+ "' border='0' wi"+"dth='1' he"+"ight='1'/>"); </script> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] } </script> </body> </html>
