<!doctypehtml><html xmlns="https://www.w3.org/1999/xhtml"lang="en-US"xml:lang="en-US"itemscope=""itemtype="http://schema.org/WebSite"><meta charset="utf-8"><meta name="description"content="Who is that properly designed object in an object-oriented world? What name, behavior, habits, interfaces, and friends does he have? Let&apos;s look at it from a different perspective."><meta name="keywords"content=""><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><meta name="google-site-verification"content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8"><meta name="author"content="Yegor Bugayenko"><meta name="og:site_name"content="Yegor Bugayenko"><meta name="og:type"content="article"><meta name="og:locale"content="en_US"><meta name="twitter:account_id"content="4503599630178231"><meta name="twitter:creator"content="@yegor256"><meta name="twitter:site"content="@yegor256"><meta name="twitter:title"property="og:title"content="Seven Virtues of a Good Object"><meta name="twitter:description"property="og:description"content="Who is that properly designed object in an object-oriented world? What name, behavior, habits, interfaces, and friends does he have? Let&apos;s look at it from a different perspective."><meta name="twitter:url"property="og:url"content="https://www.yegor256.com/ru/2014/11/20/seven-virtues-of-good-object.html"><meta name="telegram:channel"content="AAAAAEJFMRzsRTRxM3ec6A"><link rel="search"type="application/opensearchdescription+xml"href="/opensearch.xml"title="yegor256"><link rel="shortcut icon"href="/favicon.ico?ca021e3385f"><link rel="apple-touch-icon"href="/favicon.ico?ca021e3385f"><link rel="alternate"type="application/rss+xml"title="RSS for yegor256.com"href="https://www.yegor256.com/rss.xml"><link rel="stylesheet"href="/css/layout.css?ca021e3385f"><link rel="stylesheet"href="/css/icons.css?ca021e3385f"><link rel="canonical"href="https://www.yegor256.com/ru/2014/11/20/seven-virtues-of-good-object.html"><title>Seven Virtues of a Good Object</title><div class="wrapper"><aside class="header-toggle unprintable"id="header-toggle"title="Show the menu"onclick='$("#header").show(),$("#header-toggle").hide()'>&#9776;</aside><header class="header"id="header"><div class="face"><a href="/about-me.html#form"class="sub"title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html"style="position:relative"><img src="/images/face-256x256.jpg"class="photo"alt="Yegor Bugayenko"></a></div><nav><ul class="menu social notranslate"><li><a href="https://twitter.com/intent/follow?screen_name=yegor256"rel="nofollow"title="Follow me on Twitter"><i class="icon icon-twitter notranslate"aria-hidden="true"></i></a><li><a href="/rss.xml"rel="nofollow"title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://github.com/yegor256"rel="nofollow"title="My GitHub profile"><i class="icon icon-github notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="http://stackoverflow.com/users/187141/yegor256"rel="nofollow"title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://www.facebook.com/yegor256"rel="nofollow"title="Follow me on Facebook"><i class="icon icon-facebook notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://instagram.com/yegor256"rel="nofollow"title="Follow me on Instagram"><i class="icon icon-instagram notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://www.linkedin.com/in/yegor256"rel="nofollow"title="My LinkedIn profile"><i class="icon icon-linkedin notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://www.youtube.com/c/yegor256?sub_confirmation=1"rel="nofollow"title="My Youtube video channel"><i class="icon icon-youtube notranslate"aria-hidden="true"></i></a><li><a href="https://soundcloud.com/yegor256"rel="nofollow"title="My podcast"><i class="icon icon-podcast notranslate"aria-hidden="true"></i></a><li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721"rel="nofollow"title="My iTunes podcast"><i class="icon icon-itunes notranslate"aria-hidden="true"></i></a><li><a href="https://t.me/yegor256news"rel="nofollow"title="My Telegram public channel"><i class="icon icon-telegram notranslate"aria-hidden="true"></i></a><li><a href="mailto:blog@yegor256.com"rel="nofollow"title="Email me any time"><i class="icon icon-mail notranslate"aria-hidden="true"></i></a></ul><ul class="menu"><li><a href="/"title="Home page">Home</a><li><a href="/best.html"title="Best articles to read">12&#160;Best</a><li><a href="/contents.html"title="The contents of the entire blog">All&#160;395</a><li><a href="/teaching.html"title="My courses and lectures">Teaching</a><li><a href="/talks.html"title="Future and past conference talks">Talks</a><li><a href="/books.html"title="The books I wrote">Books</a><li><a href="/research.html"title="My research directions and progress">Research</a><li><a href="/pets.html"title="My loved pet projects">Pets</a><li><a href="/testimonials.html"title="What some people say about me">Testimonials</a><li><a href="/shift-m.html"title="Audio podcast about project management">Shift-M</a><li><a href="/paintings.html"title="My paintings for sale">Art</a><li><a href="https://ru.yegor256.com/"title="Немного на русском языке о политике в России, Украине и мире">Политика</a></ul></nav><div class="search"><form action="https://www.google.com/search"itemprop="potentialAction"itemscope=""itemtype="http://schema.org/SearchAction"><meta itemprop="target"content="https://www.google.com/search?q={q}"><input name="sitesearch"value="yegor256.com"type="hidden"> <input itemprop="query-input"id="search-query"class="field field-text"required="required"onfocus='$(".google").css("visibility","visible")'name="q"placeholder="Search..."autocomplete="off"> <input type="image"src="/images/google-search-icon.svg"class="google"title="Search via Google"alt="Search via Google"></form></div><div class="hot"><ul></ul></div></header></div><section itemscope=""itemtype="http://schema.org/BlogPosting"><div class="wrapper"><header><h1 itemprop="name headline mainEntityOfPage">Seven Virtues of a Good Object</h1></header><article class="main"itemprop="articleBody"style="font-family:sans-serif;font-size:.9em;line-height:1.2em"><p style="color:#c42c00">The following text is a <em>partial</em> translation of the <a href="https://www.yegor256.com/2014/11/20/seven-virtues-of-good-object.html">original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:<p>Мартин Фаулер <a href="https://martinfowler.com/bliki/InversionOfControl.html">говорит</a>:<p>Функции, организованные в классы? Со всем уважением, это неправильно. И это очень распространенное заблуждение о классе в объектно-ориентированном программировании. Классы не являются организаторами функций. И объекты не являются структурами данных.<p>Так что же такое “правильный” объект? Какой из них не является правильным? В чем разница? Несмотря на то, что это очень полемическая тема, она очень важна. Если мы не понимаем, что такое объект, как мы можем писать объектно-ориентированное программное обеспечение? Хорошо, благодаря Java, Ruby и другим языкам, мы можем. Но насколько хорошим это будет? К сожалению, это не точная наука, и есть много мнений. Вот мой список качеств хорошего объекта.<p>Прежде чем мы начнем говорить о объектах, давайте определим, что такое <em>класс</em>. Это место, где рождаются объекты (также известные как <em>инстанцированные</em>). Основная ответственность класса - <em>конструировать</em> новые объекты по требованию и <em>уничтожать</em> их, когда они больше не используются. Класс знает, как должны выглядеть его потомки и как они должны себя вести. Другими словами, он знает, каким <em>контрактам</em> они должны подчиняться.<p>Иногда я слышу, что классы называют “шаблонами объектов” (например, <a href="https://en.wikipedia.org/wiki/Class_%28computer_programming%29">Википедия так говорит</a>). Это определение неправильное, потому что оно ставит классы в пассивное положение. Данное определение предполагает, что кто-то получит шаблон и создаст объект, используя его. Технически говоря, это может быть верно, но концептуально это неправильно. Никто другой не должен быть вовлечен - есть только класс и его потомки. Объект просит класс создать другой объект, и класс его создает; вот и все. Ruby гораздо лучше выражает эту концепцию, чем Java или C++:<p>Объект <code class="language-plaintext highlighter-rouge">photo</code> создается классом <code class="language-plaintext highlighter-rouge">File</code> (<code class="language-plaintext highlighter-rouge">new</code> является точкой входа в класс). После создания объект действует сам по себе. Он не должен знать, кто его создал и сколько у него есть братьев и сестер в классе. Да, я имею в виду, что <a href="https://ru.wikipedia.org/wiki/Рефлексия_%28программирование%29">рефлексия</a> - ужасная идея, но я расскажу о ней подробнее в одном из следующих постов. Сейчас давайте поговорим об объектах и их лучших и худших сторонах.<p>Прежде всего, объект представляет собой <strong>живой организм</strong>. Более того, объект должен быть <a href="https://en.wikipedia.org/wiki/Anthropomorphism">антропоморфизирован</a>, то есть рассматриваться как человек (или домашнее животное, если вы их больше любите). Это означает, что объект не является <em>структурой данных</em> или набором функций. Вместо этого, он является самостоятельным существом со своим собственным жизненным циклом, своим собственным поведением и своими собственными привычками.<p>Сотрудник, отдел, HTTP-запрос, таблица в MySQL, строка в файле или сам файл являются правильными объектами – потому что они существуют в реальной жизни, даже когда наше программное обеспечение выключено. Более точно, объект является <em>представителем</em> существа реальной жизни. Он является <em>прокси</em> этого существа перед всеми остальными объектами. Без такого существа, очевидно, нет и объекта.<p>В этом примере я запрашиваю у <code class="language-plaintext highlighter-rouge">File</code> конструирование нового объекта <code class="language-plaintext highlighter-rouge">photo</code>, который будет представлять реальный файл на диске. Можно сказать, что файл также является чем-то виртуальным и существует только при включенном компьютере. Я бы согласился и уточнил определение “реальной жизни” следующим образом: это все, что существует помимо области программы, в которой существует объект. Дисковый файл находится вне области нашей программы; поэтому вполне правильно создавать его представителя внутри программы.<p>Контроллер, парсер, фильтр, валидатор, локатор сервисов, синглтон или фабрика <strong>не являются</strong> хорошими объектами (да, большинство паттернов GoF являются анти-паттернами!). Они не существуют отдельно от вашего программного обеспечения, в реальной жизни. Они придуманы только для связывания других объектов. Они искусственные и фальшивые существа. Они ни представляют никого. Серьезно, парсер XML - кого он представляет? Никого.<p>Некоторые из них могут стать хорошими, если изменят свои имена; другие никогда не могут оправдать свое существование. Например, этот парсер XML можно переименовать в “разбираемый XML” и начать представлять XML-документ, который существует вне нашей области.<p>Всегда спрашивайте себя: “Какая реальная сущность находится за моим объектом?” Если вы не можете найти ответ, начните думать о рефакторинге.<p>Хороший объект всегда работает по контрактам. Он ожидает быть нанятым не из-за своих личных достоинств, а потому, что он соблюдает контракты. С другой стороны, когда мы нанимаем объект, мы не должны дискриминировать и ожидать, что определенный объект из определенного класса выполнит работу за нас. Мы должны ожидать, что <em>любой</em> объект сделает то, что говорит наш контракт. Пока объект делает то, что нам нужно, нам не интересно, из какого класса он происходит, его пол или религия.<p>Например, мне нужно показать фотографию на экране. Я хочу, чтобы эта фотография была считана из файла в формате PNG. Я заключаю контракт с объектом из класса <code class="language-plaintext highlighter-rouge">DataFile</code> и прошу его предоставить мне бинарное содержимое этой картинки.<p>Но подождите, мне важно, откуда именно будет получено содержимое - из файла на диске, запроса HTTP или, может быть, документа в Dropbox? На самом деле, это не имеет значения. Мне важно только то, чтобы какой-то объект дал мне массив байт с содержимым PNG. Так что мой контракт будет выглядеть так:<p>Теперь любой объект из любого класса (не только <code class="language-plaintext highlighter-rouge">DataFile</code>) может для меня работать. Ему нужно только следовать договору, реализуя интерфейс <code class="language-plaintext highlighter-rouge">Binary</code>.<p>Правило здесь простое: каждый публичный метод в хорошем объекте должен реализовывать своего аналога из интерфейса. Если ваш объект имеет публичные методы, которые не наследуются от интерфейса, он плохо спроектирован.<p>Здесь есть две практические причины для этого. Во-первых, объект, работающий без контракта, невозможно подделать в модульном тестировании. Во-вторых, объект без контракта невозможно расширить с помощью <a href="https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)">декоратора</a>.<p>Хороший объект всегда должен инкапсулировать что-то, чтобы быть уникальным. Если нет ничего, что можно инкапсулировать, объект может иметь идентичные клонированные версии, что, по моему мнению, плохо. Вот пример плохого объекта, который может иметь клонированные версии:<p>Я могу создать несколько экземпляров класса <code class="language-plaintext highlighter-rouge">HTTPStatus</code>, и все они будут равны друг другу.<p>Очевидно, что утилитарные классы, в которых есть только статические методы, не могут создавать хорошие объекты. Более обще говоря, утилитарные классы не обладают никакими достоинствами, упомянутыми в этой статье, и даже не могут называться “классами”. Они являются просто ужасными нарушителями объектной парадигмы и существуют в современных объектно-ориентированных языках только потому, что их создатели предусмотрели статические методы.<p>Хороший объект никогда не должен изменять своё инкапсулированное состояние. Помните, что объект представляет собой сущность из реальной жизни, и эта сущность должна оставаться неизменной на протяжении всей жизни объекта. Другими словами, объект никогда не должен предавать тех, кого он представляет. Он никогда не должен менять владельцев.<p>Имейте в виду, что неизменяемость не означает, что все методы всегда возвращают одни и те же значения. Вместо этого, хороший неизменяемый объект является очень динамичным. Однако он никогда не изменяет своё внутреннее состояние. Например:<p>Несмотря на то, что метод <code class="language-plaintext highlighter-rouge">read()</code> может возвращать разные значения, объект является неизменяемым. Он указывает на определенную веб-страницу и никогда не будет указывать куда-либо еще. Он никогда не изменит свое инкапсулированное состояние и никогда не предаст URL, который он представляет.<p>Почему неизменяемость является добродетелью? Эта статья подробно объясняет: Объекты должны быть неизменяемыми. В двух словах, неизменяемые объекты лучше, потому что:<ul><li><p>Действительно неизменяемые объекты всегда безопасны для работы с потоками.<li><p>Они помогают избегать временной связности.<li><p>Их использование безопасно (без оборонительных копий).<li><p>Они всегда обладают атомарностью ошибки.<li><p>Они намного проще кэшировать.<li><p>Они предотвращают NULL ссылки.</ul><p>Конечно, хороший объект не имеет сеттеров, которые могут изменить его состояние и заставить его изменить URL. Другими словами, введение метода <code class="language-plaintext highlighter-rouge">setURL()</code> было бы ужасной ошибкой в классе <code class="language-plaintext highlighter-rouge">HTTPStatus</code>.<p>Кроме всего прочего, неизменяемые объекты заставят вас создавать более связанные, надежные и понятные конструкции, как объясняется в этой статье: How Immutability Helps.<p>Статический метод реализует поведение класса, а не объекта. Предположим, у нас есть класс <code class="language-plaintext highlighter-rouge">File</code>, и его потомки имеют метод <code class="language-plaintext highlighter-rouge">size()</code>.<p>Пока все идет хорошо; метод <code class="language-plaintext highlighter-rouge">size()</code> существует из-за контракта <code class="language-plaintext highlighter-rouge">Measurable</code>, и каждый объект класса <code class="language-plaintext highlighter-rouge">File</code> сможет измерить свой размер. Ужасной ошибкой было бы создать этот класс с помощью статического метода (этот дизайн также известен как утилитарный класс и очень популярен в Java, Ruby и почти в каждом ООП языке).<p>Этот дизайн полностью противоречит объектно-ориентированной парадигме. Почему? Потому что статические методы превращают объектно-ориентированное программирование в “классо-ориентированное” программирование. Этот метод <code class="language-plaintext highlighter-rouge">size()</code> предоставляет поведение класса, а не его объектов. Что в этом плохого, вы можете спросить? Почему мы не можем иметь и объекты, и классы как граждан первого класса в нашем коде? Почему у них не могут быть методы и свойства?<p>Проблема заключается в том, что с классо-ориентированным программированием декомпозиция больше не работает. Мы не можем разбить сложную проблему на части, потому что во всей программе существует только один экземпляр класса. Сила ООП заключается в том, что она позволяет использовать объекты как инструмент для разделения областей видимости. Когда я создаю объект внутри метода, он предназначен для моей конкретной задачи. Он полностью изолирован от всех остальных объектов вокруг метода. Этот объект является <em>локальной переменной</em> в области видимости метода. Класс с его статическими методами всегда является <em>глобальной переменной</em>, независимо от того, где я его использую. Из-за этого я не могу изолировать свое взаимодействие с этой переменной от других.<p>Помимо концептуального противоречия объектно-ориентированным принципам, у публичных статических методов есть несколько практических недостатков:<p>Во-первых, их <strong>невозможно замокать</strong> (Ну, вы можете использовать <a href="https://code.google.com/p/powermock/">PowerMock</a>, но это будет самым ужасным решением, которое вы могли принять в проекте на Java… Я сделал это однажды несколько лет назад).<p>Во-вторых, они <strong>не потоко-безопасны</strong> по определению, потому что они всегда работают со статическими переменными, к которым имеют доступ все потоки. Вы можете сделать их потоко-безопасными, но это всегда потребует явной синхронизации.<p>Каждый раз, когда вы видите публичный статический метод, начинайте переписывать его сразу же. Я даже не хочу упоминать о том, насколько ужасны статические (или глобальные) переменные. Я думаю, это просто очевидно.<p>Название объекта должно говорить нам, <strong>что это</strong> за объект, а не <strong>что он делает</strong>, так же, как мы называем объекты в реальной жизни: книга вместо агрегатора страниц, чашка вместо держателя воды, футболка вместо одежды для тела. Конечно, есть исключения, например, принтер или компьютер, но они были изобретены совсем недавно и теми, кто не прочитал эту статью.<p>Например, эти названия говорят нам, кто их владельцы: яблоко, файл, серия HTTP-запросов, сокет, XML-документ, список пользователей, регулярное выражение, целое число, таблица PostgreSQL или Джеффри Лебовски. Объект, названный правильно, всегда можно нарисовать в виде небольшой картинки. Даже регулярное выражение можно нарисовать.<p>Наоборот, вот примеры названий, которые говорят нам, что делают их владельцы: читатель файла, разборщик текста, проверяющий URL, печатник XML, локатор сервиса, синглтон, исполнитель сценария или программист Java. Вы можете нарисовать хотя бы одного из них? Нет, не можете. Эти названия не подходят для хороших объектов. Это ужасные названия, которые приводят к ужасному дизайну.<p>Вообще, стоит избегать названий, оканчивающихся на “-er”—большинство из них плохие.<p>“Какая альтернатива <code class="language-plaintext highlighter-rouge">FileReader</code>?” - слышу я, вы спрашиваете. Какое было бы лучшее название? Давайте посмотрим. У нас уже есть <code class="language-plaintext highlighter-rouge">File</code>, который представляет собой реальный файл на диске. Этого представителя нам недостаточно мощного, потому что он не умеет читать содержимое файла. Мы хотим создать более мощного, который будет обладать этой способностью. Как бы мы его назвали? Помните, что название должно говорить, что он есть, а не что он делает. Что он есть? Он - файл, содержащий данные; не просто файл, как <code class="language-plaintext highlighter-rouge">File</code>, а более сложный, с данными. Что насчет <code class="language-plaintext highlighter-rouge">FileWithData</code> или просто <code class="language-plaintext highlighter-rouge">DataFile</code>?<p>Та же логика должна применяться к остальным названиям. Всегда думайте о <strong>том, что это</strong> за объект, а не о том, что он делает. Давайте давать вашим объектам реальные, значимые названия, а не профессии.<p>Подробнее об этом в статье “Не создавайте объекты, оканчивающиеся на -ER”.<p>Хороший объект создается либо из конечного, либо из абстрактного класса. <code class="language-plaintext highlighter-rouge">Final</code> класс - это тот, который нельзя расширить наследованием. <code class="language-plaintext highlighter-rouge">Абстрактный</code> класс - это тот, у которого нельзя создать экземпляры. Проще говоря, класс должен либо сказать: «Ты никогда не сможешь меня сломать; я для тебя черный ящик», либо «Я уже сломан; сначала почини меня, а потом пользуйся».<p>Здесь нет ничего посередине. Конечный класс - это черный ящик, который нельзя изменить никаким способом. Он работает так, как он работает, и вы либо используете его, либо выбрасываете его. Вы не можете создать другой класс, который унаследует его свойства. Это не разрешено из-за того <code class="language-plaintext highlighter-rouge">final</code> модификатора. Единственный способ расширить такой конечный класс - это через декорацию его потомков. Допустим, у меня есть класс <code class="language-plaintext highlighter-rouge">HTTPStatus</code> (см. выше), и я не люблю его. Хорошо, я люблю его, но он для меня недостаточно мощный. Я хочу, чтобы он выбрасывал исключение, если статус HTTP превышает 400. Я хочу, чтобы его метод <code class="language-plaintext highlighter-rouge">read()</code> делал больше, чем он делает сейчас. Традиционным способом было бы расширить класс и перезаписать его метод:<p>Почему это неправильно? Это очень неправильно, потому что мы рискуем нарушить логику всего родительского класса, переопределяя один из его методов. Помните, что после переопределения метода <code class="language-plaintext highlighter-rouge">read()</code> в дочернем классе все методы родительского класса начинают использовать его новую версию. Мы буквально внедряем новую “реализацию” прямо в класс. Философски говоря, это оскорбление.<p>С другой стороны, чтобы расширить финальный класс, вы должны относиться к нему как к черному ящику и украшать его своей собственной реализацией (так называемый <a href="https://ru.wikipedia.org/wiki/Декоратор_(шаблон_проектирования)">шаблон Декоратор</a>).<p>Убедитесь, что этот класс реализует тот же интерфейс, что и исходный: <code class="language-plaintext highlighter-rouge">Status</code>. Экземпляр <code class="language-plaintext highlighter-rouge">HTTPStatus</code> будет передан ему через конструктор и инкапсулирован. Затем каждый вызов будет перехвачен и реализован по-разному, если это необходимо. В этом дизайне мы рассматриваем исходный объект как черный ящик и никогда не трогаем его внутреннюю логику.<p>Если вы не используете ключевое слово <code class="language-plaintext highlighter-rouge">final</code>, кто угодно (включая вас самого) сможет расширить класс и… обидеть его :( Такой класс без <code class="language-plaintext highlighter-rouge">final</code> является плохим дизайном.<p>Абстрактный класс - это точно противоположный случай - он сообщает нам, что он неполный и мы не можем использовать его “как есть”. Мы должны внедрить нашу собственную реализацию логики в него, но только в те места, которые он разрешает нам трогать. Эти места явно помечены как <code class="language-plaintext highlighter-rouge">abstract</code> методы. Например, наш <code class="language-plaintext highlighter-rouge">HTTPStatus</code> может выглядеть так:<p>Как видите, класс не знает, как точно проверить код HTTP, и он ожидает, что мы внедрим эту логику через наследование и переопределение метода <code class="language-plaintext highlighter-rouge">isValid()</code>. Мы не собираемся обидеть его этим наследованием, так как он защитил все остальные методы с помощью <code class="language-plaintext highlighter-rouge">final</code> (обратите внимание на модификаторы его методов). Таким образом, класс готов к нашему нарушению и отлично защищен от него.<p>В заключение, ваш класс должен быть либо <code class="language-plaintext highlighter-rouge">final</code>, либо <code class="language-plaintext highlighter-rouge">abstract</code> — ничего посередине.<p>Обновление (апрель 2017): Если вы также согласны с тем, что наследование реализации — это зло, все ваши классы должны быть <code class="language-plaintext highlighter-rouge">final</code>.<p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/42 on 2023-12-27 at 04:56</article></div><div class="wrapper"><footer class="footer"><p>&copy; <span itemscope=""itemprop="copyrightHolder"itemtype="http://schema.org/Person"><span itemprop="name">Yegor Bugayenko</span> </span>2014&ndash;<span itemprop="copyrightYear">2023</span></footer></div></section><div class="wrapper unprintable"style="text-align:center;margin-top:2em"><a href="https://www.sixnines.io/h/3ba1652f"><img src="//www.sixnines.io/b/3ba1652f?style=flat"alt="sixnines availability badge"></a>&nbsp; <a href="https://github.com/yegor256/blog/stargazers"><img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square"alt="GitHub stars"></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script><script src="/js/all.js?ca021e3385f"></script><script>var disqus_shortname="yegor256"</script><script id="dsq-count-scr"src="//yegor256.disqus.com/count.js"async="async"></script><script>((e,a,t,g,n,c)=>{e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=+new Date,n=a.createElement(t),c=a.getElementsByTagName(t)[0],n.async=1,n.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(n,c)})(window,document,"script","ga"),ga("create","UA-1963507-32","auto"),ga("send","pageview")</script><script>Cd=document,Cr="&"+Math.random(),Cp="&s=1",Cd.cookie="b=b",Cd.cookie&&(Cp+="&c=1"),Cp+="&t="+(new Date).getTimezoneOffset(),self!=top&&(Cp+="&f=1")</script><script>navigator.javaEnabled()&&(Cp+="&j=1")</script><script>"undefined"!=typeof screen&&(Cp+="&w="+screen.width+"&h="+screen.height+"&d="+(screen.colorDepth||screen.pixelDepth))</script><script>Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+"&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+"' border='0' width='1' height='1'/>")</script><script type="application/ld+json">{ "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] }</script>