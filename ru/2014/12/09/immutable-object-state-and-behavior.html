<!doctypehtml><html xmlns="http://www.w3.org/1999/xhtml"lang="en-US"xml:lang="en-US"itemscope=""itemtype="http://schema.org/WebSite"><meta charset="utf-8"><meta name="description"content="Object state and behavior are two very different things, and confusing the two often leads to incorrect design."><meta name="keywords"content=""><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><meta name="google-site-verification"content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8"><meta name="author"content="Yegor Bugayenko"><meta name="og:site_name"content="Yegor Bugayenko"><meta name="og:type"content="article"><meta name="og:locale"content="en_US"><meta name="twitter:account_id"content="4503599630178231"><meta name="twitter:creator"content="@yegor256"><meta name="twitter:site"content="@yegor256"><meta name="twitter:title"property="og:title"content="How an Immutable Object Can Have State and Behavior?"><meta name="twitter:description"property="og:description"content="Object state and behavior are two very different things, and confusing the two often leads to incorrect design."><meta name="twitter:url"property="og:url"content="https://www.yegor256.com/ru/2014/12/09/immutable-object-state-and-behavior.html"><meta name="telegram:channel"content="AAAAAEJFMRzsRTRxM3ec6A"><link rel="search"type="application/opensearchdescription+xml"href="/opensearch.xml"title="yegor256"><link rel="shortcut icon"href="/favicon.ico?57631a7f582"><link rel="apple-touch-icon"href="/favicon.ico?57631a7f582"><link rel="alternate"type="application/rss+xml"title="RSS for yegor256.com"href="https://www.yegor256.com/rss.xml"><link rel="stylesheet"href="/css/layout.css?57631a7f582"><link rel="stylesheet"href="/css/icons.css?57631a7f582"><link rel="canonical"href="https://www.yegor256.com/ru/2014/12/09/immutable-object-state-and-behavior.html"><title>How an Immutable Object Can Have State and Behavior?</title><div class="wrapper"><aside class="header-toggle unprintable"id="header-toggle"title="Show the menu"onclick='$("#header").show(),$("#header-toggle").hide()'>&#9776;</aside><header class="header"id="header"><div class="face"><a href="/about-me.html#form"class="sub"title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html"style="position:relative"><img src="/images/face-256x256.jpg"class="photo"alt="Yegor Bugayenko"></a></div><nav><ul class="menu social notranslate"><li><a href="https://twitter.com/intent/follow?screen_name=yegor256"rel="nofollow"title="Follow me on Twitter"><i class="icon icon-twitter notranslate"aria-hidden="true"></i></a><li><a href="/rss.xml"rel="nofollow"title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://github.com/yegor256"rel="nofollow"title="My GitHub profile"><i class="icon icon-github notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="http://stackoverflow.com/users/187141/yegor256"rel="nofollow"title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://www.facebook.com/yegor256"rel="nofollow"title="Follow me on Facebook"><i class="icon icon-facebook notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://instagram.com/yegor256"rel="nofollow"title="Follow me on Instagram"><i class="icon icon-instagram notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://www.linkedin.com/in/yegor256"rel="nofollow"title="My LinkedIn profile"><i class="icon icon-linkedin notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://www.youtube.com/c/yegor256?sub_confirmation=1"rel="nofollow"title="My Youtube video channel"><i class="icon icon-youtube notranslate"aria-hidden="true"></i></a><li><a href="https://soundcloud.com/yegor256"rel="nofollow"title="My podcast"><i class="icon icon-podcast notranslate"aria-hidden="true"></i></a><li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721"rel="nofollow"title="My iTunes podcast"><i class="icon icon-itunes notranslate"aria-hidden="true"></i></a><li><a href="https://t.me/yegor256news"rel="nofollow"title="My Telegram public channel"><i class="icon icon-telegram notranslate"aria-hidden="true"></i></a><li><a href="mailto:blog@yegor256.com"rel="nofollow"title="Email me any time"><i class="icon icon-mail notranslate"aria-hidden="true"></i></a></ul><ul class="menu"><li><a href="/"title="Home page">Home</a><li><a href="/best.html"title="Best articles to read">12&#160;Best</a><li><a href="/contents.html"title="The contents of the entire blog">All&#160;392</a><li><a href="/teaching.html"title="My courses and lectures">Teaching</a><li><a href="/talks.html"title="Future and past conference talks">Talks</a><li><a href="/books.html"title="The books I wrote">Books</a><li><a href="/research.html"title="My research directions and progress">Research</a><li><a href="/pets.html"title="My loved pet projects">Pets</a><li><a href="/testimonials.html"title="What some people say about me">Testimonials</a><li><a href="/shift-m.html"title="Audio podcast about project management">Shift-M</a><li><a href="/paintings.html"title="My paintings for sale">Art</a><li><a href="https://ru.yegor256.com/"title="Немного на русском языке о политике в России, Украине и мире">Политика</a></ul></nav><div class="search"><form action="https://www.google.com/search"itemprop="potentialAction"itemscope=""itemtype="http://schema.org/SearchAction"><meta itemprop="target"content="https://www.google.com/search?q={q}"><input name="sitesearch"value="yegor256.com"type="hidden"> <input itemprop="query-input"id="search-query"class="field field-text"required="required"onfocus='$(".google").css("visibility","visible")'name="q"placeholder="Search..."autocomplete="off"> <input type="image"src="/images/google-search-icon.svg"class="google"title="Search via Google"alt="Search via Google"></form></div><div class="hot"><ul></ul></div></header></div><section itemscope=""itemtype="http://schema.org/BlogPosting"><div class="wrapper"><header><h1 itemprop="name headline mainEntityOfPage">How an Immutable Object Can Have State and Behavior?</h1></header><article class="main"itemprop="articleBody"style="font-family:sans-serif;font-size:.9em;line-height:1.2em"><p style="color:#c42c00">The following text is a <em>partial</em> translation of the <a href="https://www.yegor256.com/2014/12/09/immutable-object-state-and-behavior.html">original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:<p>Я часто слышу это возражение против неизменяемых объектов: “Да, они полезны, когда состояние не меняется. Однако в нашем случае мы имеем дело с часто изменяющимися объектами. Мы просто не можем позволить себе создавать новый <code class="language-plaintext highlighter-rouge">документ</code> каждый раз, когда нам нужно только изменить его <code class="language-plaintext highlighter-rouge">заголовок</code>”. Вот где я не согласен: заголовок объекта - <strong>это не состояние</strong> документа, если вам нужно часто его менять. Вместо этого, это <strong>поведение</strong> документа. <code class="language-plaintext highlighter-rouge">Документ</code> может и должен быть неизменяемым, если это хороший объект, даже когда его заголовок часто меняется. Позвольте мне объяснить, как это работает.<p>В основе каждого объекта лежат три элемента: идентичность, состояние и поведение. <em>Идентичность</em> отличает наш <code class="language-plaintext highlighter-rouge">документ</code> от других объектов, <em>состояние</em> - это то, что документ знает о себе (также известное как “инкапсулированное знание”), а <em>поведение</em> - это то, что документ может сделать для нас по запросу. Например, этот документ является изменяемым.<p>Давайте попробуем использовать этот изменяемый объект:<p>Здесь мы создаем два объекта и затем изменяем их инкапсулированные состояния. Очевидно, что <code class="language-plaintext highlighter-rouge">first.equals(second)</code> вернет <code class="language-plaintext highlighter-rouge">false</code>, потому что у этих двух объектов разные идентичности, даже если они инкапсулируют одно и то же состояние.<p>Метод <code class="language-plaintext highlighter-rouge">toString()</code> предоставляет поведение документа - документ может преобразовать себя в строку.<p>Для изменения заголовка документа мы просто вызываем его метод <code class="language-plaintext highlighter-rouge">setTitle()</code> еще раз:<p>Простыми словами, мы можем многократно использовать объект, изменяя его внутреннее состояние. Это быстро и удобно, не так ли? Быстро, да. Удобно, не совсем. Продолжайте чтение.<p>Как я упоминал ранее, неизменяемость является одним из достоинств хорошего объекта и очень важным. Хороший объект является неизменяемым, и хорошее программное обеспечение содержит только неизменяемые объекты. Основное отличие между неизменяемыми и изменяемыми объектами заключается в том, что неизменяемый объект не имеет идентичности, и его состояние никогда не изменяется. Вот неизменяемый вариант того же документа:<p>Этот документ является неизменяемым, и его состояние (<code class="language-plaintext highlighter-rouge">id</code> и <code class="language-plaintext highlighter-rouge">title</code>) является его идентификатором. Давайте посмотрим, как мы можем использовать этот неизменяемый класс (кстати, я использую аннотацию <a href="http://aspects.jcabi.com/annotation-immutable.html"><code class="language-plaintext highlighter-rouge">@Immutable</code></a> из <a href="http://aspects.jcabi.com">jcabi-aspects</a>).<p>Мы уже не можем изменять документ. Когда нам необходимо изменить заголовок, мы должны создать новый документ.<p>Каждый раз, когда мы хотим изменить его инкапсулированное состояние, мы также должны изменить его идентичность, потому что идентичности нет. Состояние - это идентичность. Посмотрите на код метода <code class="language-plaintext highlighter-rouge">equals()</code>, который сравнивает документы по их идентификаторам и заголовкам. Теперь идентичность документа - это его идентификатор и заголовок!<p>Теперь я перехожу к вопросу, с которого мы начали: как насчет производительности и удобства? Мы не хотим изменять весь документ каждый раз, когда нам нужно изменить его заголовок. Если документ достаточно большой, это будет огромная обязанность. Более того, если неизменяемый объект инкапсулирует другие неизменяемые объекты, мы должны изменить всю иерархию даже при изменении только одной строки в одном из них.<p>Ответ прост. Заголовок документа не должен быть частью его <strong>состояния</strong>. Вместо этого, заголовок должен быть его <strong>поведением</strong>. Например, рассмотрим следующее:<p>Концептуально говоря, данный документ действует как прокси реального документа, у которого заголовок хранится где-то - например, в файле. Это то, что хороший объект должен делать - быть прокси реальной сущности. Документ предоставляет две функции: чтение заголовка и сохранение заголовка. Вот как будет выглядеть его интерфейс:<p><code class="language-plaintext highlighter-rouge">title()</code> reads the title of the document and returns it as a <code class="language-plaintext highlighter-rouge">String</code>, and <code class="language-plaintext highlighter-rouge">title(String)</code> saves it back into the document. Imagine a real paper document with a title. You ask an object to read that title from the paper or to erase an existing one and write new text over it. This paper is a “copy” utilized in these methods.<p>Теперь мы можем часто вносить изменения в неизменяемый документ, и документ остается тем же самым. Он не перестает быть неизменяемым, поскольку его состояние (<code class="language-plaintext highlighter-rouge">id</code>) не изменяется. Это тот же самый документ, даже если мы меняем его заголовок, потому что заголовок не является состоянием документа. Это что-то в реальном мире, за пределами документа. Документ - это всего лишь прокси между нами и этим “чем-то”. Чтение и запись заголовка - это <em>поведение</em> документа, а не его состояние.<p>Единственный вопрос, на который у нас все еще нет ответа, - что такое “копия” и что произойдет, если нам нужно сохранить название документа в памяти?<p>Давайте рассмотрим это с точки зрения “объектного мышления”. У нас есть объект <code class="language-plaintext highlighter-rouge">document</code>, который должен представлять сущность из реального мира в объектно-ориентированном мире. Если такая сущность - это файл, мы легко можем реализовать методы <code class="language-plaintext highlighter-rouge">title()</code>. Если такая сущность - это объект Amazon S3, мы также легко реализуем методы чтения и записи названия, сохраняя объект неизменным. Если такая сущность - это веб-страница, у нас нет проблем с реализацией методов чтения или записи названия, сохраняя объект неизменным. У нас нет проблем, пока существует реальный документ в мире и у него есть своя собственная идентичность. Наши методы чтения и записи названия будут взаимодействовать с этим реальным документом и извлекать или обновлять его название.<p>Проблемы возникают, когда такая сущность не существует в реальном мире. В этом случае нам нужно создать изменяемое свойство объекта под названием <code class="language-plaintext highlighter-rouge">title</code>, читать его с помощью <code class="language-plaintext highlighter-rouge">title()</code>, и изменять с помощью <code class="language-plaintext highlighter-rouge">title(String)</code>. Но объект неизменяем, поэтому мы не можем иметь изменяемое свойство в нем - по определению! Что мы делаем?<p>Как это может быть, что наш объект не представляет сущность реального мира? Помните, что <em>реальный мир</em> - это все, что находится вокруг живой среды объекта. Возможно ли, что объект не представляет никого и действует сам по себе? Нет, это невозможно. Каждый объект является представителем сущности реального мира. Так кого он представляет, если мы хотим сохранить <code class="language-plaintext highlighter-rouge">title</code> внутри него и у нас нет никакого файла или HTTP-страницы за объектом?<p>Он представляет <em>компьютерную память</em>.<p>Заголовок неизменного документа №50 “Как приготовить гриль-сэндвич” хранится в памяти, занимая 23 байта пространства. Документ должен знать, где хранятся эти байты, и он должен иметь возможность прочитать их и заменить на что-то другое. Эти 23 байта - это сущность реального мира, которую представляет объект. Байты не имеют никакого отношения к состоянию объекта. Они являются <em>изменяемой</em> сущностью реального мира, подобной файлу, HTTP-странице или объекту Amazon S3.<p>К сожалению, Java (и многие другие современные языки) не позволяют прямой доступ к компьютерной памяти. Вот как мы бы разработали наш класс, если бы такой прямой доступ был возможен:<p>Класс <code class="language-plaintext highlighter-rouge">Memory</code> будет реализован нативно в JDK, и все остальные классы будут неизменяемыми. Класс <code class="language-plaintext highlighter-rouge">Memory</code> будет иметь прямой доступ к куче памяти и будет отвечать за операции <a href="https://ru.wikipedia.org/wiki/Malloc"><code class="language-plaintext highlighter-rouge">malloc</code> и <code class="language-plaintext highlighter-rouge">free</code></a> на уровне операционной системы. Наличие такого класса позволит сделать все классы Java неизменяемыми, включая <code class="language-plaintext highlighter-rouge">StringBuffer</code>, <code class="language-plaintext highlighter-rouge">ByteArrayOutputStream</code> и т. д.<p>Класс <code class="language-plaintext highlighter-rouge">Memory</code> явно подчеркнет миссию объекта в программном обеспечении, которой является <em>анимация данных</em>. Объект не хранит данные; он анимирует их. Данные существуют где-то и являются анемичными, статическими, неподвижными и т. д. Данные являются <strong>мертвыми</strong>, в то время как объект жив. Роль объекта состоит в том, чтобы оживить кусок данных, <em>анимировать</em> его, но не стать самим куском данных. Объекту нужно некоторое знание, чтобы получить доступ к этому мертвому куску данных. Объекту может понадобиться уникальный ключ базы данных, HTTP-адрес, имя файла или адрес памяти, чтобы найти данные и оживить их. Но объект никогда не должен думать о себе как о данных.<p>К сожалению, у нас нет такого класса, представляющего память, в Java, Ruby, JavaScript, Python, PHP и многих других языках высокого уровня. Кажется, разработчики языков не поняли идею живых объектов против мертвых данных, что печально. Нам приходится смешивать данные с состоянием объектов, используя те же языковые конструкции: переменные объектов и свойства. Может быть, когда-нибудь у нас будет такой класс <code class="language-plaintext highlighter-rouge">Memory</code> в Java и других языках, но пока у нас есть несколько вариантов.<p><strong>Использовать C++</strong>. В C++ и подобных низкоуровневых языках можно иметь прямой доступ к памяти и работать с данными в памяти так же, как мы работаем с данными в файле или через HTTP. В C++ мы можем создать этот класс <code class="language-plaintext highlighter-rouge">Memory</code> и использовать его точно так же, как мы объяснили выше.<p><strong>Использовать массивы</strong>. В Java массив является структурой данных с уникальным свойством — его можно изменять при объявлении как <code class="language-plaintext highlighter-rouge">final</code>. Вы можете использовать массив байтов как изменяемую структуру данных внутри неизменяемого объекта. Это заменительное решение, которое концептуально напоминает класс <code class="language-plaintext highlighter-rouge">Memory</code>, но является более примитивным.<p><strong>Избегайте данных в памяти</strong>. Старайтесь избегать данных в памяти насколько возможно. В некоторых областях это легко сделать, например, в веб-приложениях, обработке файлов, адаптерах ввода-вывода и т. д. Однако в других областях это намного сложнее. Например, в играх, алгоритмах обработки данных и графическом интерфейсе большая часть объектов анимируется данными в памяти, потому что память - это единственный ресурс, который у них есть. В этом случае без класса <code class="language-plaintext highlighter-rouge">Memory</code> вы оказываетесь с изменяемыми объектами :( Нет обходного пути.<p>Подводя итог, не забывайте, что объект является <strong>аниматором</strong> данных. Он использует свои инкапсулированные знания, чтобы получить доступ к данным. Независимо от того, где хранятся данные - в файле, через HTTP или в памяти - концептуально они очень отличаются от состояния объекта, даже если они могут выглядеть очень похожими.<p>Хороший объект является неизменяемым аниматором изменяемых данных. Несмотря на то, что он неизменяемый, а данные изменяемые, он живой, а данные мертвы в рамках среды жизни объекта.<p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/42 on 2023-12-05 at 21:24</article></div><div class="wrapper"><footer class="footer"><p>&copy; <span itemscope=""itemprop="copyrightHolder"itemtype="http://schema.org/Person"><span itemprop="name">Yegor Bugayenko</span> </span>2014&ndash;<span itemprop="copyrightYear">2023</span></footer></div></section><div class="wrapper unprintable"style="text-align:center;margin-top:2em"><a href="https://www.sixnines.io/h/3ba1652f"><img src="//www.sixnines.io/b/3ba1652f?style=flat"alt="sixnines availability badge"></a>&nbsp; <a href="https://github.com/yegor256/blog/stargazers"><img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square"alt="GitHub stars"></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script><script src="/js/all.js?57631a7f582"></script><script>var disqus_shortname="yegor256"</script><script id="dsq-count-scr"src="//yegor256.disqus.com/count.js"async="async"></script><script>((e,a,t,g,n,c)=>{e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=+new Date,n=a.createElement(t),c=a.getElementsByTagName(t)[0],n.async=1,n.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(n,c)})(window,document,"script","ga"),ga("create","UA-1963507-32","auto"),ga("send","pageview")</script><script>Cd=document,Cr="&"+Math.random(),Cp="&s=1",Cd.cookie="b=b",Cd.cookie&&(Cp+="&c=1"),Cp+="&t="+(new Date).getTimezoneOffset(),self!=top&&(Cp+="&f=1")</script><script>navigator.javaEnabled()&&(Cp+="&j=1")</script><script>"undefined"!=typeof screen&&(Cp+="&w="+screen.width+"&h="+screen.height+"&d="+(screen.colorDepth||screen.pixelDepth))</script><script>Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+"&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+"' border='0' width='1' height='1'/>")</script><script type="application/ld+json">{ "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] }</script>