<!doctypehtml><html xmlns="https://www.w3.org/1999/xhtml"lang="en-US"xml:lang="en-US"itemscope=""itemtype="http://schema.org/WebSite"><meta charset="utf-8"><meta name="description"content="Object-relational mapping is a design pattern that violates encapsulation, one of the fundamental principles of OOP, but what is a possible alternative to it?"><meta name="keywords"content=""><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><meta name="google-site-verification"content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8"><meta name="author"content="Yegor Bugayenko"><meta name="og:site_name"content="Yegor Bugayenko"><meta name="og:type"content="article"><meta name="og:locale"content="en_US"><meta name="twitter:account_id"content="4503599630178231"><meta name="twitter:creator"content="@yegor256"><meta name="twitter:site"content="@yegor256"><meta name="twitter:title"property="og:title"content="ORM Is an Offensive Anti-Pattern"><meta name="twitter:description"property="og:description"content="Object-relational mapping is a design pattern that violates encapsulation, one of the fundamental principles of OOP, but what is a possible alternative to it?"><meta name="twitter:url"property="og:url"content="https://www.yegor256.com/ru/2014/12/01/orm-offensive-anti-pattern.html"><meta name="telegram:channel"content="AAAAAEJFMRzsRTRxM3ec6A"><link rel="search"type="application/opensearchdescription+xml"href="/opensearch.xml"title="yegor256"><link rel="shortcut icon"href="/favicon.ico?f9162203ae1"><link rel="apple-touch-icon"href="/favicon.ico?f9162203ae1"><link rel="alternate"type="application/rss+xml"title="RSS for yegor256.com"href="https://www.yegor256.com/rss.xml"><link rel="stylesheet"href="/css/layout.css?f9162203ae1"><link rel="stylesheet"href="/css/icons.css?f9162203ae1"><link rel="canonical"href="https://www.yegor256.com/ru/2014/12/01/orm-offensive-anti-pattern.html"><title>ORM Is an Offensive Anti-Pattern</title><div class="wrapper"><aside class="header-toggle unprintable"id="header-toggle"title="Show the menu"onclick='$("#header").show(),$("#header-toggle").hide()'>&#9776;</aside><header class="header"id="header"><div class="face"><a href="/about-me.html#form"class="sub"title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html"style="position:relative"><img src="/images/santa-hat.svg"alt="Santa hat"style="position:absolute;width:115px;left:-30px;top:-120px"> <img src="/images/face-256x256.jpg"class="photo"alt="Yegor Bugayenko"></a></div><nav><ul class="menu social notranslate"><li><a href="https://twitter.com/intent/follow?screen_name=yegor256"rel="nofollow"title="Follow me on Twitter"><i class="icon icon-twitter notranslate"aria-hidden="true"></i></a><li><a href="/rss.xml"rel="nofollow"title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://github.com/yegor256"rel="nofollow"title="My GitHub profile"><i class="icon icon-github notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="http://stackoverflow.com/users/187141/yegor256"rel="nofollow"title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://www.facebook.com/yegor256"rel="nofollow"title="Follow me on Facebook"><i class="icon icon-facebook notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://instagram.com/yegor256"rel="nofollow"title="Follow me on Instagram"><i class="icon icon-instagram notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://www.linkedin.com/in/yegor256"rel="nofollow"title="My LinkedIn profile"><i class="icon icon-linkedin notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://www.youtube.com/c/yegor256?sub_confirmation=1"rel="nofollow"title="My Youtube video channel"><i class="icon icon-youtube notranslate"aria-hidden="true"></i></a><li><a href="https://soundcloud.com/yegor256"rel="nofollow"title="My podcast"><i class="icon icon-podcast notranslate"aria-hidden="true"></i></a><li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721"rel="nofollow"title="My iTunes podcast"><i class="icon icon-itunes notranslate"aria-hidden="true"></i></a><li><a href="https://t.me/yegor256news"rel="nofollow"title="My Telegram public channel"><i class="icon icon-telegram notranslate"aria-hidden="true"></i></a><li><a href="mailto:blog@yegor256.com"rel="nofollow"title="Email me any time"><i class="icon icon-mail notranslate"aria-hidden="true"></i></a></ul><ul class="menu"><li><a href="/"title="Home page">Home</a><li><a href="/best.html"title="Best articles to read">12&#160;Best</a><li><a href="/contents.html"title="The contents of the entire blog">All&#160;395</a><li><a href="/teaching.html"title="My courses and lectures">Teaching</a><li><a href="/talks.html"title="Future and past conference talks">Talks</a><li><a href="/books.html"title="The books I wrote">Books</a><li><a href="/research.html"title="My research directions and progress">Research</a><li><a href="/pets.html"title="My loved pet projects">Pets</a><li><a href="/testimonials.html"title="What some people say about me">Testimonials</a><li><a href="/shift-m.html"title="Audio podcast about project management">Shift-M</a><li><a href="/paintings.html"title="My paintings for sale">Art</a><li><a href="https://ru.yegor256.com/"title="Немного на русском языке о политике в России, Украине и мире">Политика</a></ul></nav><div class="search"><form action="https://www.google.com/search"itemprop="potentialAction"itemscope=""itemtype="http://schema.org/SearchAction"><meta itemprop="target"content="https://www.google.com/search?q={q}"><input name="sitesearch"value="yegor256.com"type="hidden"> <input itemprop="query-input"id="search-query"class="field field-text"required="required"onfocus='$(".google").css("visibility","visible")'name="q"placeholder="Search..."autocomplete="off"> <input type="image"src="/images/google-search-icon.svg"class="google"title="Search via Google"alt="Search via Google"></form></div><div class="hot"><ul></ul></div></header></div><section itemscope=""itemtype="http://schema.org/BlogPosting"><div class="wrapper"><header><h1 itemprop="name headline mainEntityOfPage">ORM Is an Offensive Anti-Pattern</h1></header><article class="main"itemprop="articleBody"style="font-family:sans-serif;font-size:.9em;line-height:1.2em"><p style="color:#c42c00">The following text is a <em>partial</em> translation of the <a href="https://www.yegor256.com/2014/12/01/orm-offensive-anti-pattern.html">original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:<p>TL;DR ORM - ужасный антипаттерн, который нарушает все принципы объектно-ориентированного программирования, разрушая объекты и превращая их в глупые и пассивные наборы данных. Нет никаких оправданий для существования ORM в любом приложении, будь то небольшое веб-приложение или корпоративная система с тысячами таблиц и манипуляций CRUD с ними. Какова альтернатива? <strong>Объекты, говорящие на SQL</strong>.<p><a href="https://ru.wikipedia.org/wiki/Отображение_объектно-реляционных_данных">Отображение объектно-реляционных данных</a> (ORM) - это техника (также известная как паттерн проектирования), позволяющая получать доступ к реляционной базе данных из объектно-ориентированного языка программирования (например, Java). Существует множество реализаций ORM практически на любом языке программирования, например: <a href="http://hibernate.org/orm/">Hibernate</a> для Java, ActiveRecord для Ruby on Rails, <a href="https://www.doctrine-project.org/">Doctrine</a> для PHP и <a href="https://www.sqlalchemy.org/">SQLAlchemy</a> для Python. В Java даже существует стандартизированный дизайн ORM под названием <a href="https://en.wikipedia.org/wiki/Java_Persistence_API">JPA</a>.<p>Давайте для начала рассмотрим, как работает ORM, на примере. Для этого воспользуемся языком Java, СУБД PostgreSQL и Hibernate. Предположим, у нас есть одна таблица в базе данных с названием <code class="language-plaintext highlighter-rouge">post</code>:<p>Теперь мы хотим выполнять CRUD-манипуляции с этой таблицей из нашего Java-приложения (CRUD означает создание, чтение, обновление и удаление). Сначала мы должны создать класс <code class="language-plaintext highlighter-rouge">Post</code> (простите, что он такой длинный, но это лучшее, что я могу сделать).<p>Перед любой операцией с Hibernate нам необходимо создать фабрику сессий.<p>Этот завод будет предоставлять нам «сеансы» каждый раз, когда мы захотим манипулировать объектами <code class="language-plaintext highlighter-rouge">Post</code>. Каждая манипуляция с сеансом должна быть обернута в этот блок кода:<p>Когда сеанс готов, вот как мы получаем список всех сообщений из этой таблицы базы данных:<p>Думаю, здесь понятно, что происходит. Hibernate - это большой и мощный движок, который создает подключение к базе данных, выполняет необходимые запросы SQL <code class="language-plaintext highlighter-rouge">SELECT</code> и извлекает данные. Затем он создает экземпляры класса <code class="language-plaintext highlighter-rouge">Post</code> и заполняет их данными. Когда объект приходит к нам, он заполнен данными, и мы должны использовать геттеры, чтобы их извлечь, как в примере с <code class="language-plaintext highlighter-rouge">getTitle()</code> выше.<p>Когда мы хотим выполнить обратную операцию и отправить объект в базу данных, мы делаем все то же самое, но в обратном порядке. Мы создаем экземпляр класса <code class="language-plaintext highlighter-rouge">Post</code>, заполняем его данными и просим Hibernate сохранить его.<p>Вот как работает практически каждый ORM. Основной принцип всегда один и тот же - ORM объекты являются анемичными оболочками с данными. Мы общаемся с ORM фреймворком, а фреймворк общается с базой данных. Объекты только помогают нам отправлять наши запросы в ORM фреймворк и понимать его ответ. Помимо геттеров и сеттеров, объекты не имеют других методов. Они даже не знают, из какой базы данных они были получены.<p>Вот как работает объектно-реляционное отображение.<p>Что не так с этим, вы можете спросить? Все!<p>Серьезно, что не так? Hibernate уже более 10 лет является одной из самых популярных библиотек Java. Почти каждое приложение с интенсивным использованием SQL в мире использует его. Каждый учебник по Java упоминает Hibernate (или, возможно, <a href="https://en.wikipedia.org/wiki/List_of_object-relational_mapping_software">другую ORM</a> типа TopLink или OpenJPA) для приложений, связанных с базой данных. Это стандарт <em>de-facto</em>, и тем не менее я говорю, что это неправильно? Да.<p>Я утверждаю, что сама идея ORM неправильна. Ее изобретение, возможно, было второй большой ошибкой в ООП после NULL-ссылки.<p>На самом деле, я не единственный, кто говорит нечто подобное, и определенно не первый. Многое на эту тему уже было опубликовано очень уважаемыми авторами, включая <a href="https://martinfowler.com/bliki/OrmHate.html">OrmHate</a> Мартина Фаулера (не против ORM, но все равно стоит упомянуть), <a href="http://blog.codinghorror.com/object-relational-mapping-is-the-vietnam-of-computer-science/">Object-Relational Mapping Is the Vietnam of Computer Science</a> Джеффа Этвуда, <a href="http://blogs.tedneward.com/post/the-vietnam-of-computer-science/">The Vietnam of Computer Science</a> Теда Ньюарда, <a href="http://seldo.com/weblog/2011/08/11/orm_is_an_antipattern">ORM Is an Anti-Pattern</a> Лори Восса и многих других.<p>Однако мой аргумент отличается от того, что они говорят. Несмотря на то, что их причины являются практическими и обоснованными, такими как “ORM медленный” или “обновления базы данных сложны”, они упускают основной момент. Вы можете увидеть очень хороший и практический ответ на эти практические аргументы, данной Божидаром Божановым в его блоге <a href="http://techblog.bozho.net/orm-haters-dont-get-it/">ORM Haters Don’t Get It</a>.<p>Основной момент заключается в том, что ORM, вместо инкапсуляции взаимодействия с базой данных внутри объекта, извлекает его, буквально разрывая солидный и цельный живой организм. Одна часть объекта хранит данные, а другая, реализованная внутри движка ORM (фабрика сессий), знает, как работать с этими данными и передает их в реляционную базу данных. Посмотрите на эту картину; она иллюстрирует, что делает ORM.<p>Я, как читатель постов, должен иметь дело с двумя компонентами: 1) ORM и 2) “обрезанным” объектом, который мне возвращается. Поведение, с которым я взаимодействую, должно обеспечиваться через единую точку входа, которой является объект в ООП. В случае ORM я получаю это поведение через <strong>две</strong> точки входа - движок ORM и “вещь”, которую мы даже не можем назвать объектом.<p>Из-за этого ужасного и оскорбительного нарушения объектно-ориентированной парадигмы у нас уже есть много практических проблем, упомянутых в уважаемых изданиях. Я могу добавить только несколько.<p><strong>SQL не скрыт</strong>. Пользователи ORM должны использовать SQL (или его диалект, например <a href="https://docs.jboss.org/hibernate/orm/3.3/reference/en/html/queryhql.html">HQL</a>). Посмотрите на приведенный выше пример; мы вызываем <code class="language-plaintext highlighter-rouge">session.createQuery("FROM Post")</code>, чтобы получить все сообщения. Несмотря на то, что это не SQL, оно очень похоже на него. Таким образом, реляционная модель не инкапсулирована внутри объектов. Вместо этого она выставлена на все приложение. Каждый, с каждым объектом, неизбежно должен иметь дело с реляционной моделью, чтобы получить или сохранить что-то. Таким образом, ORM не скрывает и не оборачивает SQL, а загрязняет всё приложение им.<p><strong>Трудно тестировать</strong>. Когда какой-то объект работает со списком сообщений, ему нужно иметь дело с экземпляром <code class="language-plaintext highlighter-rouge">SessionFactory</code>. Как мы можем замокать это зависимость? Мы должны создать его мок? Насколько сложна эта задача? Посмотрите на приведенный выше код, и вы поймете, насколько громоздким и трудоемким будет такой модульный тест. Вместо этого мы можем написать интеграционные тесты и подключить всё приложение к тестовой версии PostgreSQL. В этом случае нет необходимости замокать <code class="language-plaintext highlighter-rouge">SessionFactory</code>, но такие тесты будут довольно медленными, и, что еще более важно, наши объекты, не имеющие никакого отношения к базе данных, будут тестироваться на экземпляре базы данных. Ужасный дизайн.<p>Еще раз, позвольте мне повторить. Практические проблемы ORM - это всего лишь последствия. Основным недостатком является то, что ORM разрывает объекты, ужасно и оскорбительно нарушая саму идею того, что такое объект.<p>Что же является альтернативой? Позвольте мне показать это на примере. Давайте попробуем спроектировать класс <code class="language-plaintext highlighter-rouge">Post</code> по-своему. Нам придется разделить его на два класса: <code class="language-plaintext highlighter-rouge">Post</code> и <code class="language-plaintext highlighter-rouge">Posts</code>, единственное и множественное число. Я уже упоминал в одной из своих предыдущих статей, что хороший объект всегда является абстракцией реальной сущности. Вот как это принцип работает на практике. У нас есть две сущности: таблица базы данных и строка таблицы. Поэтому мы создадим два класса: <code class="language-plaintext highlighter-rouge">Posts</code> будет представлять таблицу, а <code class="language-plaintext highlighter-rouge">Post</code> будет представлять строку.<p>Как я также упоминал в той статье, каждый объект должен работать по контракту и реализовывать интерфейс. Давайте начнем наше проектирование с двух интерфейсов. Конечно, наши объекты будут неизменяемыми. Вот как будет выглядеть <code class="language-plaintext highlighter-rouge">Posts</code>:<p>Вот как будет выглядеть отдельный <code class="language-plaintext highlighter-rouge">Post</code>:<p>Вот как мы будем перечислять все сообщения в таблице базы данных:<p>Вот как мы будем создавать новый пост:<p>Как видите, у нас теперь есть настоящие объекты. Они отвечают за все операции и идеально скрывают свои детали реализации. Нет никаких транзакций, сессий или фабрик. Мы даже не знаем, общаются ли эти объекты с PostgreSQL или хранят все данные в текстовых файлах. Все, что нам нужно от <code class="language-plaintext highlighter-rouge">Posts</code>, это возможность перечислить все сообщения для нас и создать новое. Детали реализации идеально скрыты внутри. Теперь давайте посмотрим, как мы можем реализовать эти два класса.<p>Я собираюсь использовать <a href="https://jdbc.jcabi.com">jcabi-jdbc</a> как обертку для JDBC, но вы можете использовать что-то другое, например <a href="https://www.jooq.org">jOOQ</a> или просто JDBC, если вам нравится. Это не имеет особого значения. Важно, чтобы ваши взаимодействия с базой данных были скрыты внутри объектов. Давайте начнем с <code class="language-plaintext highlighter-rouge">Posts</code> и реализуем его в классе <code class="language-plaintext highlighter-rouge">PgPosts</code> (“pg” означает PostgreSQL):<p>Далее, давайте реализуем интерфейс <code class="language-plaintext highlighter-rouge">Post</code> в классе <code class="language-plaintext highlighter-rouge">PgPost</code>:<p>Вот как будет выглядеть полная сценарий взаимодействия с базой данных с использованием только что созданных классов:<p>Вы можете увидеть полный практический пример <a href="https://github.com/aintshy/hub/tree/0.7.2/src/main/java/com/aintshy/pgsql">здесь</a>. Это веб-приложение с открытым исходным кодом, которое работает с PostgreSQL с использованием точно такого же подхода, как объяснено выше - объектов, говорящих на SQL.<p>Я слышу, как вы кричите: “А что насчет производительности?” В том скрипте, который находится немного выше, мы делаем много избыточных обращений к базе данных. Сначала мы извлекаем идентификаторы записей с помощью <code class="language-plaintext highlighter-rouge">SELECT id</code>, а затем, чтобы получить их заголовки, мы делаем дополнительный запрос <code class="language-plaintext highlighter-rouge">SELECT title</code> для каждой записи. Это неэффективно, или, проще говоря, слишком медленно.<p>Не беспокойтесь; это объектно-ориентированное программирование, что означает, что оно гибкое! Давайте создадим декоратор <code class="language-plaintext highlighter-rouge">PgPost</code>, который будет принимать все данные в своем конструкторе и кэшировать их внутренне навсегда:<p>Обратите внимание: этот декоратор ничего не знает о PostgreSQL или JDBC. Он просто декорирует объект типа <code class="language-plaintext highlighter-rouge">Post</code> и предварительно кэширует дату и заголовок. Как обычно, этот декоратор также является неизменяемым.<p>Теперь давайте создадим другую реализацию <code class="language-plaintext highlighter-rouge">Posts</code>, которая будет возвращать “константные” объекты.<p>Теперь все сообщения, возвращаемые методом <code class="language-plaintext highlighter-rouge">iterate()</code> этого нового класса, предварительно оснащены датами и заголовками, полученными в одном проходе к базе данных.<p>Используя декораторы и несколько реализаций одного и того же интерфейса, вы можете составлять любую функциональность, которую пожелаете. Самое важное здесь - то, что при расширении функциональности сложность дизайна не возрастает, потому что классы не увеличиваются в размере. Вместо этого мы вводим новые классы, которые остаются согласованными и надежными, потому что они маленькие.<p>Каждый объект должен обрабатывать свои собственные транзакции и инкапсулировать их так же, как запросы <code class="language-plaintext highlighter-rouge">SELECT</code> или <code class="language-plaintext highlighter-rouge">INSERT</code>. Это приведет к вложенным транзакциям, что является вполне нормальным, при условии, что сервер базы данных их поддерживает. Если такой поддержки нет, создайте объект транзакции, распространяющийся на всю сессию, который будет принимать “вызываемый” класс. Например:<p>Затем, когда вы хотите объединить несколько операций с объектами в одну транзакцию, сделайте это следующим образом:<p>Этот код создаст новый пост и оставит комментарий к нему. Если один из вызовов не выполнится успешно, весь транзакционный процесс будет отменен.<p>Мне кажется, что этот подход имеет объектно-ориентированное представление. Я называю его “объекты, говорящие на SQL”, потому что они знают, как общаться с базой данных на SQL-языке. Это их навык, полностью инкапсулированный внутри их границ.<p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/42 on 2024-01-09 at 18:05</article></div><div class="wrapper"><footer class="footer"><p>&copy; <span itemscope=""itemprop="copyrightHolder"itemtype="http://schema.org/Person"><span itemprop="name">Yegor Bugayenko</span> </span>2014&ndash;<span itemprop="copyrightYear">2024</span></footer></div></section><div class="wrapper unprintable"style="text-align:center;margin-top:2em"><a href="https://www.sixnines.io/h/3ba1652f"><img src="//www.sixnines.io/b/3ba1652f?style=flat"alt="sixnines availability badge"></a>&nbsp; <a href="https://github.com/yegor256/blog/stargazers"><img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square"alt="GitHub stars"></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script><script src="/js/all.js?f9162203ae1"></script><script>var disqus_shortname="yegor256"</script><script id="dsq-count-scr"src="//yegor256.disqus.com/count.js"async="async"></script><script>((e,a,t,g,n)=>{e.GoogleAnalyticsObject="ga",e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=+new Date,g=a.createElement(t),n=a.getElementsByTagName(t)[0],g.async=1,g.src="//www.google-analytics.com/analytics.js",n.parentNode.insertBefore(g,n)})(window,document,"script"),ga("create","UA-1963507-32","auto"),ga("send","pageview")</script><script>Cd=document,Cr="&"+Math.random(),Cp="&s=1",Cd.cookie="b=b",Cd.cookie&&(Cp+="&c=1"),Cp+="&t="+(new Date).getTimezoneOffset(),self!=top&&(Cp+="&f=1")</script><script>navigator.javaEnabled()&&(Cp+="&j=1")</script><script>"undefined"!=typeof screen&&(Cp+="&w="+screen.width+"&h="+screen.height+"&d="+(screen.colorDepth||screen.pixelDepth))</script><script>Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+"&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+"' border='0' width='1' height='1'/>")</script><script type="application/ld+json">{ "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] }</script>