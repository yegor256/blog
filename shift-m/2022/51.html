<!doctypehtml><html xmlns="https://www.w3.org/1999/xhtml"lang="en-US"xml:lang="en-US"itemscope=""itemtype="http://schema.org/WebSite"><meta charset="utf-8"><meta name="description"content="Michael Kay is the editor of the W3C XSLT 2.0 and 3.0 language specifications and the developer of the Saxon XSLT and XQuery processing software."><meta name="keywords"content="management podcast, podcast, podcast programming, podcast software management, project management podcast"><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><meta name="google-site-verification"content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8"><meta name="author"content="Yegor Bugayenko"><meta name="article:published_time"content="2022-01-13 12:00:00 +0000"><meta name="yandex-verification"content="7d2a0afee14d72bc"><meta name="og:site_name"content="Yegor Bugayenko"><meta name="og:type"content="article"><meta name="og:locale"content="en_US"><meta name="twitter:account_id"content="4503599630178231"><meta name="twitter:creator"content="@yegor256"><meta name="twitter:site"content="@yegor256"><meta name="twitter:title"property="og:title"content="Shift-M/51"><meta name="twitter:description"property="og:description"content="Michael Kay is the editor of the W3C XSLT 2.0 and 3.0 language specifications and the developer of the Saxon XSLT and XQuery processing software."><meta name="twitter:url"property="og:url"content="https://www.yegor256.com/shift-m/2022/51.html"><meta name="telegram:channel"content="AAAAAEJFMRzsRTRxM3ec6A"><link rel="search"type="application/opensearchdescription+xml"href="/opensearch.xml"title="yegor256"><link rel="icon"href="/favicon.ico?3650590"type="image/x-icon"><link rel="shortcut icon"href="/favicon.ico?3650590"><link rel="apple-touch-icon"href="/favicon.ico?3650590"><link rel="alternate"type="application/rss+xml"title="RSS for yegor256.com"href="https://www.yegor256.com/rss.xml"><link rel="stylesheet"href="/css/layout.css?3650590"><link rel="stylesheet"href="/css/icons.css?3650590"><link rel="canonical"href="https://www.yegor256.com/shift-m/2022/51.html"><title>Shift-M/51</title><meta name="og:image"content="https://www.yegor256.com/images/andreea/podcast.png"><meta name="twitter:image"content="https://www.yegor256.com/images/andreea/podcast.png"><meta name="og:image:width"content="1280"><meta name="twitter:image:width"content="1280"><meta name="og:image:height"content="730"><meta name="twitter:image:height"content="730"><meta name="twitter:card"content="summary_large_image"><meta name="twitter:image:alt"content="Main picture"><div class="wrapper"><aside class="header-toggle unprintable"id="header-toggle"title="Show the menu"onclick='$("#header").show(),$("#header-toggle").hide()'>&#9776;</aside><header class="header"id="header"><div class="face"><a href="/about-me.html#form"class="sub"title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html"style="position:relative"><img src="/images/face-256x256.jpg"class="photo"alt="Yegor Bugayenko"></a></div><nav><ul class="menu social notranslate"><li><a href="https://twitter.com/intent/follow?screen_name=yegor256"rel="nofollow"title="Follow me on Twitter"><i class="icon icon-twitter notranslate"aria-hidden="true"></i></a><li><a href="/rss.xml"rel="nofollow"title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://github.com/yegor256"rel="nofollow"title="My GitHub profile"><i class="icon icon-github notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="http://stackoverflow.com/users/187141/yegor256"rel="nofollow"title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://www.facebook.com/yegor256"rel="nofollow"title="Follow me on Facebook"><i class="icon icon-facebook notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://instagram.com/yegor256"rel="nofollow"title="Follow me on Instagram"><i class="icon icon-instagram notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://www.linkedin.com/in/yegor256"rel="nofollow"title="My LinkedIn profile"><i class="icon icon-linkedin notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://www.youtube.com/c/yegor256?sub_confirmation=1"rel="nofollow"title="My Youtube video channel"><i class="icon icon-youtube notranslate"aria-hidden="true"></i></a><li><a href="https://soundcloud.com/yegor256"rel="nofollow"title="My podcast"><i class="icon icon-podcast notranslate"aria-hidden="true"></i></a><li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721"rel="nofollow"title="My iTunes podcast"><i class="icon icon-itunes notranslate"aria-hidden="true"></i></a><li><a href="https://t.me/yegor256news"rel="nofollow"title="My Telegram public channel"><i class="icon icon-telegram notranslate"aria-hidden="true"></i></a><li><a href="mailto:blog@yegor256.com"rel="nofollow"title="Email me any time"><i class="icon icon-mail notranslate"aria-hidden="true"></i></a></ul><ul class="menu"><li><a href="/"title="Home page">Home</a><li><a href="/best.html"title="Best articles to read">12&#160;Best</a><li><a href="/contents.html"title="The contents of the entire blog">All&#160;484</a><li><a href="/teaching.html"title="My courses and lectures">Teaching</a><li><a href="/talks.html"title="Future and past conference talks">Talks</a><li><a href="/books.html"title="The books I wrote">Books</a><li><a href="/research.html"title="My research directions and progress">Research</a><li><a href="/pets.html"title="My loved pet projects">Pets</a><li><a href="/trainings.html"title="On-site trainings">Trainings</a><li><a href="https://www.iccq.ru"title="International Conference on Code Quality">ICCQ</a><li><a href="https://www.kaicode.org"title="Open Source Festival">KaiCode</a><li><a href="/testimonials.html"title="What some people say about me">Testimonials</a><li><a href="/shift-m.html"title="Audio podcast about project management">Shift-M</a><li><a href="/paintings.html"title="My paintings for sale">Art</a></ul></nav><div class="search"><form action="https://www.google.com/search"itemprop="potentialAction"itemscope=""itemtype="http://schema.org/SearchAction"><meta itemprop="target"content="https://www.google.com/search?q={q}"><input name="sitesearch"value="yegor256.com"type="hidden"> <input itemprop="query-input"id="search-query"class="field field-text"required="required"onfocus='$(".google").css("visibility","visible")'name="q"placeholder="Type üÑµ to search"autocomplete="off"> <input type="image"src="/images/google-search-icon.svg"class="google"title="Search via Google"alt="Search via Google"></form></div><div class="hot"><ul><li>We are organizing the <strong>6th <a href="https://www.iccq.ru/2026.html">ICCQ</a> conference</strong> in collaboration with <a href="https://www.iis.nsk.su/en">IIS</a> (Novosibirsk) and, hopefully, IEEE Computer Society. We're looking for volunteers to help us. If interested, please email at <a href="mailto:orgs@iccq.ru">orgs@iccq.ru</a> (attach your LinkedIn and GitHub profiles).<li>Are you familiar with open source and have a decent GitHub portfolio of contributions? <strong>We need freelancers</strong>, working remotely and paid by result, for <a href="https://www.eolang.org">EO</a>, a new programming language. Join our Telegram group, we'll discuss: <a href="https://t.me/eolang_org">@eolang_org</a>.</ul></div></header></div><section itemscope=""itemtype="http://schema.org/BlogPosting"><div class="wrapper"><header><p class="printable"><img src="https://api.qrserver.com/v1/create-qr-code/?data=https://www.yegor256.com/shift-m/2022/51.html&amp;format=svg"style="width:125px;height:125px"alt="QR code"><p class="printable"><code itemprop="url">https://www.yegor256.com</code><h1 itemprop="name headline mainEntityOfPage">Shift-M/51</h1><ul class="subline"><li><time itemprop="datePublished"datetime="2022-01-13T12:00:00+00:00">13 January 2022</time><li class="desktop-only"itemprop="locationCreated">Moscow, Russia<li class="printable"itemscope=""itemprop="author"itemtype="http://schema.org/Person"><span itemprop="name">Yegor Bugayenko</span><li class="unprintable"><i class="icon icon-comments"></i> <a href="https://www.yegor256.com/shift-m/2022/51.html#disqus_thread"itemprop="discussionUrl">comments</a></ul><p class="unprintable"><nav class="buttons notranslate desktop-only"><a href="https://www.facebook.com/sharer/sharer.php?u=https://www.yegor256.com/shift-m/2022/51.html"title="Share on Facebook"class="button"rel="nofollow"><span class="count count-facebook">0</span> <i class="icon icon-facebook notranslate"aria-hidden="true"></i> </a><a href="https://twitter.com/share?url=https://www.yegor256.com/shift-m/2022/51.html&amp;text=Shift-M%2F51"title="Share on Twitter"class="button"rel="nofollow"><span class="count count-twitter">0</span> <i class="icon icon-twitter notranslate"aria-hidden="true"></i> </a><a href="https://www.linkedin.com/cws/share?url=https://www.yegor256.com/shift-m/2022/51.html"title="Share on LinkedIn"class="button"rel="nofollow"><span class="count count-linkedin">0</span> <i class="icon icon-linkedin notranslate"aria-hidden="true"></i> </a><a href="https://reddit.com/submit?url=https://www.yegor256.com/shift-m/2022/51.html%3F2022-02&amp;title=Shift-M%2F51"title="Share on Reddit"class="button"rel="nofollow"><span class="count count-reddit">0</span> <i class="icon icon-reddit notranslate"aria-hidden="true"></i> </a><a href="https://news.ycombinator.com/submitlink?u=https://www.yegor256.com/shift-m/2022/51.html%3F2022-02&amp;t=Shift-M%2F51"title="Share on Hacker News"class="button"rel="nofollow"><span class="count count-hackernews">0</span> <i class="icon icon-hackernews notranslate"aria-hidden="true"></i> </a><a href="#"title="Cite it via BibTeX"class="button"onclick='return $("#bibtex").toggle(),!1'><i class="icon icon-tex notranslate"aria-hidden="true"></i></a></nav></header><article class="main"itemprop="articleBody"><div class="nospell"><div id="bibtex"style="display:none"><p>Please, cite this blog post via <a href="https://www.bibtex.org/">BibTeX</a> as such:<pre style="color:#053c5e">@misc&#123;bugayenko2022blog0113,
  author = &#123;Bugayenko, Yegor&#125;,
  title = &#123;&#123;Shift-M/51&#125;&#125;,
  howpublished = &#123;\url&#123;https://www.yegor256.com&#125;&#125;,
  year = &#123;2022&#125;,
  month = &#123;jan&#125;,
  note = &#123;[Online; accessed 17-11-2025]&#125;
&#125;</pre></div><iframe width="100%"height="450"scrolling="no"frameborder="no"allow="autoplay"src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/1198496698&amp;color=%23ff5500&amp;auto_play=false&amp;hide_related=false&amp;show_comments=true&amp;show_user=true&amp;show_reposts=false&amp;show_teaser=true&amp;visual=true"></iframe><div style="font-size:10px;color:#ccc;line-break:anywhere;word-break:normal;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;font-family:Interstate,Lucida Grande,Lucida Sans Unicode,Lucida Sans,Garuda,Verdana,Tahoma,sans-serif;font-weight:100"><a href="https://soundcloud.com/yegor256"title="@yegor256"target="_blank"style="color:#ccc;text-decoration:none">@yegor256</a> ¬∑ <a href="https://soundcloud.com/yegor256/shift-m51-michael-kay-about-xslt"title="Shift-M/51: Michael Kay about XSLT"target="_blank"style="color:#ccc;text-decoration:none">Shift-M/51: Michael Kay about XSLT</a></div><p><a href="https://en.wikipedia.org/wiki/Michael_Howard_Kay">Michael Kay</a> was our special guest. Michael is the editor of the W3C XSLT 2.0 and 3.0 language specifications for performing XML transformations and the developer of the Saxon XSLT and XQuery processing software.<p>Video is <a href="https://youtu.be/2Zt9oJtFKGw">here</a>.<h2 id="transcript">Transcript</h2><p>[00:00:00] <strong>Yegor</strong>: Hi, everybody. This is Shift-M Podcast, the next episode, the new episode with a special guest, Michael Kay. He‚Äôs in my opinion, the godfather of XSL, XSLT, the language, the format which I love very much. You probably know about that if you follow my projects, if you follow me and my blog. So, I‚Äôm really glad to have Michael with me. Michael, could you please introduce yourself quite quickly?<p>[00:00:24] <strong>Michael</strong>: Okay, (chuckles), I‚Äôm Michael Kay. I‚Äôm the editor of the 2.0 and 3.0 XSLT specifications, and I‚Äôm the developer of the Saxon implementation of those specs.<p>[00:00:40] <strong>Yegor</strong>: You know, when I tell my readers, my listeners about XML, most of them or many of them, they say that I am quite old and I love that format because I‚Ä¶<p>[00:00:50] <strong>Michael</strong>: Not as old as me.<p>[00:00:51] <strong>Yegor</strong>: I‚Äôm not a modern programmer, I don‚Äôt understand JSON, YAML, and all these formats, and they keep telling me that XML is dead, so that JSON is the future. What‚Äôs your take on that?<p>[00:01:01] <strong>Michael</strong>: They‚Äôre not engaged in the fields in which XML is important. XML is very, very widely used in all kinds of document publishing. It‚Äôs used for things like patents, for academic publishing, scientific publishing, legal publishing. is published in XML. That‚Äôs there because it‚Äôs got to last for 50 years. Well, legislation lasts for 700 years, and they chose a format that‚Äôs capable of surviving for that long. They are not going to change to something else quickly, so XML is definitely here to stay in those sorts of fields. What‚Äôs going to change is that people need to do something quick and cheap and dirty are going to use the quickest, most effective solution available to them, and very often that‚Äôs JSON, particularly if you‚Äôre working in a web browser. So it‚Äôs a distinction between whether you are doing something for the longterm or whether you‚Äôre doing something cheap and cheerful that‚Äôs only of local significance.<p>[00:02:16] <strong>Yegor</strong>: You know, they claim that XML, like you just mentioned, it‚Äôs a good format for documents, for something which is large, and they have to be standardized somehow, but when it‚Äôs a choice of what language or what format to use inside an application, let‚Äôs say we‚Äôre developing a mobile app or a web app, then the choice for XML‚Ä¶ it looks to them like quite strange. They say, why not JSON, because we don‚Äôt need to be standardized. We don‚Äôt need to publish our documents anywhere, it‚Äôs inside, so inside of the application‚Ä¶ They tend to use JSON more and more.<p>[00:02:48] <strong>Michael</strong>: Well, conventional programming languages have data models that aren‚Äôt very well suited to documents. Using the DOM is hard, it‚Äôs a complex structure, because the language wasn‚Äôt designed for that. There‚Äôs not a good mapping between the data structures used in the document world and the data structures used in conventional programming languages, which is where a language like XSLT comes in. It‚Äôs why there‚Äôs a niche for a special purpose language that‚Äôs designed for that kind of data, rather than the kind of data that you get in typical data processing applications.<p>[00:03:32] <strong>Yegor</strong>: And what is your story? How you do, how did you end up doing XML stuff, XSL stuff? Is it, was it like business, moneymaking, like it was necessary for you, or you really liked that format?<p>[00:03:44] <strong>Michael</strong>: It‚Äôs a long story. My specialism, my PhD many years ago (chuckles), was in database technology, and I spent 25 years working in the British computer manufacturer, mainframe manufacturing, then it was, ICL, on database technology. And we‚Äôd got to the point in the 90s where we were developing some big publishing systems for clients, particularly scientific publishing, news publishing. The 90s was when the web started to become sort of industrial scale in that kind of way. And at the time I was working with people in Fujitsu, developing object database technology, and we were trying to deliver those sites using the object databases, and finding that it didn‚Äôt actually work that well. It worked, we built some successful systems, but they were very expensive to build and we realized we haven‚Äôt got enough sort of reuse and enough power in the tools that we were using to build lots of sites quickly. And XML was coming along, so we knew XML might be the answer to that problem and then what really triggered it was we got a request to tender, an invitation to tender from Oxford University Press to do with the dictionaries and that was very much SGML and XML-oriented. And I said, ‚ÄúHey, this is our opportunity to get into XML. ‚ÄúWe‚Äôve known for ages we need to look at it, ‚Äúthis is the chance.‚Äù And the marketing people said, ‚ÄúNo, that‚Äôs too a high-risk. ‚ÄúWe‚Äôre not bidding for that contract ‚Äúwith a technology that we have no experience in.‚Äù So I said, ‚ÄúWell, how the hell ‚Äúare we going to get experienced in it (laughs), ‚Äúif we ignore an opportunity like this?‚Äù And so they said, ‚ÄúOkay, Mike, you‚Äôve got three months. ‚ÄúYou write a response to that bid, see what you can do.‚Äù And that‚Äôs really when I started playing with the technology, I started developing what became Saxon, as a prototype, to show to that customer, to show that we could handle XML and solve their problems and it was good fun because I hadn‚Äôt done any programming for years, I‚Äôd been too senior to do any programming in that kind of company, you‚Äôre expected to spend your time attending meetings, not actually writing code. So I wrote that prototype and presented it to the customer and the customer liked it, and our marketing people said, ‚ÄúHey, this is high risk, we‚Äôll double your estimates.‚Äù And so they doubled the price, and so the customer didn‚Äôt like the price and didn‚Äôt buy it. Which I was very aggrieved about (chuckles), but I‚Äôd had three months fun anyway. And that prototype eventually became the Saxon product. What I realized was that I‚Äôd been developing a Java library to do basically rule-based transformation of XML hierarchies. And then I saw that XSLT was coming along and that was doing rule-based transformation of XML hierarchies and a lot of the concepts seemed to align very closely, so I thought, let‚Äôs turn my library into an XSLT processor and that‚Äôs how it happened. And then I got invited to write a book on XSLT, and then as a result of the book I got headhunted by Software AG and then it all moved on from there. But the key thing is, I didn‚Äôt start it, James Clark started it, XSLT, he invented the language. I picked it up and did versions two and three and whatever, and that‚Äôs been the story of my career, really, picking up something, a good idea, developed by a good ideas person and industrializing it, turning it into a good product.<p>[00:07:42] <strong>Yegor</strong>: But when you were making the Saxon product, which I use in all of my projects right now, there were other products on the market, as far as I remember. I remember that like 15 or maybe more years ago, there was the Apache product, Xerces or what‚Äôs the right term?<p>[00:07:59] <strong>Michael</strong>: Yeah, I mean, there were a dozen XSLT 1.0 processors that came out very quickly, and it was a nice, small language, it was wasn‚Äôt too expensive to implement, so. And of course, you know, there was a hype curve, XML had an enormous hype curve at the beginning, ‚Äòcause you know, all the big players, Oracle and IBM, and Sun, and Microsoft, all for some reason decided rather than fighting each other, they‚Äôd collaborate on it. And so everyone was very excited by having a standard in that area, which we‚Äôd never had before. And then XSLT came along about a year behind as the way of processing it and lots of people had a go at implementing it. You know, there was a Microsoft implementation, the Lotus XSL implementation, and from Lotus, which became part of IBM, and which then moved into what is now Xalan and there were lots of what I call hobbyist implementations, Sablotron, no one knows about Sablotron anymore, there was one produced by (indistinct), in Python called full suite, it was called, I think at some stage. So there were lots of them and how did Saxon sort of emerge? I think basically because I stuck at it, most of them, most people produced a good version one product, and then never got beyond it. And why did they never get beyond it? Well, I think in the case of the commercial operations, IBM, Microsoft, what have you, their problem was producing a business case, the software was free, they weren‚Äôt making any money on it, you can produce a version one by promising your managers that it‚Äôs going to take over the world, but when it hasn‚Äôt taken over the world, then it‚Äôs quite hard to get the funding to produce version two. And then the other end of the scale, they were the hobbyist people who were writing in their weekends. And like, I guess their wives told them they wanted them to do something else with their weekend, or perhaps they got interested in some other new technology, because they tend to be the sort of people who like to do something new and doing a version two or something old is not what you want to spend your weekends doing. So really the reason that Saxon carried on while those other things failed was stickability. I stuck to it and I found a business model that enabled me to fund the ongoing development and make some money to continue that development, which the other people hadn‚Äôt. So the product was, it was good, but it wasn‚Äôt in any way, you know, so much better than all the others, that it was going to beat them on technical grounds. It was much more that I had a successful business model that enabled me to keep developing.<p>[00:11:22] <strong>Yegor</strong>: I remember that like 10 years ago, when I was choosing the XSLT engine for my Java projects, Saxon was not an option for me because it was all commercial, if I‚Äôm not mistaken. So it‚Äôs kind of.<p>[00:11:34] Micahel: I mean, that has always been an open source and a commercial version.<p>[00:11:40] <strong>Yegor</strong>: But there were some limitations, I remember that it was always kind of difficult.<p>[00:11:43] <strong>Michael</strong>: Yes, but they, in some ways the limitations, well that‚Äôs fair enough. I mean, the BBC‚Äôs coverage of the 2012 London Olympics was all using the free version of Saxon. I resented that slightly since they spent billions on the Olympics and I didn‚Äôt get any of it. (laughing loudly) But that‚Äôs the, you know, there‚Äôs a downside to the business model as well, which is you, I mean, from my point of view, the reasons for doing open source is that you get millions of users and then if, you know, if 1% or 5% of them decide that they need more than the open source version, then you get enough revenue to fund the whole thing and so open source is the marketing mechanism, it‚Äôs the loss leader that brings in the revenue. So I don‚Äôt mind the fact that there are billions of users of the open source version, because the model works well for me.<p>[00:12:46] <strong>Yegor</strong>: But why people now would pay for Saxon? I know only one feature, which I miss in the open source version is the external functions aside from there, they have everything so I don‚Äôt understand how your model works, what people pay you for.<p>[00:12:49] Micahel: There are a lot of people who pay for it, not because they need the extra features, but because they like the sense of security of using, of having a commercial relationship with a supplier. It‚Äôs not expensive for them after all, it‚Äôs a pretty small part of their total IT budget, but they feel more comfortable with a commercial product than with an open source one for something that they‚Äôre particularly dependent on. So that‚Äôs the answer for some people, for other people, yes, they need one or more of the features. They might need streaming, they might get benefit from schema awareness, they might benefit from the optimization capabilities, which becomes significant when you‚Äôre doing queries on large documents, so, yes, the open source version is good enough for 90% of users but once people get stuck in, they find they need the other, need something else from the mix of things that we offer in the, you know, the rest of it.<p>[00:14:09] <strong>Yegor</strong>: And how many programmers do you have right now in house if you can disclose this information?<p>[00:14:13] <strong>Michael</strong>: In the team?<p>[00:14:14] <strong>Yegor</strong>: Yeah.<p>[00:14:15] <strong>Michael</strong>: We‚Äôre a team of six people of whom four are developers.<p>[00:14:20] <strong>Yegor</strong>: And you are the developer, or you‚Äôre in the management side now?<p>[00:14:23] <strong>Michael</strong>: No, I‚Äôm cutting code everyday.<p>[00:14:27] <strong>Yegor</strong>: That‚Äôs amazing. Well, I know you from Stack Overflow, you‚Äôre not only writing code, you‚Äôre also answering questions there and quite helpful. You actually answered a few of my questions, no, I think many of them, so that‚Äôs my next question to you. So, how do you find time for that and how do you feel about the Stack Overflow platform? ‚ÄòCause most people don‚Äôt do that and they claim that this platform is, has all the answers possible to be given, so that‚Äôs it, so no reason to be there because all the questions have been answered already, so people don‚Äôt spend time there, but you do, so.<p>[00:14:59] <strong>Michael</strong>: Yes and, I do it because I, partly because I think it‚Äôs a good idea in principle and partly because I enjoy it. Actually, everything I do is a combination of doing things because I think it‚Äôs a good thing to do and doing it because I enjoy it. If things don‚Äôt meet one of those two criteria, then they don‚Äôt get done (chuckles). Except for really necessary things like doing my tax returns. (laughing loudly) But on the whole, I do things because it seems a good idea and I enjoy it. Why do I enjoy it? Because I think it‚Äôs very important if you‚Äôre developing software to be in touch with your users. I actually quite enjoyed the first few years of doing Saxonica and I was spending half my time doing consultancy and so I actually got out to visit customers. In those days consultancy meant you actually traveled, you actually flew to California and visited your users and had dinner with them and drinks with them and things like that and that was fun, I miss that now. Just knowing them by email, isn‚Äôt the same. But even if it‚Äôs just electronic, knowing what your users are doing, knowing what they have difficulty with, knowing what they find easy, knowing what they find hard and picking up ideas from other people, answering the questions. That‚Äôs important. It‚Äôs a contact with the user base. And apart from bug reports, you know, it‚Äôs the only more or less, the only contact I get. And that sort of tells you, I mean, what makes a good product? Users understand the error messages, people will tell you, one thing I like about Saxon is the error messages. Well, that‚Äôs a really boring mundane thing, but to me, a bad error message is something that really needs to be fixed. That‚Äôs the, that‚Äôs what users are dealing with every day, they‚Äôre reading my error messages. If (chuckles), if those glare out as being unhelpful, as being badly spelled, then that‚Äôs their experience with the product, so it‚Äôs important to get it right. And I put a lot of effort into those sorts of little details and to do that, you‚Äôve got to have the contact with the user base. Just see, I mean, getting good error messages is really quite an art because do you phrase the error message in terms of the proper terminology from the spec? Or do you use the terminology that the users are using out there, which might be quite wrong. What users call a tag isn‚Äôt what the specs call a tag. They‚Äôll use a tag to mean element. So which word am I going to use in an error message? It‚Äôs quite hard to get that sort of thing right and getting a balance between a message that is technically correct, and a message that users understand, sometimes requires a fair bit of thought. And then you‚Äôve got to phrase the error message in terms of what the user was trying to do, not in terms of what was going on internally. And that again gives you a significant challenge, so yeah, you have to think about those things, to think about those sorts of things. You firstly, have to use the product yourself, that‚Äôs very important. And my project over the last year has been translating the Java code of Saxon into a C-Sharp version of Saxon. And so to do that, I had to write a translator for Java to C-Sharp and so how do you write such a translation? Well, obviously using XSLT (chuckles). I mean, what you‚Äôre doing, Java is has a syntactic structure, you pass it and you get a syntax tree, so you‚Äôve got a tree structured information structure, and you‚Äôre converting that into another tree structured information structure from which you generate C-Sharp and how do you transform one tree to another? Obviously you use XSLT. It‚Äôs the natural choice that anyone would come up with, isn‚Äôt it (chuckles)? I‚Äôm joking (indistinct).<p>[00:19:19] <strong>Yegor</strong>: No, it‚Äôs not. You‚Äôll be surprised, but it‚Äôs not (laughs). You know, I‚Äôm working right now with three projects, three different teams and they write translators from one programming language to another programming language, none of these teams ever considered XSLT as a translator, but I‚Äôm not the member of these teams, I only supervise them so I cannot enforce them to make those decisions, but they don‚Äôt make this decision, why? Because they don‚Äôt probably know about XSLT. So what they do, they build this abstract syntax three in memory, like part like they make it objects, not XML syntax tree, which is natural just as you‚Äôve said, but they make the objects like Java objects or C plus plus objects and then from these objects, they build another source code making these basically print like statement.<p>[00:20:03] <strong>Michael</strong>: And of course, I mean, I‚Äôm joking because if I wasn‚Äôt involved with the XSLT, then it wouldn‚Äôt declare to me to do it that way, or anything.<p>[00:20:10] <strong>Yegor</strong>: Okay.<p>[00:20:11] <strong>Michael</strong>: But, the fact is when you‚Äôre familiar with technology, then you can see that it‚Äôs ideally suited to that job.<p>[00:20:19] <strong>Yegor</strong>: Yeah, it‚Äôs perfect, yeah.<p>[00:20:21] <strong>Michael</strong>: And it‚Äôs perfect for it and so that‚Äôs the way you do it. And of course it has, the benefit is not that it‚Äôs XML or that it‚Äôs XSLT, the benefit is primarily the paradigm that you‚Äôre doing a recursive descent rule-based transformation. And that‚Äôs what XSLT is, it‚Äôs a rule-based language.<p>[00:20:42] <strong>Yegor</strong>: You know, for most people, it‚Äôs hard to understand this language, that‚Äôs what they complain about. I wrote the compiler in XSLT just last year, the compiler like instead of, you know, making, it‚Äôs, I have a language which is the programming language, and then I had a Ja‚Äì, I have a task to implement the compiler from this language to Java so I made it entirely in XSLT. So I have many, many style sheets and they go in one after another, so it‚Äôs like a chain of style sheets and then I transfer the inputs, abstract syntax tree to the final result.<p>[00:21:10] <strong>Michael</strong>: But we‚Äôll. If you read the textbook on writing compilers, it talks about it as a pipeline of tree to tree transformations and that‚Äôs exactly the typical architecture of an XSLT application.<p>[00:21:25] <strong>Yegor</strong>: But when I show you this, when I show this code to other programmers, most of them just say, I don‚Äôt understand how it works, because it‚Äôs something I haven‚Äôt seen before, so they just.<p>[00:21:33] <strong>Michael</strong>: Yeah, it is and that‚Äôs the resistance to XSLT is because for most people where they‚Äôre coming from, particularly programmers, where they‚Äôre coming from, the direction of non-programmers is quite different, but programmers where they‚Äôre coming from, it‚Äôs just so different from anything they‚Äôve ever seen before that it requires some rewiring of the brain and therefore the, you know, the enthusiasts, so those who get over the initial learning curve and discover why this weirdness is actually such a good thing, but for people first coming to it, it can be quite an obstacle.<p>[00:22:24] <strong>Yegor</strong>: Let me, quote you, I was listening to one of your speeches of the, recent speeches of the conferences, and you said exactly this, ‚ÄúMost XSLT programmers don‚Äôt know, computer science, ‚Äúthey see examples and they understand how they work.‚Äù So (laughs), that sounds really accurate because most people don‚Äôt really understand the XSLT, how really they don‚Äôt understand that it‚Äôs a functional language, functional programming language. They just.<p>[00:22:48] <strong>Michael</strong>: Yeah. Now, I mean, it‚Äôs, I find it fascinating because I find, I sometimes find new technologies quite hard to get familiar with and to adopt and that‚Äôs because I think I, when I look at a new technology, I want to have a deep conceptual understanding of it before I use it. I know other people who are much better at picking up something new who have a different learning style, they learn by example, they see something that works and they bend it and adapt it and make it fit without ever having a deep understanding. And it‚Äôs like, you know, some people can jump in a car and press the pedals and it goes in the right direction and other people really want to understand why you have to turn the steering wheel back after turning it, you know, it‚Äôs, you can over intellectualize things and I‚Äôm on that end of the spectrum, probably as a spectrum as well.<p>[00:23:59] <strong>Yegor</strong>: Don‚Äôt you think that we are getting more and more people of the first kind in the programming industry?<p>[00:24:06] <strong>Michael</strong>: Oh, absolutely. Yes. Yes. It‚Äôs the difference between engineers and mechanics. We‚Äôve got a lot more mechanics now who are very, you know, capable of doing a good job, but they‚Äôre not computer scientists and, you know, as computer scientists, we‚Äôve been building technology to enable those people to build systems. And so we shouldn‚Äôt complain.<p>[00:24:39] <strong>Yegor</strong>: Right (laughs). Do you think it will be ever possible to create something like a simplified version of XSLT? Which would look more, you know, I‚Äôm dreaming about this project for a few years already, something which will simplify the syntax of XSLT, because right now it‚Äôs basically XML and then XSLT is not a dialect, but it‚Äôs the language which we use as XML, basically and XSLT is just elements which we use there, right? But maybe we can turn it into something more use, more traditional for programmers, like Java, like the language where you have statements, statements after statements.<p>[00:25:21] Michal: A lot of people have tried, you know, to prove a different syntax for XSLT and it‚Äôs not that difficult to do and I think what‚Äôs happened is that when people have done it, you realize that actually you thought syntax was the problem and it wasn‚Äôt, the problem is not the syntax, it‚Äôs the concept. It‚Äôs what the hell is a template rule? What the hell does applying templates actually mean? And it‚Äôs not a, you think syntax is the difficulty, but it‚Äôs not. The difficulty is actually the semantics of the language and improving the syntax doesn‚Äôt help. The other thing is that once you‚Äôve been in, once you‚Äôve got past that stage of the syntax looking weird, you actually realize that there are some benefits for having an XML based syntax. The benefits of any big XSLT based application that I‚Äôve seen ends up exploiting the fact that XSLT is XML and that you can generate XSLT and you can modify XSLT, you can build libraries with XSLT components and assemble them in different ways, and the fact that you‚Äôre using the same conceptual tool set to manipulate your data and your source code. I mean, that‚Äôs something that comes from Lisp, isn‚Äôt it? But they in turn, programs are essentially the same thing and XML and XSLT is if you like a continuation of that Lisp concept of not separating data from programs.<p>[00:27:14] <strong>Yegor</strong>: So it‚Äôs not the syntax, which is the problem? Let me ask you something else about the committee, what would you sit on like the W3C committee, which defines (indistinct).<p>[00:27:24] <strong>Michael</strong>: Which I did sit on, it‚Äôs now wound up, but.<p>[00:27:28] <strong>Yegor</strong>: So how do these guys work? How do these communities work? Can you explain? Like you sit there, how they define the standards, how, for example, I can get in? Is it possible? Is it an open door or?<p>[00:27:39] <strong>Michael</strong>: Well, as I say that most of those committees have now disbanded through not having enough people to take things forward. I mean, I am hoping to reconvene a group to develop an XSLT in fall, I‚Äôve been promising that for a while, but it‚Äôs definitely going to happen this year (laughs), that‚Äôs my project for this year.<p>[00:28:01] <strong>Yegor</strong>: I would love to join by the way. (laughing loudly)<p>[00:28:06] <strong>Michael</strong>: So how does it work? The actual dynamics vary quite a lot from one group to another. On the XSL working group, I sort of inherited the role of editor from James Clark and the way the group worked didn‚Äôt really change after that. The process was very much that I was in a kind of chief designer role, not just editing the spec, which doesn‚Äôt mean that all the ideas were mine and that I had the final say on everything, it means that people brought their ideas to me and I had to turn them into something that worked or to come back and say, ‚ÄúNo, I don‚Äôt think that will work.‚Äù Perhaps something else would work. It also means if I brought an idea to the group, then it would get subject to a lot of scrutiny, people would ask a lot of challenging questions. It would be improved in the course of review. But I was still sort of acting as chief designer with a group around me that was helping me to get the details right, if you like. So it was a very constructive and friendly group. The XQuery group was very different. When I first came to the XQuery group, I was sort of shocked and horrified because there were six people on the group, at least, who were capable of being chief designer. Who were capable of designing a programming language. And they all had radically different ideas about what (chuckles) the language should be. So it was a group that had immense tensions on it, simply because it had so much talent in the group. There were too many creative individuals with different ideas as to where to take the language, which is very much harder to work with in many ways and you didn‚Äôt have the same feeling of a cohesive sense of unified purpose. What you did have was a couple of people on that group, Paul Cotton, who was the chairman for most of the time, I was involved, Don Chamberlin, who was the XQuery editor for lots of the time, Mary Fernandez, who coordinated with the Excel group on defining X path, who extremely good moderators, who took the creative people by the scruff of the neck and banged their heads together and said, you know, this is what you agree about, this is what you disagree about, let‚Äôs concentrate on, you know, sorting out the areas you agree on, we‚Äôll work out the areas you disagree on next week, and who forced the process through by managing the people who would otherwise have killed each other (chuckles). So, yeah, different groups have very different dynamics. I‚Äôm told the XML schema group, before I joined it, they were meeting for 40 people there. And they all brought ideas to the table and just managing the agenda was one of the biggest challenges because they‚Äôd come to a week long meeting, somewhere in a hotel, or somewhere in Florida, and they‚Äôd have more work on the table than they could get through in a week. So, yeah, it‚Äôs different for each group.<p>[00:32:05] <strong>Yegor</strong>: And how these groups, they get created? Is it somebody who‚Äôs deciding that or it‚Äôs like chaotic process?<p>[00:32:17] <strong>Michael</strong>: I don‚Äôt really know because I‚Äôve never been involved, it‚Äôs always been going by the time I got on board.<p>[00:32:33] <strong>Yegor</strong>: And how did you get on board?<p>[00:32:34] <strong>Michael</strong>: As I say, as with software, you know, I‚Äôve heard someone say, there are two kinds of people, there are starters and finishes, and I‚Äôve always been, I‚Äôve always been the kind of person who finished things that other people have started (laughs).<p>[00:32:35] <strong>Yegor</strong>: So how did you get on board? Somebody invited you, or you applied?<p>[00:32:38] <strong>Michael</strong>: I got invited by Sharon Adler, who is the chair of the XSL working group, basically on the strength of the Wiley book. So the group had developed XSLT 1.0 with Sharon Adler in the chair, and James Clark as editor, I developed an implementation and I was asked by Wiley to write a book on XSLT, which I did, when the book landed on Sharon‚Äôs desk, she picked up the phone and asked me to join the working group and then I had to persuade ICL to give me the time to (chuckles), to let me do that.<p>[00:33:16] <strong>Yegor</strong>: So basically it‚Äôs not like there‚Äôs a form which we can fill up and apply for?<p>[00:33:19] <strong>Michael</strong>: Sure you can. Sure, yes, people do. They, I think most of the people who give it enough time to be worth having on the group are people who are not just doing it as a hobby. They‚Äôre definitely engaged, they need the group to be successful for professional and business reasons. Otherwise they find they haven‚Äôt got time to read all the papers and email, and then they get lost in meetings and they drift away.<p>[00:33:59] <strong>Yegor</strong>: Was it profitable for you to be in this group?<p>[00:34:04] <strong>Michael</strong>: In what sense?<p>[00:34:06] <strong>Yegor</strong>: What did you get out of it?<p>[00:34:12] <strong>Michael</strong>: It‚Äôs a very, it‚Äôs a creative process, it‚Äôs a rigorous process, it‚Äôs a very frustrating process. It‚Äôs all of those at the same time. If, as a software developer, I come up with an idea for a language feature, I can implement it that morning and think that it‚Äôs done. If I take that same feature to a standards group, it will be challenged. Why do we need it? Can‚Äôt it be done this other way? Why did you choose that keyword rather than a different keyword? Can‚Äôt you solve this other problem at the same time? You will come up with a vast number of challenges to your little idea that make it bigger or smaller or change it in all sorts of ways and that can be very frustrating ‚Äòcause it takes a long time, but it also produces a much better result in the end than one person‚Äôs good idea from, you know, sitting in the bath. So yeah, that‚Äôs what you get out of it. You get the, a very thorough review of ideas in which people bring things to the table and you end up with synthesis. It doesn‚Äôt always produce a better result, you know, sometimes you do get the problem of committee compromises and you can definitely, there are definitely bad decisions that committees have made in XSLT and XQuery and XML and everything else where you just wish we hadn‚Äôt made that compromise but that‚Äôs the way of the world. One of the most difficult things is keeping the design coherent. Setting yourself design principles and sticking to them with every new feature. An example of that with XSLT is error handling. XSLT 1.0 had a sort of principle of no runtime errors and that‚Äôs because it was a lot of the driver for XSLT 1.0 was the idea of running it in the browser and in the browser, the last thing you want to do is on the user screen, put up something that says error on line 17 of style sheet, everything should produce an answer if you, even if it‚Äôs the wrong answer. So I think that was part of the 1.0 design thinking, but then people realized that that makes debugging very difficult. If an incorrect program just produces blank output, then it‚Äôs very hard for the programmer to work out what they did wrong. And so in 2.0, you started to get more of the concept of static errors and dynamic errors and a little more systematic approach to error handling, but then you find, although you‚Äôve changed what you‚Äôre trying to achieve, you‚Äôve then got the fact that you can‚Äôt change the existing language, you‚Äôre stuck with the way it was designed first time round and so you end up with new features, having one philosophy and the old features, having a different philosophy and you start to lose the coherence and that‚Äôs hard to achieve, how hard to get right.<p>[00:37:33] <strong>Yegor</strong>: So there is no one single architect in the group, it‚Äôs always the democratic decision-making process?<p>[00:37:40] Micahel: Yeah, it‚Äôs not democratic in the, and certainly the way W3C works, it‚Äôs not democratic in the sense of taking a vote. The Tim Berners-Lee philosophy is very much the benevolent dictator. The chair has to declare that consensus has been achieved (chuckles), whatever that means. So it‚Äôs not numerical counting of votes, it‚Äôs people going away from the meeting, being prepared to accept the decision of the group.<p>[00:38:16] <strong>Yegor</strong>: But the decision has to be made by the group, not by one leader.<p>[00:38:19] <strong>Michael</strong>: The decision has to be made by the group, yeah, and that can be tough. And yes, you know, you will get compromises, I‚Äôll let you have this feature, if you let me out of that one, (laughs), or more often, the compromise is one person will be very, very enthusiastic about some new feature, everyone else thinks it‚Äôs of marginal value, but it‚Äôs much easier to get that, keep that person quiet by accepting their idea and putting it in the language than to have more and more arguments as to why it shouldn‚Äôt be added. So it‚Äôs the easiest route out for a committee is sometimes to accept something it doesn‚Äôt really want rather than keep fighting against it. (laughing softly)<p>[00:39:11] <strong>Yegor</strong>: That‚Äôs weird. And you, at the same time being in the committee and the chief of Saxonica, your private company, so I feel that there is a, sometimes could be a conflict of interest, when you have this feature, you want this feature for your customers, you probably already implemented this feature and you gave it to your customers and then you bring this feature to the committee and say, I would love to have this in the standard. They may say the group may say, you know, we understand why you‚Äôre doing that because you are the, does it happen?<p>[00:39:39] Micahel: I found. I found it usually, it doesn‚Äôt usually work like that. I mean, one of the first things I did that wasn‚Äôt in the standard was grouping and multiple output files and they sort of go together and I did grouping because it was clearly needed, in all the applications I‚Äôd had to write, I needed grouping and so I invented the way to do it and then when I joined the group, I took my grouping design there to the working group and everyone there accepted that we needed to do grouping and that the feature was needed, but there was then lots of constructive criticism about the way I‚Äôd implemented it in Saxon and questions about the, how edge cases works that I hadn‚Äôt even thought about, and you know, more use cases, how will it handle this problem? How will it handle that problem? The group improved the design and I implemented the improved design. So that sort of syn‚Äì, I regard that as synergy between doing an implementation, having users and developing a standard, and most of the time that it was synergistic, the fact that we had users, the fact that I had an implementation, the fact that we were developing the language actually worked in harmony.<p>[00:41:12] <strong>Yegor</strong>: And the source code of Saxon is open or not?<p>[00:41:16] <strong>Michael</strong>: There‚Äôs an open source product, there are other features which are proprietary. The schema processing is all proprietary, but the, you know, the XSLT code is largely open source. The streaming is proprietary.<p>[00:41:32] <strong>Yegor</strong>: It‚Äôs on SourceForge.<p>[00:41:34] <strong>Michael</strong>: Yeah, the we‚Äôre sort of moving away from SourceForge. It has historically always been on SourceForge and I, but I think we now just use SourceForge for publishing new versions, because, to make sure people don‚Äôt download old versions. The main page you get to do is from the repository on our own Saxonica sites.<p>[00:41:53] <strong>Yegor</strong>: And where do you move to GitHub?<p>[00:42:00] <strong>Michael</strong>: We‚Äôve got some things on GitHub, but a lot of it is on repositories on our own site.<p>[00:42:05] <strong>Yegor</strong>: Okay.<p>[00:42:06] <strong>Michael</strong>: You can download it from there. We‚Äôre increasingly moving to, you know, on.net, it‚Äôs all you download it from NuGet on Node.js, you download it from NPM, it‚Äôs part of the sort of, and Java people download from Maven.<p>[00:42:22] <strong>Yegor</strong>: Right. That‚Äôs what I do.<p>[00:42:24] <strong>Michael</strong>: Yeah.<p>[00:42:26] <strong>Yegor</strong>: And do you know anything about the possibility of compiling XSLT to some binary code? Because in my case, the performance is quite an issue. So XSLT is a great standard, it‚Äôs a great idea. I write all the style sheets, like I told you, in my compiler, I have many, many of these style sheets, but they have like maybe 30 of them and to run all of them one by one, it takes seconds, it doesn‚Äôt take microseconds. So I‚Äôm thinking maybe it would be possible to turn those XSLT into some binary code.<p>[00:42:59] <strong>Michael</strong>: Well, I mean, the answer is quite a few years ago now. We did bytecode generation in the commercial product and the enterprise edition and when we first did it, it gave us a performance improvement, sort of between 25 and 50%. And these days it tends to be less than that. It‚Äôs very often, only 10 or 15%, which means it‚Äôs hardly worth doing. The reason the performance advantage has declined over time is that the Java hotspot compiler has got better and we haven‚Äôt got better (chuckles). Because those guys who write the hotspot compiler really understand what goes fast in machine code terms. To do code generation and make it go fast, you‚Äôve, it‚Äôs a mindset and a knowledge about the behavior of the hardware that most mere mortals don‚Äôt have. You, don‚Äôt get the amount of benefit that you‚Äôd expect. And when we look at it in detail, the benefit that we are getting is not because we‚Äôre generating code, it‚Äôs because we‚Äôre making decisions at the right time. And you can actually reproduce that effect of making decisions at the right time by taking things out of the loop, for example, out of a runtime loop, into a static decision at co-generation time, you can do that without generating bytecode. So it turns out, I think that cogeneration is not the answer to improved performance. The other thing we found is that a lot of XSLT workloads, people are doing the static analysis on the style sheet or the compilation once for every time they execute. And if you do that, then it becomes compile time that‚Äôs important, and not runtime. It‚Äôs, there are an awful lot of workloads where people are spending three seconds compiling the style sheet and then three milliseconds executing it. And if that‚Äôs the ratio in your workload, then the last thing you want is to move more work out of run time, to do more work at compile time in order to reduce the runtime because the runtime is negligible. Also for all the simple transformations, the transformation is a lot faster than the passing. So the XML passer is taking longer than the actual transformation. And so if you get a work flow like that, you know, taking a long time, there are all sorts of reasons for it and one is that the most common reason is that the star sheet‚Äôs being compiled every time it executes and the compilation is taken too long. We‚Äôve only sort of grasped that fairly recently, that we really need to put more effort into compile time performance. Another reason is simply, you‚Äôre dealing with a high level of declarative language and with high-level declarative languages, it‚Äôs like the SQL, one line of code can take six hours to execute. You‚Äôre not writing at a low level where the statements you write in your program have a one-to-one correspondence with hardware instructions. There‚Äôs a very, very indirect relationship and therefore you need to think about the performance of your code in a different kind of way. And I mean, this is one of the dilemmas to make your code perform. The idea of a declarative language is that you don‚Äôt know what‚Äôs going on inside, it‚Äôs up to the optimizer to work out what‚Äôs going inside but the reality is that to write efficient code in a language like SQL or XSLT, you have to have some kind of appreciation of what you are asking the machine to do and whether it‚Äôs going to be a quadratic algorithm or an in log-in algorithm or whatever, how it‚Äôs going to scale with your data size, you know, your several layers removed from the machine and yet to achieve performance, you‚Äôve got to understand what‚Äôs going on in those layers, which is challenging.<p>[00:47:39] <strong>Yegor</strong>: How are you, how tight are you integrated with the people who develop web browsers like Chrome, for example, or Firefox? Do you work with them?<p>[00:47:51] <strong>Michael</strong>: Not really.<p>[00:47:52] <strong>Yegor</strong>: Not really?<p>[00:47:53] <strong>Michael</strong>: No. The, I had a bit of rant in my blog about 2005 or 2006 (laughs), at the stage where the browser developers were deciding that they didn‚Äôt like XML, they didn‚Äôt like XSLT.<p>[00:48:10] <strong>Yegor</strong>: Right.<p>[00:48:13] <strong>Michael</strong>: The rant was mainly about who are they to decide? You know, why should? It‚Äôs the power struggle, you know. I like the idea of an open layered architecture in which people own one layer and leave the layer above just to other people, whereas the web browsers remind me of the sort of very vertically integrated days when if you produce a computer, you controlled what applications were allowed to run on it. We‚Äôre seeing that again with mobile phones, aren‚Äôt we? I think the web browser should be a sort of neutral platform on which other people can develop technologies above it and where we haven‚Äôt really seen that, we‚Äôve seen a lot of the very proprietary sort of space and yeah, they decided they weren‚Äôt interested in XML. We decided that we were going to do an XSLT processor in the browser anyway, which works pretty well but of course it‚Äôs a minority interest. The one thing that has pleased me recently, actually, is we‚Äôre seeing, most adoption of Saxon in the browser has been from people who are XML and XSLT enthusiasts who are very much committed members of the community. But we‚Äôve been seeing a few users recently picking it up who are new to that and that‚Äôs nice to see.<p>[00:50:01] <strong>Yegor</strong>: ‚ÄòCause that‚Äôs really sad. ‚ÄòCause I think it‚Äôs, that would be a great, it is a great technology, having XML, having web servers deliver XML only, and then XSLT runs on the client on the Chrome and then does the (indistinct).<p>[00:50:17] <strong>Michael</strong>: It is absolutely the way things should be if you do all the rendering, all the user and traction on the browser and the message sent from the server to the browser should be as abstract and as pure data as possible. And that means XML, no doubt, I mean, no doubt that‚Äôs the way things should be. But if it hasn‚Äôt, it hasn‚Äôt found favor, except that of course HTML has tried to develop in that direction of being a somewhat more abstract formulation, but they‚Äôve tried to get rid of the very presentation oriented aspects of HTML. So they‚Äôve moved HTML in the direction of XML, if you like, while rejecting XML itself.<p>[00:51:07] <strong>Yegor</strong>: Yeah. I want to ask you one question, which I like from the slack channel of yours, of your group, of the XML group. The question is, are there any features in XSLT or XML or XQuery, which you would, if you will have the power, you would replace, remove, change? Do they exist? Let‚Äôs start from there (indistinct).<p>[00:51:31] <strong>Michael</strong>: Yeah and I guess there are two kinds as well. There are some that are very little things, like the choice of keyword for XSL value of should have been XSL text and that leads to a lot of users making the same mistake, you know, hitting the same problem just because the choice of keyword is wrong. And similarly, the handling of default namespaces. Every user falls into that same trap that their path expressions don‚Äôt select anything because they didn‚Äôt think namespaces mattered. So, you know, we got the default wrong and that‚Äôs very hard to change. And then at the other end of the spectrum, I have doubts about the, some of the really big things that we did. So for example, the biggest thing we did in XSLT 2.0 was schema awareness. And I think in retrospect, it would be hard to say that schema awareness was a success. The idea was right, you can get considerable benefits from schema awareness, if you‚Äôre writing a big style sheets, schema awareness can definitely make it more robust, easier to debug, it can give you a lot of software engineering benefits, but at the same time, it hasn‚Äôt been successful in terms of adoption. Most people aren‚Äôt using it and the reason they aren‚Äôt using it is because the short-term cost of adoption is high compared with immediate benefits. You‚Äôve got a lifecycle benefit over using it, but you don‚Äôt, if you‚Äôre sitting down on Monday morning and want to have some code running by lunchtime, then you leave out schema awareness because it seems too difficult. So it‚Äôs, there‚Äôs a sense in which it was strategically the right thing to do, but somehow in the way we did it, we just made it and I‚Äôve constantly been trying to tweak it to try and make it more of a, you know, a magic switch on schema awareness and get all the benefits but it‚Äôs very hard to achieve that. It‚Äôs something that people have to put a lot of investment into before they can get the benefits out. So I have doubts about that sort of thing. Streaming similarly. Streaming is really valuable for the 3% of users who need it, but it has no value at all for the other 97%. And that makes you wonder whether the complexity of doing it in the spec was actually justified. So those are tough calls. You do want to increase the power of the language, but at the same time, I‚Äôve always got much more satisfaction from doing little things that everyone benefited from, you know, like the double bar and caffeination operator. Everyone says, ‚ÄúWhat a great idea! ‚ÄúWhy couldn‚Äôt we do that before?‚Äù Rather than the big strategic things, which cost far more.<p>[00:55:03] <strong>Yegor</strong>: What are you working on right now, XSLT 4.0?<p>[00:55:07] <strong>Michael</strong>: At the moment we‚Äôre in the process of hoping to ship Saxon 11, we‚Äôve shipped Saxon 11 on C-Sharp, we‚Äôve got to do a maintenance release of that and 11.1 for C-Sharp and the first release on Java and moving forward the Saxon C product to that same 11 code base. So we‚Äôre working on that and hopefully that will be out within a couple of weeks and that means at the moment, we‚Äôre in that process of running millions of tests and working out why three of them are failing (chuckles), which is (laughing), which is very dispiriting and frustrating. It, there are so many tests now that it‚Äôs a nightmare. Now and Toby Walsh who joined the team last year has been doing a lot of work on automating our build and test process and that‚Äôs been very, very valuable and hopefully will lead to more reliable releases, and more frequent releases. But after that, when we start getting a clean sheet of paper, we‚Äôve got to make some decisions. I want to put some more effort into the Saxon-JS product and that‚Äôs been, you know, a bit too quiet for a year, one of the problems is we‚Äôre not making any money on it, I want to see if I can find some way of reproducing the business model, that‚Äôs generate some revenue for Saxon-JS, which will create a better justification for doing development, work on it. A key technical challenge with Saxon-JS is doing asynchrony because the JavaScript platform needs to be asynchronous. When you fetch resources, you‚Äôve got fetch them asynchronously, and that‚Äôs very hard to map into the XSLT way of doing things so that‚Äôs a technical challenge. Other things, yeah, carrying forward the 4.0 initiative, trying to get a group of people together to define a 4.0 and that I hope will be lots of handy little things, rather than, you know, one big strategic thing that takes five years or 10 years, I think three is what we‚Äôre talking (laughs).<p>[00:57:23] <strong>Yegor</strong>: But how it‚Äôs going to happen if you said that the group has been disbanded?<p>[00:57:27] <strong>Michael</strong>: I have to put together a new community group basically. They won‚Äôt be under W3C except as a sort of hands-off relationship. A number of the groups have continued as community groups with a sort of informal way of working, but it‚Äôs different now because of course, W3C had the model that you only work on a standard, and if there aren‚Äôt going to be at least three implementations. And XSLT, you know, there‚Äôs no chance now of having three implementations, the only people who‚Äôve implemented XSLT 3.0, well, there have been three, there were three implementations. There was mine, there was Altova‚Äôs and then there was (indistinct) but (indistinct) has, seems to have found other things to do with his time and Altova, an interesting company, because they always implement the standards, but they never participate in developing them. I don‚Äôt understand the logic of that, but that‚Äôs up to them, that‚Äôs the way they work, they‚Äôre entitled to do that. So it‚Äôs, it won‚Äôt be a standard in the same way in that you expect to see lots of implementations, there‚Äôll be more specification for the next Saxon release and the world‚Äôs changed in that way.<p>[00:58:52] <strong>Yegor</strong>: So there was a possibility that we may not see this as a standard, we just may see your next version of Saxon that‚Äôs?<p>[00:58:59] <strong>Michael</strong>: It‚Äôs, oh, it might, yes, might, some people might perceive it as proprietary extensions, and will almost certainly provide a way of switching off all the extensions so that you still do have official standards conformance. But yeah, but the world changes when you haven‚Äôt got lots of implementations that have to be compatible with each other and when there‚Äôs little chance of getting them. You know, a lot of programming languages, you know, you take PHP and Python, you don‚Äôt have lots of alternative implementations of PHP or Python.<p>[00:59:35] <strong>Yegor</strong>: Right (chuckles).<p>[00:59:38] <strong>Michael</strong>: It‚Äôs not something you expect.<p>[00:59:41] <strong>Yegor</strong>: That‚Äôs right. Now, which programming language do you personally like most? Java, C-Sharp? What‚Äôs your favorite?<p>[00:59:48] <strong>Michael</strong>: Ooh! Well, there are lots I haven‚Äôt used and I‚Äôm sure out there somewhere is the perfect language. There are lots of that I would like to have used more, I‚Äôve done a very little bit of work with Scala, for example and I would like to have done more with Scala. I would also like, I mean, I‚Äôve over the years, I‚Äôve become more and more a fan of functional programming and so writing in a pure functional language would have an appeal to me now. More and more of my Java and JavaScript is using a functional paradigm, that‚Äôs the way I now choose to write code so a language that enforces that would be a good thing. What I miss in the programming languages I use is parallelism and asynchrony. I haven‚Äôt found a language where doing multi-threading and parallel processing becomes really reliable and robust and bug free. So, you know, I would quite fancy playing with Erlang to see if it solves some of those problems people say it does, I don‚Äôt know how that would work for me. Java has been a pretty good development for the industry. It‚Äôs and I mean, C-Sharp is essentially exactly the same, except in minor details, but that mixture of object oriented programming and a rich class library is a good tool set to work with. And of course the tools on top, we use IntelliJ, make it immensely more productive. They solve many of the, you know, verbosity of problems the boiler plate problems that you get in any programming language, so.<p>[01:01:52] <strong>Yegor</strong>: Including XSLT.<p>[01:02:00] <strong>Michael</strong>: Yeah, and I wish IntelliJ had better support for XSLT, but.<p>[01:02:08] <strong>Yegor</strong>: But you can do some debugging there.<p>[01:02:09] <strong>Michael</strong>: You can, yes, but Oxygen does it much better. Partly because Oxygen works with us closely and redistributes our product and we have a good relationship with Oxygen. We‚Äôve never established a relationship with IntelliJ, with JetBrains. Well, I‚Äôve tried (chuckles).<p>[01:02:31] <strong>Yegor</strong>: Okay. Okay, my last question, Michael, do you need any help from volunteers for your projects or you have enough people in the team and that‚Äôs it?<p>[01:02:44] <strong>Michael</strong>: I‚Äôm not good at managing volunteers, let‚Äôs put it that way. Volunteers do need a lot of managing. We‚Äôve had some useful contributions over the years in code and ideas and tests but very often the volunteers only do the fun bit of the work and they leave us to do the boring bits. So the number of times people have suggested a code change and I‚Äôve said, yes, are you going to send us the tests? (laughing loudly) Or the documentation (chuckles)? And then you get this little blank look, (exclaims), tasks. (laughing loudly) It doesn‚Äôt help but in the past, we didn‚Äôt publish the test frameworks so we made it difficult, but yes, I regard programming as a professional engineering discipline. I don‚Äôt want to work in this sort of field where it‚Äôs being done by amateurs in their own time who aren‚Äôt paid and don‚Äôt necessarily share your objectives and aren‚Äôt working to your timelines and things like that, the sort of vast volunteer initiatives like Firefox, I don‚Äôt know how those work, I‚Äôve never participated in them. I can‚Äôt imagine how you can produce a decent bit of engineering in that sort of environment. So, yeah, but I mean the best contribution people, the best contributions we get are people testing the product when it comes out and sending us good bug reports. That‚Äôs immensely valuable and people don‚Äôt believe it when I say I actually appreciate it when people send in bug reports, I do, I love it. It‚Äôs an enormous contribution to the reliability of the product.<p>[01:04.58] <strong>Yegor</strong>: Oh yeah, I will send you a bug reports instead of posting questions on Stack Overflow. (laughing loudly) Because this is what I do now, is just go to Stack Overflow, I consider it a Stack Overflow as a sort of a bug reporting place, instead of.<p>[01:05:10] <strong>Michael</strong>: Yeah, it‚Äôs more than that, I mean, it‚Äôs also for many people, a help site. It‚Äôs a substitute for the fact that your colleagues don‚Äôt work at the next desk to you, the questions you would have asked, you know, to the person at the next desk, you now ask on Stack Overflow, but yes, it‚Äôs also a bug reporting site. It‚Äôs not actually a good way of managing bugs because there‚Äôs no way of saying, you know, give me a list of the open bugs and what their status is and how long they‚Äôve been open. So it‚Äôs, it doesn‚Äôt give that kind of management, but yeah, so if someone reports something on Stack Overflow, we transfer it to our bug reporting system and manage it that way, which works quite well.<p>[01:06:03] <strong>Yegor</strong>: Okay, thank you very much for coming. I only can wish you really good luck in the XSLT development, it seems that we are in the difficult time right now, so we definitely all love XSLT 1.0, XSLT 2.0, but (laughs), the future is not as clear as it seems, right, as it has to be.<p>[01:06:22] <strong>Michael</strong>: Well, thanks very much. It‚Äôs been fun talking about the wider issues and I hope people are listening and get some insights from that.<p>[01:06:32] <strong>Yegor</strong>: Definitely, thanks a lot.<p>[01:06:34] <strong>Michael</strong>: Okay, cheers, bye.<p>[01:06:36] <strong>Yegor</strong>: Bye-bye, bye.</div></article></div><div class="disqus"role="complementary"aria-hidden="true"><p class="disqus_hint">Please, use <a href="https://help.disqus.com/commenting/what-html-tags-are-allowed-within-comments">syntax highlighting</a> in your comments, to make them more readable.<div id="disqus_thread"class="disqus-thread"><a>&nbsp;</a></div><script>var disqus_config=function(){this.page.url=document.location.href.split("?")[0].split("#")[0],this.page.identifier=this.page.url};(()=>{var e=document,t=e.createElement("script");t.src="//yegor256.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript><div><p class="red">JavaScript is disabled in your browser, that's why you can't see comments under this post.</div></noscript></div><div class="wrapper"><footer class="footer"><p>&copy; <span itemscope=""itemprop="copyrightHolder"itemtype="http://schema.org/Person"><span itemprop="name">Yegor Bugayenko</span> </span>, 2014&ndash;<span itemprop="copyrightYear">2025</span></footer></div></section><div class="wrapper unprintable"style="text-align:center;margin-top:2em"><a href="https://www.sixnines.io/h/3ba1652f"><img src="https://www.sixnines.io/b/3ba1652f?style=flat"alt="sixnines availability badge"></a>&nbsp; <a href="https://github.com/yegor256/blog/stargazers"><img src="https://img.shields.io/github/stars/yegor256/blog.svg?style=flat-square"alt="GitHub stars"></a></div><script src="https://code.jquery.com/jquery-1.9.0.min.js"></script><script src="/js/all.js?3650590"></script><script type="application/ld+json">{ "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] }</script>