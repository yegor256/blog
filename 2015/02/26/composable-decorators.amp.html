<!doctypehtml><html amp lang="en"><meta charset="utf-8"><title>Composable Decorators vs. Imperative Utility Methods</title><link rel="canonical"href="https://www.yegor256.com/2015/02/26/composable-decorators.html"><link rel="icon"type="image/png"href="/favicon.ico"><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><script type="application/ld+json">{
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2015/02/26/composable-decorators.html"
        },
        "headline": "Composable Decorators vs. Imperative Utility Methods",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2015/02/russina-matroshka.jpg",
          "height": 763,
          "width": 1200
        },
        "datePublished": "2015-02-26",
        "dateModified": "2015-02-26",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "A decorator pattern, while being the best instrument to keep objects highly cohesive,
solid, and loosely coupled, is unfortunately not very popular in traditional Java
programming.
",
        "keywords": ["composable decorators", "decorator design pattern", "decorator pattern java", "decorator pattern example", "decorator pattern real life example"]
      }</script><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript><link rel="stylesheet"href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500"><style amp-custom="amp-custom">@font-face{font-family:Cambria;src:url(https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf)}body{font-family:Cambria,'Times New Roman',serif;padding:.5em;font-size:1.2em}article{width:600px;max-width:100%;margin-left:auto;margin-right:auto}code,pre{font-family:'Source Code Pro','Courier New',monospace;font-size:.8em}code{padding:0 .3em;background-color:#d3d3d3}a,a:hover,a:visited{color:inherit}.intro{color:red;font-size:.75em}.photo{border-radius:50%}pre{overflow-x:scroll}</style><script async src="https://cdn.ampproject.org/v0.js"></script><article><p class="intro">This is a mobile version, full one is <a href="https://www.yegor256.com/2015/02/26/composable-decorators.html">here</a>.<p><amp-img src="/images/face-256x256.jpg"width="80"height="80"alt="Yegor Bugayenko"class="photo"></amp-img><p>Yegor Bugayenko<br>26 February 2015<h1>Composable Decorators vs. Imperative Utility Methods</h1><p>The <a href="https://en.wikipedia.org/wiki/Decorator_pattern">decorator pattern</a> is my favorite among all other patterns I’m aware of. It is a very simple and yet very powerful mechanism to make your code <a href="https://en.wikipedia.org/wiki/Cohesion_%28computer_science%29">highly cohesive</a> and <a href="https://en.wikipedia.org/wiki/Coupling_%28computer_programming%29">loosely coupled</a>. However, I believe decorators are not used often enough. They should be everywhere, but they are not. The biggest advantage we get from decorators is that they make our code <em>composable</em>. That’s why the title of this post is composable decorators. Unfortunately, instead of decorators, we often use imperative utility methods, which make our code procedural rather than object-oriented.</p><amp-img src="/images/2015/02/russina-matroshka.jpg"alt=""height="763"width="1200"layout="responsive"></amp-img><p>First, a practical example. Here is an interface for an object that is supposed to read a text somewhere and return it:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Text</span> <span class="o">{</span>
  <span class="nc">String</span> <span class="nf">read</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>Here is an implementation that reads the text from a file:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="nc">TextInFile</span> <span class="kd">implements</span> <span class="nc">Text</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">File</span> <span class="n">file</span><span class="o">;</span>
  <span class="kd">public</span> <span class="nf">TextInFile</span><span class="o">(</span><span class="kd">final</span> <span class="nc">File</span> <span class="n">src</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">file</span> <span class="o">=</span> <span class="n">src</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">read</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">String</span><span class="o">(</span>
      <span class="nc">Files</span><span class="o">.</span><span class="na">readAllBytes</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">file</span><span class="o">.</span><span class="na">toPath</span><span class="o">()),</span> <span class="s">"UTF-8"</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>And now the decorator, which is another implementation of <code class="language-plaintext highlighter-rouge">Text</code> that removes all unprintable characters from the text:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="nc">PrintableText</span> <span class="kd">implements</span> <span class="nc">Text</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Text</span> <span class="n">origin</span><span class="o">;</span>
  <span class="kd">public</span> <span class="nf">PrintableText</span><span class="o">(</span><span class="kd">final</span> <span class="nc">Text</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">origin</span> <span class="o">=</span> <span class="n">text</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">read</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">origin</span><span class="o">.</span><span class="na">read</span><span class="o">()</span>
      <span class="o">.</span><span class="na">replaceAll</span><span class="o">(</span><span class="s">"[^\p{Print}]"</span><span class="o">,</span> <span class="s">""</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>Here is how I’m using it:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="nc">Text</span> <span class="n">text</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PrintableText</span><span class="o">(</span>
  <span class="k">new</span> <span class="nf">TextInFile</span><span class="o">(</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"/tmp/a.txt"</span><span class="o">))</span>
<span class="o">);</span>
<span class="nc">String</span> <span class="n">content</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
</code></pre></div></div><p>As you can see, the <code class="language-plaintext highlighter-rouge">PrintableText</code> doesn’t read the text from the file. It doesn’t really care where the text is coming from. It <em>delegates</em> text reading to the encapsulated instance of <code class="language-plaintext highlighter-rouge">Text</code>. How this encapsulated object will deal with the text and where it will get it doesn’t concern <code class="language-plaintext highlighter-rouge">PrintableText</code>.<p>Let’s <a href="/2016/04/19/object-must-not-be-configurable.html">continue</a> and try to create an implementation of <code class="language-plaintext highlighter-rouge">Text</code> that will capitalize all letters in the text:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="nc">AllCapsText</span> <span class="kd">implements</span> <span class="nc">Text</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Text</span> <span class="n">origin</span><span class="o">;</span>
  <span class="kd">public</span> <span class="nf">AllCapsText</span><span class="o">(</span><span class="kd">final</span> <span class="nc">Text</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">origin</span> <span class="o">=</span> <span class="n">text</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">read</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">origin</span><span class="o">.</span><span class="na">read</span><span class="o">().</span><span class="na">toUpperCase</span><span class="o">(</span><span class="nc">Locale</span><span class="o">.</span><span class="na">ENGLISH</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>How about a <code class="language-plaintext highlighter-rouge">Text</code> that trims the input:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="kd">class</span> <span class="nc">TrimmedText</span> <span class="kd">implements</span> <span class="nc">Text</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Text</span> <span class="n">origin</span><span class="o">;</span>
  <span class="kd">public</span> <span class="nf">TrimmedText</span><span class="o">(</span><span class="kd">final</span> <span class="nc">Text</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">origin</span> <span class="o">=</span> <span class="n">text</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">read</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">origin</span><span class="o">.</span><span class="na">read</span><span class="o">().</span><span class="na">trim</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>I can go on and on with these <a href="/2015/10/01/vertical-horizontal-decorating.html">decorators</a>. I can create many of them, suitable for their own individual use cases. But let’s see how they all can play together. Let’s say I want to read the text from the file, capitalize it, trim it, and remove all unprintable characters. And I want to be <em>declarative</em>. Here is what I do:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="nc">Text</span> <span class="n">text</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AllCapsText</span><span class="o">(</span>
  <span class="k">new</span> <span class="nf">TrimmedText</span><span class="o">(</span>
    <span class="k">new</span> <span class="nf">PrintableText</span><span class="o">(</span>
      <span class="k">new</span> <span class="nf">TextInFile</span><span class="o">(</span><span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"/tmp/a.txt"</span><span class="o">))</span>
    <span class="o">)</span>
  <span class="o">)</span>
<span class="o">);</span>
<span class="nc">String</span> <span class="n">content</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="na">read</span><span class="o">();</span>
</code></pre></div></div><p>First, I create an instance of <code class="language-plaintext highlighter-rouge">Text</code>, <em>composing</em> multiple decorators into a single object. I declaratively define the behavior of <code class="language-plaintext highlighter-rouge">text</code> without actually executing anything. Until method <code class="language-plaintext highlighter-rouge">read()</code> is called, the file is not touched and the processing of the text is not started. The object <code class="language-plaintext highlighter-rouge">text</code> is just a composition of decorators, not an executable <em>procedure</em>. Check out this article about declarative and imperative styles of programming: <a href="/2015/02/20/utility-classes-vs-functional-programming.html">Utility Classes Have Nothing to Do With Functional Programming</a>.<p>This design is much more flexible and reusable than a more traditional one, where the <code class="language-plaintext highlighter-rouge">Text</code> object is smart enough to perform all said operations. For example, class <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html"><code class="language-plaintext highlighter-rouge">String</code></a> from Java is a good example of a bad design. It has more than 20 <em>utility methods</em> that should have been provided as decorators instead: <code class="language-plaintext highlighter-rouge">trim()</code>, <code class="language-plaintext highlighter-rouge">toUpperCase()</code>, <code class="language-plaintext highlighter-rouge">substring()</code>, <code class="language-plaintext highlighter-rouge">split()</code>, and many others, for example. When I want to trim my string, uppercase it, and then split it into pieces, here is what my code will look like:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="nc">String</span> <span class="n">txt</span> <span class="o">=</span> <span class="s">"hello, world!"</span><span class="o">;</span>
<span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">parts</span> <span class="o">=</span> <span class="n">txt</span><span class="o">.</span><span class="na">trim</span><span class="o">().</span><span class="na">toUpperCase</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
</code></pre></div></div><p>This is imperative and procedural programming. Composable decorators, on the other hand, would make this code object-oriented and declarative. Something like this would be great to have in Java instead (pseudo-code):<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">parts</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">.</span><span class="na">Split</span><span class="o">(</span>
  <span class="k">new</span> <span class="nc">String</span><span class="o">.</span><span class="na">UpperCased</span><span class="o">(</span>
    <span class="k">new</span> <span class="nc">String</span><span class="o">.</span><span class="na">Trimmed</span><span class="o">(</span><span class="s">"hello, world!"</span><span class="o">)</span>
  <span class="o">)</span>
<span class="o">);</span>
</code></pre></div></div><p>To conclude, I recommend you think twice every time you add a new utility method to the interface/class. Try to avoid utility methods as much as possible, and use decorators instead. An <a href="/2016/04/26/why-inputstream-design-is-wrong.html">ideal interface</a> should contain only methods that you absolutely cannot remove. Everything else should be done through composable decorators.</article>