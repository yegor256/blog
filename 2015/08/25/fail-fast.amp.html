<!doctypehtml><html amp lang="en"><meta charset="utf-8"><title>Need Robust Software? Make It Fragile</title><link rel="canonical"href="https://www.yegor256.com/2015/08/25/fail-fast.html"><link rel="icon"type="image/png"href="/favicon.ico"><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><script type="application/ld+json">{
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2015/08/25/fail-fast.html"
        },
        "headline": "Need Robust Software? Make It Fragile",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2015/08/black-cat-white-cat.jpg",
          "height": 352,
          "width": 640
        },
        "datePublished": "2015-08-25",
        "dateModified": "2015-08-25",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "How to create robust and failure-resistant software---by making it fragile and fail fast, despite
intuitive desire to make it fail safe.
",
        "keywords": ["fail fast vs fail safe", "failure resilience", "fail fast", "fail safe", "robust architecture"]
      }</script><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript><link rel="stylesheet"href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500"><style amp-custom="amp-custom">@font-face{font-family:Cambria;src:url(https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf)}body{font-family:Cambria,'Times New Roman',serif;padding:.5em;font-size:1.2em}article{width:600px;max-width:100%;margin-left:auto;margin-right:auto}code,pre{font-family:'Source Code Pro','Courier New',monospace;font-size:.8em}code{padding:0 .3em;background-color:#d3d3d3}a,a:hover,a:visited{color:inherit}.intro{color:red;font-size:.75em}.photo{border-radius:50%}pre{overflow-x:scroll}</style><script async src="https://cdn.ampproject.org/v0.js"></script><article><p class="intro">This is a mobile version, full one is <a href="https://www.yegor256.com/2015/08/25/fail-fast.html">here</a>.<p><amp-img src="/images/face-256x256.jpg"width="80"height="80"alt="Yegor Bugayenko"class="photo"></amp-img><p>Yegor Bugayenko<br>25 August 2015<h1>Need Robust Software? Make It Fragile</h1><p>In any software project, the goal is to create something stable. We don’t want it to break in front of a user. We also don’t want our website to show an “internal application error” instead of a web page. We want our software to work, not fail. That’s a perfectly valid and logical desire, but in order to achieve that, we have to make our software as fragile as possible. This may sound counter-intuitive, but that’s the way it is. The more <em>fragile</em> your app is in development, the more <em>robust</em> it is in production.</p><amp-img src="/images/2015/08/black-cat-white-cat.jpg"alt="Black Cat, White Cat (1998) by Emir Kusturica"height="352"width="640"layout="responsive"></amp-img><p>By fragile, I’m referring to the <a href="https://martinfowler.com/ieeeSoftware/failFast.pdf">Fail Fast</a> philosophy, which is the opposite of Fail Safe. I believe you know the difference, but let me remind you anyway, by example. This is Fail Safe:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">(</span><span class="nc">File</span> <span class="n">file</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(!</span><span class="n">file</span><span class="o">.</span><span class="na">exists</span><span class="o">())</span> <span class="o">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">file</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>This method is supposed to calculate and return a file size. It first checks whether the file exists. If it doesn’t exist, the method returns zero. Indeed, the file is absent, so there is no size. We could complain that the file is absent, but what for? Why make noise? Let’s keep it quiet and return zero. We don’t fail because we’re trying to keep the app running. This is called Fail Safe.<p>To the contrary, this is how Fail Fast looks:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">(</span><span class="nc">File</span> <span class="n">file</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(!</span><span class="n">file</span><span class="o">.</span><span class="na">exists</span><span class="o">())</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span>
      <span class="s">"There is no such file; I can't get its length."</span>
    <span class="o">);</span>
  <span class="o">}</span>
  <span class="k">return</span> <span class="n">file</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>We can’t find a file? We don’t hide this fact. We make this situation public and visible. We scream and cry. We <a href="/2015/12/01/rethrow-exceptions.html">throw</a> an exception. We <em>want</em> the app to crash, break, and fail, because someone gave us a file that doesn’t exist. We complain and protest. This is called Fail Fast.<p>Which philosophy, if we follow it everywhere, will make our software robust and failure-resilient? Only the second one—the Fail Fast.<p>Why? Because the quicker and easier the failure is, the faster it will be fixed. And the fix will be simpler and also more visible. Fail Fast is a much better approach for maintainability. The code becomes cleaner. It is much easier to track a failure. All methods are ready to break and throw an exception on even the tiniest problem.<p>In this example, if the method returns zero, it’s not obvious whether the file exists and its size is actually zero or if its name is wrong and it is just not found. The Fail Safe approach <em>conceals</em> problems and makes code less maintainable, and that’s why it’s difficult to stabilize.<p>In the beginning, during production, we will have many crashes and errors. But all of them will be visible and easy to understand. We will fix them and cover them with unit tests. Each fix will make our software more <em>stable</em> and better covered by tests.<p>Software designed with the Fail Safe approach in mind will look more stable at the beginning, but it will degrade quickly and inevitably turn into an unmaintainable mess.<p>Software designed with the Fail Fast approach in mind will crash frequently at the beginning but will improve its stability with every fix and eventually become very stable and robust.<p>That’s why fragility is the key success factor for robustness.</article>