<!doctypehtml><html amp lang="en"><meta charset="utf-8"><title>Seven Deadly Sins of a Software Project</title><link rel="canonical"href="https://www.yegor256.com/2015/06/08/deadly-sins-software-project.html"><link rel="icon"type="image/png"href="/favicon.ico"><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><script type="application/ld+json">{
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2015/06/08/deadly-sins-software-project.html"
        },
        "headline": "Seven Deadly Sins of a Software Project",
        "image": {
          "@type": "ImageObject",
          "url": "https://www.yegor256.com/images/face-1024x1024.jpg",
          "height": 1400,
          "width": 1400
        },
        "datePublished": "2015-06-08",
        "dateModified": "2015-06-08",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Here is a list of criteria I apply to software projects
submitted for the Software Quality Award; they can
be applied equally to any other projects.
",
        "keywords": ["software project", "software project deliverables", "software project plan", "software project management", "software project lifecycle", "software maintainability"]
      }</script><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript><link rel="stylesheet"href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500"><style amp-custom="amp-custom">@font-face{font-family:Cambria;src:url(https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf)}body{font-family:Cambria,'Times New Roman',serif;padding:.5em;font-size:1.2em}article{width:600px;max-width:100%;margin-left:auto;margin-right:auto}code,pre{font-family:'Source Code Pro','Courier New',monospace;font-size:.8em}code{padding:0 .3em;background-color:#d3d3d3}a,a:hover,a:visited{color:inherit}.intro{color:red;font-size:.75em}.photo{border-radius:50%}pre{overflow-x:scroll}</style><script async src="https://cdn.ampproject.org/v0.js"></script><article><p class="intro">This is a mobile version, full one is <a href="https://www.yegor256.com/2015/06/08/deadly-sins-software-project.html">here</a>.<p><amp-img src="/images/face-256x256.jpg"width="80"height="80"alt="Yegor Bugayenko"class="photo"></amp-img><p>Yegor Bugayenko<br>8 June 2015<h1>Seven Deadly Sins of a Software Project</h1><p><em>Maintainability</em> is the <a href="/2014/10/26/hacker-vs-programmer-mentality.html">most valuable virtue</a> of modern software development. <a href="https://en.wikipedia.org/wiki/Maintainability">Maintainability</a> can basically be measured as the working time required for a new developer to learn the software before he or she can start making serious changes in it. The longer the time, the lower the maintainability. In some projects, this time requirement is close to infinity, which means it is literally unmaintainable. I believe there are seven fundamental and fatal <strong>sins</strong> that make our software unmaintainable. Here they are.<h2 id="anti-patterns">Anti-Patterns</h2><p>Unfortunately, the programming languages we’re using are too <em>flexible</em>. They allow too much and forbid too little. For example, Java has nothing against you placing the entire application in one single “class” with a few thousand methods. Technically, the application will compile and run. But it’s a well-known anti-pattern called a <a href="https://en.wikipedia.org/wiki/God_object">God object</a>.<p>Thus, an <a href="https://en.wikipedia.org/wiki/Anti-pattern">anti-pattern</a> is a technically acceptable way of designing things that is commonly agreed to be wrong. There are many anti-patterns in each language. Their presence in your product is similar to a tumor in a living organism. Once it starts to grow, it’s very difficult to stop. Eventually, the entire body dies. Eventually, the entire software becomes unmaintainable and has to be re-written.<p>Once you let a few anti-patterns in, you will eventually get more of them, and the “tumor” will only grow.<p>This is especially true for object-oriented languages (Java, C++, Ruby, and Python), mostly because they inherit so much from procedural languages (C, Fortran, and COBOL). And because <a href="/2016/08/15/what-is-wrong-object-oriented-programming.html">OOP</a> developers tend to think in a procedural and imperative way. Unfortunately.<p>By the way, in addition to an existing <a href="https://en.wikipedia.org/wiki/Anti-pattern">list of well-known anti-patterns</a>, I also consider <a href="/2014/09/10/anti-patterns-in-oop.html">these few things</a> as rather bad coding approaches.<p>My only practical suggestion here is to read and learn. Maybe <a href="/2015/04/22/favorite-software-books.html">these books</a> will help you or my book “<a href="/elegant-objects.html">Elegant Objects</a>.” Always try to be skeptical about the quality of your software, and don’t relax when it “just works.” Like with cancer, the earlier you diagnose it, greater is the chance to survive.<h2 id="untraceable-changes">Untraceable Changes</h2><p>When I look at the commit history, I should be able to tell for every single change <em>what</em> was changed, <em>who</em> made a change, and <em>why</em> the change was made. Moreover, the time required to get those three answers must be measured in seconds. In most projects, this is not the case. Here are a few practical recommendations:<p><strong>Always Use Tickets</strong>. No matter how small the project or its team is, even if it’s just yourself, create tickets (GitHub issues) for every problem you’re solving. Explain the problem briefly in the ticket and document your thinking there. Use the ticket as temporary storage for all information related to the problem. Post everything that could make any sense in the future, when someone else will try to understand what those “few strange commits” were about.<p><strong>Reference Tickets in Commits</strong>. Needless to say, every commit must have a message. Commits without messages are a very dirty practice; I won’t even discuss why. But just a message is not enough. Every message must start with the number of the ticket you’re working with. GitHub (I’m sure you are using it) will automatically link commits and tickets, increasing <em>traceability</em> of changes.<p><strong>Don’t Delete Anything</strong>. Git allows us to do a “forced” push, which overwrites the entire branch that previously existed on the server. This is just one example of how you can destroy the history of development. Many times I’ve also seen people delete their comments in GitHub discussions to make tickets look more “clean.” That’s just wrong. Never delete anything; let your history stay with you, no matter how bad (or messy) it may look to you now.<h2 id="ad-hoc-releases">Ad Hoc Releases</h2><p>Every piece of software must be packaged before it can be delivered to the end user. If it’s a Java library, it has to be packaged as a <code class="language-plaintext highlighter-rouge">.jar</code> file and released to some repository; if it’s a web app, it has to be deployed to some platform, etc. No matter how small or big the product is, there is always a standard procedure that tests, packages, and deploys.<p>An ideal solution would be to automate this procedure so it is possible to execute it from a command line with a single command:<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>./release.sh
...
DONE <span class="o">(</span>took 98.7s<span class="o">)</span>
</code></pre></div></div><p>Most projects are far from that. Their release process always involves some magic, where the person responsible for it (also known as a DevOp) has to click some buttons here and there, login somewhere, check some metrics, etc. Such an <em>ad hoc</em> release process is still a very typical sin of the entire software engineering industry.<p>I can give only one practical piece of advice here: Automate it. I use <a href="/2014/09/11/deployment-script-vs-rultor.html">rultor.com</a> for that, but you can use whatever tools you like. What is important is that the entire procedure is fully automated and can be executed from the command line.<h2 id="volunteer-static-analysis">Volunteer Static Analysis</h2><p><a href="https://en.wikipedia.org/wiki/Static_program_analysis">Static analysis</a> is what makes our code <em>look</em> better. And by making it look better, we are inevitably making it <em>work</em> better. But this happens only when the entire team is forced (!) to follow the rules dictated by the static analyzer(s). I’ve written about this in <a href="/2014/08/13/strict-code-quality-control.html">Strict Control of Java Code Quality</a>. I use <a href="https://www.qulice.com">qulice.com</a> in Java projects and <a href="https://github.com/bbatsov/rubocop">rubocop</a> in Ruby, but there are many similar tools for nearly every language.<p>You can use any of them, but make it mandatory! In most projects where static analysis is used, developers just build nicely-looking reports and continue to write code the way they did before. Such a “volunteer” approach is not doing any favors for the project. Moreover, it creates an illusion of quality.<p>What I’m saying is that static analysis must be a mandatory step in your deployment pipeline. The build can’t pass if any static analysis rule is violated.<h2 id="unknown-test-coverage">Unknown Test Coverage</h2><p>Simply put, <a href="https://en.wikipedia.org/wiki/Code_coverage">test coverage</a> is the degree to which the software has been <a href="/2015/07/16/fools-dont-write-unit-tests.html">tested</a> by unit or integration tests. The higher the coverage, the greater “amount” of code was executed while tests were running. Obviously, higher coverage is a good thing.<p>However, many project developers simply don’t know their coverage. They just don’t measure this metric. They may have some tests, but nobody knows how deeply they penetrate the software and what parts of it are not tested at all. This situation is much worse than low test coverage that is measured and reported to everyone.<p>High coverage is not a guarantee of high quality. That’s obvious. But unknown coverage is a clear indicator of maintainability problems. When a new developer enters the project, he or she should be able to make some changes and see how coverage is affected by them. Ideally, test coverage should be checked the same way as static analysis, and the build should fail if it comes out lower than a certain pre-defined threshold (usually somewhere around 80 percent).<h2 id="nonstop-development">Nonstop Development</h2><p>What I mean by nonstop is without milestones and releases. No matter what kind of software you’re writing, you must release and <a href="http://semver.org/">versionalize</a> it frequently. A project without a clear release history is an unmaintainable mess.<p>This is mostly because maintainability is all about me being able to understand you by reading your code.<p>When I look into the source code and its commit and release history, I have to be able to tell what the intention of its author(s) was, what the project was doing a year ago, where it is going now, what its roadmap is, etc. All this information must be in the source code and, more importantly, in Git history.<p><a href="https://git-scm.com/book/en/v2/Git-Basics-Tagging">Git tags</a> and GitHub <a href="https://github.com/blog/1547-release-your-software">release notes</a> are two powerful instruments that provide me such information. Use them to their full extent. Also, don’t forget that each binary version of the product must be available for immediate download. I have to be able to download version 0.1.3 and test it right now, even if the project is working on 3.4 at the moment.<h2 id="undocumented-interfaces">Undocumented Interfaces</h2><p>Every piece of software has interfaces through which it is supposed to be used. If it’s a Ruby gem, there are classes and methods that I’m going to use as an end user of it. If it’s a web app, there are web pages that an end user will see and control in order to use the app. Every software project has interfaces, and they must be carefully documented.<p>Like everything above, this is also about maintainability. As a new programmer on a project, I will start to learn about it from its interfaces. I should be able to understand what it does and try to use it myself.<p>I’m talking here about documentation for users, not for developers. In general, I’m against documentation inside the software. Here I totally agree with the <a href="http://agilemanifesto.org/">Agile Manifesto</a>—working software is much more important than comprehensive documentation. But that’s not referring to “external” documentation, which is supposed to be read by users, not developers.<p>So end-user interaction with the software must be clearly documented.<p>If your software is a library, then its end users are software developers who are going to use it—not contribute to it but simply use it as a “black box.”<hr><p>These are the criteria being used to evaluate the open source projects entered in our <a href="/2015/04/16/award.html">award</a> competition.</article>