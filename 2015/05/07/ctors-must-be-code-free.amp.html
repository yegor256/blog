<!doctypehtml><html amp lang="en"><meta charset="utf-8"><title>Constructors Must Be Code-Free</title><link rel="canonical"href="https://www.yegor256.com/2015/05/07/ctors-must-be-code-free.html"><link rel="icon"type="image/png"href="/favicon.ico"><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><script type="application/ld+json">{
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2015/05/07/ctors-must-be-code-free.html"
        },
        "headline": "Constructors Must Be Code-Free",
        "image": {
          "@type": "ImageObject",
          "url": "/images/2015/05/kill-bill.jpg",
          "height": 718,
          "width": 1694
        },
        "datePublished": "2015-05-07",
        "dateModified": "2015-05-07",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "It is a bad idea to put executing statements into class
constructors because that leads to side effects and
uncontrollable behavior.
",
        "keywords": ["how much code in constructors", "constructors in java", "oop constructors best practices", "best practices java constructors", "how much code to put into constructors"]
      }</script><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript><link rel="stylesheet"href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500"><style amp-custom="amp-custom">@font-face{font-family:Cambria;src:url(https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf)}body{font-family:Cambria,'Times New Roman',serif;padding:.5em;font-size:1.2em}article{width:600px;max-width:100%;margin-left:auto;margin-right:auto}code,pre{font-family:'Source Code Pro','Courier New',monospace;font-size:.8em}code{padding:0 .3em;background-color:#d3d3d3}a,a:hover,a:visited{color:inherit}.intro{color:red;font-size:.75em}.photo{border-radius:50%}pre{overflow-x:scroll}</style><script async src="https://cdn.ampproject.org/v0.js"></script><article><p class="intro">This is a mobile version, full one is <a href="https://www.yegor256.com/2015/05/07/ctors-must-be-code-free.html">here</a>.<p><amp-img src="/images/face-256x256.jpg"width="80"height="80"alt="Yegor Bugayenko"class="photo"></amp-img><p>Yegor Bugayenko<br>7 May 2015<h1>Constructors Must Be Code-Free</h1><p>How much work should be done within a constructor? It seems reasonable to do some computations inside a constructor and then encapsulate results. That way, when the results are required by object methods, we’ll have them ready. Sounds like a good approach? No, it’s not. It’s a bad idea for one reason: It prevents composition of objects and makes them un-extensible.</p><amp-img src="/images/2015/05/kill-bill.jpg"alt="Kill Bill: Vol. 2 (2004) by Quentin Tarantino"height="718"width="1694"layout="responsive"></amp-img><p>Let’s say we’re making an interface that would represent a name of a person:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">interface</span> <span class="nc">Name</span> <span class="o">{</span>
  <span class="nc">String</span> <span class="nf">first</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div><p>Pretty easy, right? Now, let’s try to implement it:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">EnglishName</span> <span class="kd">implements</span> <span class="nc">Name</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
  <span class="kd">public</span> <span class="nf">EnglishName</span><span class="o">(</span><span class="kd">final</span> <span class="nc">CharSequence</span> <span class="n">text</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">,</span> <span class="mi">2</span><span class="o">)[</span><span class="mi">0</span><span class="o">];</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">first</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>What’s wrong with this? It’s faster, right? It splits the name into parts only once and encapsulates them. Then, no matter how many times we call the <code class="language-plaintext highlighter-rouge">first()</code> method, it will return the same value and won’t need to do the splitting again. However, this is flawed thinking! Let me show you the right way and explain:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">EnglishName</span> <span class="kd">implements</span> <span class="nc">Name</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">CharSequence</span> <span class="n">text</span><span class="o">;</span>
  <span class="kd">public</span> <span class="nf">EnglishName</span><span class="o">(</span><span class="kd">final</span> <span class="nc">CharSequence</span> <span class="n">txt</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">text</span> <span class="o">=</span> <span class="n">txt</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">first</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">text</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="mi">2</span><span class="o">)[</span><span class="mi">0</span><span class="o">];</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>This is the right design. I can see you smiling, so let me prove my point.<p>Before I start proving, though, let me ask you to read this article: <a href="/2015/02/26/composable-decorators.html">Composable Decorators vs. Imperative Utility Methods</a>. It explains the difference between a static method and composable decorators. The first snippet above is very close to an imperative utility method, even though it looks like an object. The second example is a true object.<p>In the first example, we are abusing the <code class="language-plaintext highlighter-rouge">new</code> operator and turning it into a static method, which does all calculations for us <em>right here and now</em>. This is what <em>imperative</em> programming is about. In imperative programming, we do all calculations right now and return fully ready results. In declarative programming, we are instead trying to delay calculations for as long as possible.<p>Let’s try to use our <code class="language-plaintext highlighter-rouge">EnglishName</code> class:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="nc">Name</span> <span class="n">name</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">EnglishName</span><span class="o">(</span>
  <span class="k">new</span> <span class="nf">NameInPostgreSQL</span><span class="o">(</span><span class="cm">/*...*/</span><span class="o">)</span>
<span class="o">);</span>
<span class="k">if</span> <span class="o">(</span><span class="cm">/* something goes wrong */</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span>
    <span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span>
      <span class="s">"Hi, %s, we can't proceed with your application"</span><span class="o">,</span>
      <span class="n">name</span><span class="o">.</span><span class="na">first</span><span class="o">()</span>
    <span class="o">)</span>
  <span class="o">);</span>
<span class="o">}</span>
</code></pre></div></div><p>In the first line of this snippet, we are just making an instance of an object and labeling it <code class="language-plaintext highlighter-rouge">name</code>. We don’t want to go to the database yet and fetch the full name from there, split it into parts, and encapsulate them inside <code class="language-plaintext highlighter-rouge">name</code>. We just want to create an instance of an object. Such a parsing behavior would be a side effect for us and, in this case, will slow down the application. As you see, we may only need <code class="language-plaintext highlighter-rouge">name.first()</code> if something goes wrong and we need to construct an exception object.<p>My point is that having <strong>any</strong> computations done inside a constructor is a bad practice and must be avoided because they are side effects and are not requested by the object owner.<p>What about performance during the re-use of <code class="language-plaintext highlighter-rouge">name</code>, you may ask. If we make an instance of <code class="language-plaintext highlighter-rouge">EnglishName</code> and then call <code class="language-plaintext highlighter-rouge">name.first()</code> five times, we’ll end up with five calls to the <code class="language-plaintext highlighter-rouge">String.split()</code> method.<p>To solve that, we create another class, a <a href="/2015/02/26/composable-decorators.html">composable decorator</a>, which will help us solve this “re-use” problem:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">CachedName</span> <span class="kd">implements</span> <span class="nc">Name</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Name</span> <span class="n">origin</span><span class="o">;</span>
  <span class="kd">public</span> <span class="nf">CachedName</span><span class="o">(</span><span class="kd">final</span> <span class="nc">Name</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">origin</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="nd">@Cacheable</span><span class="o">(</span><span class="n">forever</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">first</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">origin</span><span class="o">.</span><span class="na">first</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>I’m using the <a href="https://aspects.jcabi.com/annotation-cacheable.html"><code class="language-plaintext highlighter-rouge">Cacheable</code></a> annotation from <a href="https://aspects.jcabi.com/">jcabi-aspects</a>, but you can use any other caching tools available in Java (or other languages), like <a href="https://github.com/google/guava/wiki/CachesExplained">Guava Cache</a>:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">CachedName</span> <span class="kd">implements</span> <span class="nc">Name</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Cache</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">cache</span> <span class="o">=</span>
    <span class="nc">CacheBuilder</span><span class="o">.</span><span class="na">newBuilder</span><span class="o">().</span><span class="na">build</span><span class="o">();</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Name</span> <span class="n">origin</span><span class="o">;</span>
  <span class="kd">public</span> <span class="nf">CachedName</span><span class="o">(</span><span class="kd">final</span> <span class="nc">Name</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">origin</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
  <span class="o">}</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">first</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span>
      <span class="mi">1L</span><span class="o">,</span>
      <span class="k">new</span> <span class="nc">Callable</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;()</span> <span class="o">{</span>
        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="nc">String</span> <span class="nf">call</span><span class="o">()</span> <span class="o">{</span>
          <span class="k">return</span> <span class="nc">CachedName</span><span class="o">.</span><span class="na">this</span><span class="o">.</span><span class="na">origin</span><span class="o">.</span><span class="na">first</span><span class="o">();</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div><p>But please don’t make <code class="language-plaintext highlighter-rouge">CachedName</code> mutable and lazily loaded—it’s an anti-pattern, which I’ve discussed before in <a href="/2014/06/09/objects-should-be-immutable.html">Objects Should Be Immutable</a>.<p>This is how our code will look now:<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="nc">Name</span> <span class="n">name</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CachedName</span><span class="o">(</span>
  <span class="k">new</span> <span class="nf">EnglishName</span><span class="o">(</span>
    <span class="k">new</span> <span class="nf">NameInPostgreSQL</span><span class="o">(</span><span class="cm">/*...*/</span><span class="o">)</span>
  <span class="o">)</span>
<span class="o">);</span>
</code></pre></div></div><p>It’s a very primitive example, but I hope you get the idea.<p>In this design, we’re basically splitting the object into two parts. The first one knows how to get the first name from the English name. The second one knows how to cache the results of this calculation in memory. And now it’s my decision, as a user of these classes, how exactly to use them. I will decide whether I need caching or not. This is what object composition is all about.<p>Let me reiterate that the only allowed statement inside a constructor is an assignment. If you need to put something else there, start thinking about refactoring—your class definitely needs a redesign.</article>