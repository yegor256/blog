<!DOCTYPE html>
<html amp lang="en">
  <head>

    <meta charset="utf-8">
    <title>A Few Thoughts on Unit Test Scaffolding</title>
    <link rel="canonical" href="http://www.yegor256.com/2015/05/25/unit-test-scaffolding.html">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "http://www.yegor256.com/2015/05/25/unit-test-scaffolding.html"
        },
        "headline": "A Few Thoughts on Unit Test Scaffolding",
        "image": {
          "@type": "ImageObject",
          "url": "https://cf.jare.io/?u=http://www.yegor256.com/images/2015/05/leon-the-professional.jpg",
          "height": 563,
          "width": 1200
        },
        "datePublished": "2015-05-25",
        "dateModified": "2015-05-25",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "http://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Most unit tests require mocks, stubs, and the preparation
of some other structures before a test can be initiated;
here is how I recommend you do that.
",
        "keywords": ["unit test scaffolding", "unit testing best practices", "unit testing mocks", "unit testing stubs", "unit testing of static"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <style amp-custom="amp-custom">
      body { padding: .5em; font-size: 1.2em; }
      article { width: 600px; max-width: 100%; margin-left: auto; margin-right: auto; }
      .intro { color: red; font-size: .75em; }
      .photo { border-radius: 50%; }
      pre { overflow-x:scroll; }
    </style>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <article>
      <p class="intro">
        This is a mobile version, full one is
        <a href="http://www.yegor256.com/2015/05/25/unit-test-scaffolding.html">here</a>.
      </p>
      <p>
        <amp-img src="/images/yegor-bugayenko-192x192.png" width="80" height="80" alt="Yegor Bugayenko" class="photo"></amp-img>
      </p>
      <p>Yegor Bugayenko<br>25 May 2015</p>
      <h1>A Few Thoughts on Unit Test Scaffolding</h1>
      <p>When I start to repeat myself in unit test methods by creating
the same objects and preparing the data to run the test,
I feel disappointed in my design. Long test methods with a lot of code
duplication just don't look right. To simplify and shorten them,
there are basically two options, at least in Java: 1) private properties
initialized through <code>@Before</code> and <code>@BeforeClass</code>, and 2)
<a href="/2017/02/07/private-method-is-new-class.html">private static methods</a>.
They both look anti-OOP to me, and I think there is an
alternative. Let me explain.</p>



<amp-img src="https://cf.jare.io/?u=http://www.yegor256.com/images/2015/05/leon-the-professional.jpg" alt="LÃ©on: The Professional by Luc Besson" height="563" width="1200" layout="responsive"></amp-img>

<p>JUnit officially suggests a
<a href="http://junit.org/faq.html#atests_2">test fixture</a>:</p>

<pre>public final class MetricsTest {
  private File temp;
  private Folder folder;
  @Before
  public void prepare() {
    this.temp = Files.createTempDirectory("test");
    this.folder = new DiscFolder(this.temp);
    this.folder.save("first.txt", "Hello, world!");
    this.folder.save("second.txt", "Goodbye!");
  }
  @After
  public void clean() {
    FileUtils.deleteDirectory(this.temp);
  }
  @Test
  public void calculatesTotalSize() {
    assertEquals(22, new Metrics(this.folder).size());
  }
  @Test
  public void countsWordsInFiles() {
    assertEquals(4, new Metrics(this.folder).wc());
  }
}</pre>

<p>I think it's obvious what this test is doing. First, in <code>prepare()</code>,
it creates a "test fixture" of type <code>Folder</code>. That is used in all three
tests as an argument for the <code>Metrics</code> constructor. The real class being
tested here is <code>Metrics</code> while <code>this.folder</code> is something we need
in order to test it.</p>

<p>What's wrong with this test? There is one serious issue:
<strong>coupling</strong> between test methods. Test methods (and all tests in general)
must be perfectly isolated from each other. This means that changing
one test must not affect any others. In this example, that is not the case.
When I want to change the <code>countsWords()</code> test, I have to change the internals
of <code>before()</code>, which will affect the other method in the test "class."</p>

<p>With all due respect to JUnit, the idea of creating test fixtures in
<code>@Before</code> and <code>@After</code> is wrong, mostly because it encourages
developers to couple test methods.</p>

<p>Here is how we can improve our test and isolate test methods:</p>

<pre>public final class MetricsTest {
  @Test
  public void calculatesTotalSize() {
    final File dir = Files.createTempDirectory("test-1");
    final Folder folder = MetricsTest.folder(
      dir,
      "first.txt:Hello, world!",
      "second.txt:Goodbye!"
    );
    try {
      assertEquals(22, new Metrics(folder).size());
    } finally {
      FileUtils.deleteDirectory(dir);
    }
  }
  @Test
  public void countsWordsInFiles() {
    final File dir = Files.createTempDirectory("test-2");
    final Folder folder = MetricsTest.folder(
      dir,
      "alpha.txt:Three words here",
      "beta.txt:two words"
      "gamma.txt:one!"
    );
    try {
      assertEquals(6, new Metrics(folder).wc());
    } finally {
      FileUtils.deleteDirectory(dir);
    }
  }
  private static Folder folder(File dir, String... parts) {
    Folder folder = new DiscFolder(dir);
    for (final String part : parts) {
      final String[] pair = part.split(":", 2);
      this.folder.save(pair[0], pair[1]);
    }
    return folder;
  }
}</pre>

<p>Does it look better now? We're not there yet, but now our test
methods are perfectly isolated. If I want to change one of them,
I'm not going to affect the others because I pass all configuration
parameters to a private static utility (!) method <code>folder()</code>.</p>

<p>A utility method, huh? Yes,
<a href="/2014/05/05/oop-alternative-to-utility-classes.html">it smells</a>.</p>

<p>The main issue with this design, even though it is way better than
the previous one, is that it doesn't prevent code duplication between
test "classes." If I need a similar test fixture of type <code>Folder</code> in
another test case, I will have to move this static method there. Or
even worse, I will have to create a utility class.
Yes, there is <a href="/2015/02/20/utility-classes-vs-functional-programming.html">nothing worse</a>
in object-oriented programming than utility classes.</p>

<p>A much better design would be to use
<a href="/2014/09/23/built-in-fake-objects.html">"fake" objects</a>
instead of private static utilities. Here is how. First, we create a fake class
and place it into <code>src/main/java</code>. This class can be used in tests
and also in production code, if necessary (<code>Fk</code> for "fake"):</p>

<pre>public final class FkFolder implements Folder, Closeable {
  private final File dir;
  private final String[] parts;
  public FkFolder(String... prts) {
    this(Files.createTempDirectory("test-1"), parts);
  }
  public FkFolder(File file, String... prts) {
    this.dir = file;
    this.parts = parts;
  }
  @Override
  public Iterable&lt;File&gt; files() {
    final Folder folder = new DiscFolder(this.dir);
    for (final String part : this.parts) {
      final String[] pair = part.split(":", 2);
      folder.save(pair[0], pair[1]);
    }
    return folder.files();
  }
  @Override
  public void close() {
    FileUtils.deleteDirectory(this.dir);
  }
}</pre>

<p>Here is how our test will look now:</p>

<pre>public final class MetricsTest {
  @Test
  public void calculatesTotalSize() {
    final String[] parts = {
      "first.txt:Hello, world!",
      "second.txt:Goodbye!"
    };
    try (final Folder folder = new FkFolder(parts)) {
      assertEquals(22, new Metrics(folder).size());
    }
  }
  @Test
  public void countsWordsInFiles() {
    final String[] parts = {
      "alpha.txt:Three words here",
      "beta.txt:two words"
      "gamma.txt:one!"
    };
    try (final Folder folder = new FkFolder(parts)) {
      assertEquals(6, new Metrics(folder).wc());
    }
  }
}</pre>

<p>What do you think? Isn't it better than what JUnit offers?
Isn't it more reusable and extensible than utility methods?</p>

<p>To summarize, I believe scaffolding in unit testing must be
done through
<a href="/2014/09/23/built-in-fake-objects.html">fake objects</a>
that are shipped together with production code.</p>

    </article>
  </body>
</html>
