<!DOCTYPE html>
<html amp lang="en">
  <head>

    <meta charset="utf-8">
    <title>Every Build in Its Own Docker Container</title>
    <link rel="canonical" href="https://www.yegor256.com/2014/07/29/docker-in-rultor.html">
    <link rel="icon" type="image/png" href="/favicon.ico">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "mainEntityOfPage":{
          "@type": "WebPage",
          "@id": "https://www.yegor256.com/2014/07/29/docker-in-rultor.html"
        },
        "headline": "Every Build in Its Own Docker Container",
        "image": {
          "@type": "ImageObject",
          "url": "https://www.yegor256.com/images/face-1024x1024.jpg",
          "height": 1400,
          "width": 1400
        },
        "datePublished": "2014-07-29",
        "dateModified": "2014-07-29",
        "author": {
          "@type": "Person",
          "name": "Yegor Bugayenko"
        },
        "publisher": {
          "@type": "Organization",
          "name": "yegor256.com",
          "logo": {
            "@type": "ImageObject",
            "url": "https://www.yegor256.com/images/face-512x512.jpg",
            "width": 512,
            "height": 512
          }
        },
        "description": "Rultor.com runs every build in its own Docker container,
perfectly isolating configurations and making them cacheable and reproducible.
",
        "keywords": ["continuous integration", "docker continuous integration", "continuous delivery", "docker continuous delivery", "jenkins docker", "docker builds ci", "unit tests in docker"]
      }
    </script>
    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style>
<noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500">
    <style amp-custom="amp-custom">
      @font-face {
        font-family: 'Cambria';
        src: url('https://www.yegor256.com/fonts/cambria/2EAA54_2_0.ttf');
      }
      body { font-family: 'Cambria', 'Times New Roman', serif; padding: .5em; font-size: 1.2em; }
      article { width: 600px; max-width: 100%; margin-left: auto; margin-right: auto; }
      pre, code { font-family: 'Source Code Pro', 'Courier New', monospace; font-size: .8em; }
      code { padding: 0 .3em; background-color: lightgray; }
      a, a:hover, a:visited { color: inherit; }
      .intro { color: red; font-size: .75em; }
      .photo { border-radius: 50%; }
      pre { overflow-x:scroll; }
    </style>
    <script async src="https://cdn.ampproject.org/v0.js"></script>
  </head>
  <body>
    <article>
      <p class="intro">
        This is a mobile version, full one is
        <a href="https://www.yegor256.com/2014/07/29/docker-in-rultor.html">here</a>.
      </p>
      <p>
        <amp-img src="/images/face-256x256.jpg" width="80" height="80" alt="Yegor Bugayenko" class="photo"></amp-img>
      </p>
      <p>Yegor Bugayenko<br>29 July 2014</p>
      <h1>Every Build in Its Own Docker Container</h1>
      

<p><a href="https://www.docker.io">Docker</a> is a command line tool that
can run a shell command in a virtual Linux, inside an isolated file system.
Every time we build our projects, we want them to run in their own
Docker containers. Take this Maven project for example:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>docker run <span class="nt">-i</span> <span class="nt">-t</span> ubuntu mvn clean <span class="nb">test</span>
</code></pre></div></div>



<p>This command will start a new Ubuntu system and execute
<code class="language-plaintext highlighter-rouge">mvn clean test</code> inside it. <a href="https://www.rultor.com">Rultor.com</a>, our
virtual assistant, does exactly that with our builds, when we
deploy, package, test and merge them.</p>



<h2 id="why-docker">Why Docker?</h2>

<p>What benefits does it give us? And why
<a href="/2014/08/29/docker-non-root.html">Docker</a>,
when there are many <a href="https://en.wikipedia.org/wiki/Operating_system-level_virtualization">other virtualization technologies</a>,
like LXC, for example?</p>

<p>Well, there are a few very important benefits:</p>

<ul>
  <li>
    <p>Image repository (hub.docker.com)</p>
  </li>
  <li>
    <p>Versioning</p>
  </li>
  <li>
    <p>Application-centric</p>
  </li>
</ul>

<p>Let’s discuss them in details.</p>

<h2 id="image-repository">Image Repository</h2>

<p>Docker enables image sharing through its public repository at
<a href="http://hub.docker.com">hub.docker.com</a>. This means that after
I prepare a working environment for my application, I make
an image out of it and push it to the hub.</p>

<p>Let’s say, I want my Maven build to be executed in a container
with a pre-installed <code class="language-plaintext highlighter-rouge">graphviz</code> package (in order to enable <code class="language-plaintext highlighter-rouge">dot</code> command line tool).
First, I would start a plain vanilla Ubuntu container, and install <code class="language-plaintext highlighter-rouge">graphviz</code> inside it:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sudo docker run -i -t ubuntu /bin/bash
root@215d2696e8ad:/# sudo apt-get install -y graphviz
Reading package lists... Done
Building dependency tree
Reading state information... Done
The following extra packages will be installed:
...
root@215d2696e8ad:/# exit
$ sudo docker ps -a
CONTAINER ID        IMAGE               COMMAND             CREATED              STATUS                     PORTS               NAMES
215d2696e8ad        ubuntu:14.04        /bin/bash           About a minute ago   Exited (0) 3 seconds ago                       high_mccarthy
</code></pre></div></div>

<p>I have a container that stopped a few seconds ago. Container’s
ID is <code class="language-plaintext highlighter-rouge">215d2696e8ad</code>. Now, I want to make it reusable for all
further tests in Rultor.com. I have to create an image from it:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>docker commit 215d2696e8ad yegor256/beta
c5ad7718fc0e20fe4bf2c8a9bfade4db8617a25366ca5b64be2e1e8aa0de6e52
</code></pre></div></div>

<p>I just made my new commit to a new image <code class="language-plaintext highlighter-rouge">yegor256/beta</code>.
This image can be reused right now. I can create a new container
from this image and it will have <code class="language-plaintext highlighter-rouge">graphviz</code> installed inside!</p>

<p>Now it’s time to share my image at Docker hub, in order to make it available for Rultor:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sudo docker push yegor256/beta
The push refers to a repository [yegor256/beta] (len: 1)
Sending image list
Pushing repository yegor256/beta (1 tags)
511136ea3c5a: Image already pushed, skipping
d7ac5e4f1812: Image already pushed, skipping
2f4b4d6a4a06: Image already pushed, skipping
83ff768040a0: Image already pushed, skipping
6c37f792ddac: Image already pushed, skipping
e54ca5efa2e9: Image already pushed, skipping
c5ad7718fc0e: Image successfully pushed
Pushing tag for rev [c5ad7718fc0e] on {https://registry-1.docker.io/v1/repositories/yegor256/beta/tags/latest}
</code></pre></div></div>

<p>The last step is to configure Rultor to use this image in
all builds. To do this, I will edit <a href="https://doc.rultor.com/reference.html"><code class="language-plaintext highlighter-rouge">.rultor.yml</code></a>
in the root directory of my GitHub repository:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker:
  image: yegor256/beta
</code></pre></div></div>

<p>That’s it. From now on, Rultor will use my custom Docker image with
pre-installed <code class="language-plaintext highlighter-rouge">graphviz</code>, in every build (merge, release, deploy, etc.)</p>

<p>Moreover, if and when I want to add something else to the image,
it’s easy to do. Say, I want to install Ruby into my build image.
I start a container from the image and install it (pay attention,
I’m starting a container not from <code class="language-plaintext highlighter-rouge">ubuntu</code> image, as I did before, but from <code class="language-plaintext highlighter-rouge">yegor256/beta</code>):</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sudo docker run -i -t yegor256/beta /bin/bash
root@7e0fbd9806c9:/# sudo apt-get install -y ruby
Reading package lists... Done
Building dependency tree
Reading state information... Done
The following extra packages will be installed:
...
root@7e0fbd9806c9:/# exit
$ sudo docker ps -a
CONTAINER ID        IMAGE                  COMMAND             CREATED             STATUS                     PORTS               NAMES
7e0fbd9806c9        yegor256/beta:latest   /bin/bash           28 seconds ago      Exited (0) 2 seconds ago                       pensive_pare
215d2696e8ad        ubuntu:14.04           /bin/bash           10 minutes ago      Exited (0) 8 minutes ago                       high_mccarthy
</code></pre></div></div>

<p>You can now see that I have two containers. The first one is the one
I am using right now; it contains Ruby. The second one is the one
I was using before and it contains <code class="language-plaintext highlighter-rouge">graphviz</code>.</p>

<p>Now I have to commit again and push:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>docker commit 7e0fbd9806c9 yegor256/beta
6cbfb7a6b18a2182f42171f6bb5aef67c4819b5c2795edffa6a63ba78aaada2d
<span class="nv">$ </span><span class="nb">sudo </span>docker push yegor256/beta
...
</code></pre></div></div>

<p>Thus, this Docker hub is a very convenient feature for Rultor and similar systems.</p>

<h2 id="versioning">Versioning</h2>

<p>As you saw in the example above, every change to a Docker image has
its own version (hash) and it’s possible to track changes.
It is also possible to roll back to any particular change.</p>

<p>Rultor is not using this functionality itself, but Rultor users
are able to control their build configurations with much better precision.</p>

<h2 id="application-centric">Application-Centric</h2>

<p>Docker, unlike LXC or Vagrant, for example, is application-centric.
This means that when we start a container—we start an application.
With other virtualization technologies, when you get a virtual machine—you get a fully functional Unix environment, where you can login through
SSH and do whatever you want.</p>

<p>Docker makes things simpler. It doesn’t give you SSH access to container,
but runs an application inside and shows you its output. This is
exactly what we need in Rultor. We need to run an automated build
(for example Maven or Bundler), see its output and get its exit code.
If the code is not zero, we fail the build and report to the user.</p>

<p>This is how we run Maven build:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>docker run <span class="nt">--rm</span> <span class="nt">-i</span> <span class="nt">-t</span> yegor256/rultor mvn clean <span class="nb">test</span>
<span class="o">[</span>INFO] <span class="nt">------------------------------------------------------------------------</span>
<span class="o">[</span>INFO] Building jcabi-github 0.13
<span class="o">[</span>INFO] <span class="nt">------------------------------------------------------------------------</span>
<span class="o">[</span>INFO]
<span class="o">[</span>INFO] <span class="nt">---</span> maven-clean-plugin:2.5:clean <span class="o">(</span>default-clean<span class="o">)</span> @ jcabi-github <span class="nt">---</span>
<span class="o">[</span>INFO]
...
</code></pre></div></div>

<p>As you can see, Maven starts immediately. We don’t worry
about the internals of the container. We just start an application inside it.</p>

<p>Furthermore, thanks to the <code class="language-plaintext highlighter-rouge">--rm</code> option, the container gets
destroyed immediately after Maven execution is finished.</p>

<p>This is what application-centric is about.</p>

<p>Our overall impression of Docker is highly positive.</p>

<p>ps. A compact version of this article was published at
<a href="http://devops.com/blogs/build-docker-containers/">devops.com</a></p>

    </article>
  </body>
</html>
