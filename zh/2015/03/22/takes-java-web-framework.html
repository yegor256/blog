<!doctypehtml><html xmlns="http://www.w3.org/1999/xhtml"lang="en-US"xml:lang="en-US"itemscope=""itemtype="http://schema.org/WebSite"><meta charset="utf-8"><meta name="description"content="Takes is a pure object-oriented and immutable Java web framework that turns the design and development of web applications into a pleasant and fun process."><meta name="keywords"content=""><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><meta name="google-site-verification"content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8"><meta name="author"content="Yegor Bugayenko"><meta name="og:site_name"content="Yegor Bugayenko"><meta name="og:type"content="article"><meta name="og:locale"content="en_US"><meta name="twitter:account_id"content="4503599630178231"><meta name="twitter:creator"content="@yegor256"><meta name="twitter:site"content="@yegor256"><meta name="twitter:title"property="og:title"content="Java Web App Architecture In Takes Framework"><meta name="twitter:description"property="og:description"content="Takes is a pure object-oriented and immutable Java web framework that turns the design and development of web applications into a pleasant and fun process."><meta name="twitter:url"property="og:url"content="https://www.yegor256.com/zh/2015/03/22/takes-java-web-framework.html"><meta name="telegram:channel"content="AAAAAEJFMRzsRTRxM3ec6A"><link rel="search"type="application/opensearchdescription+xml"href="/opensearch.xml"title="yegor256"><link rel="shortcut icon"href="/favicon.ico?b0f3971423a"><link rel="apple-touch-icon"href="/favicon.ico?b0f3971423a"><link rel="alternate"type="application/rss+xml"title="RSS for yegor256.com"href="https://www.yegor256.com/rss.xml"><link rel="stylesheet"href="/css/layout.css?b0f3971423a"><link rel="stylesheet"href="/css/icons.css?b0f3971423a"><link rel="canonical"href="https://www.yegor256.com/zh/2015/03/22/takes-java-web-framework.html"><title>Java Web App Architecture In Takes Framework</title><div class="wrapper"><aside class="header-toggle unprintable"id="header-toggle"title="Show the menu"onclick='$("#header").show(),$("#header-toggle").hide()'>&#9776;</aside><header class="header"id="header"><div class="face"><a href="/about-me.html#form"class="sub"title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html"style="position:relative"><img src="/images/face-256x256.jpg"class="photo"alt="Yegor Bugayenko"></a></div><nav><ul class="menu social notranslate"><li><a href="https://twitter.com/intent/follow?screen_name=yegor256"rel="nofollow"title="Follow me on Twitter"><i class="icon icon-twitter notranslate"aria-hidden="true"></i></a><li><a href="/rss.xml"rel="nofollow"title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://github.com/yegor256"rel="nofollow"title="My GitHub profile"><i class="icon icon-github notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="http://stackoverflow.com/users/187141/yegor256"rel="nofollow"title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://www.facebook.com/yegor256"rel="nofollow"title="Follow me on Facebook"><i class="icon icon-facebook notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://instagram.com/yegor256"rel="nofollow"title="Follow me on Instagram"><i class="icon icon-instagram notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://www.linkedin.com/in/yegor256"rel="nofollow"title="My LinkedIn profile"><i class="icon icon-linkedin notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://www.youtube.com/c/yegor256?sub_confirmation=1"rel="nofollow"title="My Youtube video channel"><i class="icon icon-youtube notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://www.pinterest.com/yegor256/"rel="nofollow"title="My Pinterest boards"><i class="icon icon-pinterest notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://angel.co/yegor256"rel="nofollow"title="My AngelList profile"><i class="icon icon-angellist notranslate"aria-hidden="true"></i></a><li><a href="https://soundcloud.com/yegor256"rel="nofollow"title="My podcast"><i class="icon icon-podcast notranslate"aria-hidden="true"></i></a><li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721"rel="nofollow"title="My iTunes podcast"><i class="icon icon-itunes notranslate"aria-hidden="true"></i></a><li><a href="https://t.me/yegor256news"rel="nofollow"title="My Telegram public channel"><i class="icon icon-telegram notranslate"aria-hidden="true"></i></a><li><a href="mailto:blog@yegor256.com"rel="nofollow"title="Email me any time"><i class="icon icon-mail notranslate"aria-hidden="true"></i></a></ul><ul class="menu"><li><a href="/"title="Home page">Home</a><li><a href="/best.html"title="Best articles to read">12&#160;Best</a><li><a href="/contents.html"title="The contents of the entire blog">All&#160;390</a><li><a href="/teaching.html"title="My courses and lectures">Teaching</a><li><a href="/talks.html"title="Future and past conference talks">Talks</a><li><a href="/books.html"title="The books I wrote">Books</a><li><a href="/research.html"title="My research directions and progress">Research</a><li><a href="/pets.html"title="My loved pet projects">Pets</a><li><a href="/testimonials.html"title="What some people say about me">Testimonials</a><li><a href="/shift-m.html"title="Audio podcast about project management">Shift-M</a><li><a href="/paintings.html"title="My paintings for sale">Art</a><li><a href="https://ru.yegor256.com/"title="Немного на русском языке о политике в России, Украине и мире">Политика</a></ul></nav><div class="search"><form action="https://www.google.com/search"itemprop="potentialAction"itemscope=""itemtype="http://schema.org/SearchAction"><meta itemprop="target"content="https://www.google.com/search?q={q}"><input name="sitesearch"value="yegor256.com"type="hidden"> <input itemprop="query-input"id="search-query"class="field field-text"required="required"onfocus='$(".google").css("visibility","visible")'name="q"placeholder="Search..."autocomplete="off"> <input type="image"src="/images/google-search-icon.svg"class="google"title="Search via Google"alt="Search via Google"></form></div><div class="hot"><ul></ul></div></header></div><section itemscope=""itemtype="http://schema.org/BlogPosting"><div class="wrapper"><header><h1 itemprop="name headline mainEntityOfPage">Java Web App Architecture In Takes Framework</h1></header><article class="main"itemprop="articleBody"style="font-family:sans-serif;font-size:.9em;line-height:1.2em"><p style="color:#c42c00">The following text is a <em>partial</em> translation of the <a href="https://www.yegor256.com/2015/03/22/takes-java-web-framework.html">original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:<p>我曾经使用Servlets、JSP、JAX-RS、Spring Framework、Play Framework、JSF with Facelets和一点Spark Framework。在我个人的观点中，所有这些解决方案都离面向对象和优雅的目标相差甚远。它们都充斥着静态方法、无法测试的数据结构和肮脏的黑科技。因此，大约一个月前，我决定创建自己的Java Web框架。我将几个基本原则融入到了它的基础中：1）不使用NULL，2）不使用公共静态方法，3）不使用可变类，4）不使用类转换、反射和<code class="language-plaintext highlighter-rouge">instanceof</code>操作符。这四个基本原则应该能够保证代码的整洁和架构的透明。这就是<a href="http://www.takes.org">Takes</a>框架的诞生方式。让我们看看它是如何被创建出来并且如何工作的。<p>这是我对Web应用程序架构及其组件的简单理解。<p>首先，要创建一个Web服务器，我们需要创建一个新的<a href="http://en.wikipedia.org/wiki/Network_socket">网络套接字</a>，它在特定的<a href="http://en.wikipedia.org/wiki/Port_%28computer_networking%29">TCP端口</a>上接受连接。通常情况下是80，但我将使用8080进行测试。在Java中，可以使用<a href="http://docs.oracle.com/javase/7/docs/api/java/net/ServerSocket.html"><code class="language-plaintext highlighter-rouge">ServerSocket</code></a>类来完成这个任务：<p>这就足够启动一个Web服务器了。现在，套接字已准备好，并在8080端口上进行监听。当有人在浏览器中打开<code class="language-plaintext highlighter-rouge">http://localhost:8080</code>时，连接将建立并浏览器将永远旋转等待。编译这段代码片段并尝试一下。我们刚刚构建了一个简单的Web服务器，没有使用任何框架。目前我们还没有对传入的连接进行任何操作，但我们也没有拒绝它们。所有的连接都被排列在那个<code class="language-plaintext highlighter-rouge">server</code>对象里。这是在后台线程中完成的；这就是为什么我们需要在后面放置那个<code class="language-plaintext highlighter-rouge">while(true)</code>的原因。如果没有这个无限暂停，应用程序将立即完成执行，并关闭服务器套接字。<p>下一步是接受传入的连接。在Java中，这通过对<code class="language-plaintext highlighter-rouge">accept()</code>方法进行阻塞调用来完成：<p>该方法会阻塞其线程并等待新连接的到来。一旦发生这种情况，它会返回一个<code class="language-plaintext highlighter-rouge">Socket</code>实例。为了接受下一个连接，我们应该再次调用<code class="language-plaintext highlighter-rouge">accept()</code>。所以基本上，我们的Web服务器应该按照以下方式工作：<p>这是一个无止境的循环，它接受一个新的连接，理解它，创建一个响应，返回响应，并再次接受新的连接。HTTP协议是无状态的，这意味着服务器不应该记住任何先前连接中发生的事情。它只关心这个特定连接中传入的HTTP请求。<p>HTTP请求来自于套接字的输入流，看起来像一个多行文本块。如果你读取套接字的输入流，你会看到这样的内容：<p>你会看到类似于这样的东西：<p>客户端（例如Google Chrome浏览器）将此文本传递给建立的连接。它连接到<code class="language-plaintext highlighter-rouge">localhost</code>的8080端口，一旦连接准备就绪，它立即将此文本发送到连接中，然后等待响应。<p>我们的任务是使用请求中获得的信息创建HTTP响应。如果我们的服务器非常简单，我们可以基本上忽略请求中的所有信息，并只返回”Hello, world!”给所有请求（为了简单起见，我使用<a href="https://commons.apache.org/proper/commons-io/javadocs/api-2.5/org/apache/commons/io/IOUtils.html"><code class="language-plaintext highlighter-rouge">IOUtils</code></a>）。<p>就是这样。服务器已准备好。尝试编译并运行它。将您的浏览器指向 <code class="language-plaintext highlighter-rouge">http://localhost:8080</code>，您将看到 <code class="language-plaintext highlighter-rouge">Hello, world!</code>。<p>这就是构建Web服务器所需的全部内容。现在让我们来讨论如何使其面向对象和可组合。让我们尝试看看<a href="http://www.takes.org">Takes</a>框架是如何构建的。<p>Routing/dispatching在Takes中与response printing结合在一起。您只需要创建一个实现<a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/Take.html"><code class="language-plaintext highlighter-rouge">Take</code></a>接口的单个类，就可以创建一个工作的web应用程序。<p>现在是时候启动服务器了：<p>这个 <a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/http/FtBasic.html"><code class="language-plaintext highlighter-rouge">FtBasic</code></a> 类执行了上述解释的完全相同的套接字操作。它在端口8080上启动一个服务器套接字，并通过我们传递给它的 <code class="language-plaintext highlighter-rouge">TkFoo</code> 实例来分派所有传入的连接。它通过一个 <a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/http/Exit.html"><code class="language-plaintext highlighter-rouge">Exit</code></a> 的实例在一个无限循环中进行这个分派，并每秒检查是否停止。显然，<code class="language-plaintext highlighter-rouge">Exit.NEVER</code> 总是回答说：“请不要停止。”<p>现在让我们看看到达<code class="language-plaintext highlighter-rouge">TkFoo</code>的HTTP请求中有什么，以及我们可以从中获得什么。这是<a href="http://www.takes.org">Takes</a>中<code class="language-plaintext highlighter-rouge">Request</code>接口的定义方式。<p>请求分为两部分：头部和正文。头部包含所有在正文开始的空行之前的所有行，根据HTTP规范在<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html">RFC 2616</a>中定义。框架中有许多有用的修饰符可用于<code class="language-plaintext highlighter-rouge">Request</code>。例如，<code class="language-plaintext highlighter-rouge">RqMethod</code>可以帮助您从头部的第一行获取方法名。<p><code class="language-plaintext highlighter-rouge">RqHref</code> will help extract the query part and parse it. For example, this is the request:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /user?id=123 HTTP/1.1
Host: www.example.com
</code></pre></div></div><p>这段代码将提取<code class="language-plaintext highlighter-rouge">123</code>：<p><code class="language-plaintext highlighter-rouge">RqPrint</code> can get the entire request or its body printed as a <code class="language-plaintext highlighter-rouge">String</code>:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>final String body = new RqPrint(request).printBody();
</code></pre></div></div><p>这里的想法是保持<code class="language-plaintext highlighter-rouge">Request</code>接口简单，并将此请求解析功能提供给其装饰器。这种方法有助于框架保持类小而有凝聚力。每个装饰器都非常小而坚实，只做一件事。所有这些装饰器都在<a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/rq/package-summary.html"><code class="language-plaintext highlighter-rouge">org.takes.rq</code></a>包中。正如您可能已经理解的，<code class="language-plaintext highlighter-rouge">Rq</code>前缀代表<code class="language-plaintext highlighter-rouge">Request</code>。<p>让我们创建我们的第一个真正的网页应用程序，它将会做一些有用的事情。我建议从一个<code class="language-plaintext highlighter-rouge">Entry</code>类开始，这是Java在命令行中启动应用程序所必需的。<p>这个类只包含一个<code class="language-plaintext highlighter-rouge">main()</code>静态方法，当应用程序从命令行启动时，JVM将调用该方法。正如你所见，它实例化<a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/http/FtCli.html"><code class="language-plaintext highlighter-rouge">FtCli</code></a>，给它一个<code class="language-plaintext highlighter-rouge">TkApp</code>类的实例和命令行参数。我们将在下一步创建<code class="language-plaintext highlighter-rouge">TkApp</code>类。<code class="language-plaintext highlighter-rouge">FtCli</code>（翻译为“带有命令行界面的前端”）创建了一个相同的<code class="language-plaintext highlighter-rouge">FtBasic</code>实例，并将其包装成几个有用的装饰器，并根据命令行参数进行配置。例如，<code class="language-plaintext highlighter-rouge">--port=8080</code>将被转换为<code class="language-plaintext highlighter-rouge">8080</code>端口号，并作为<code class="language-plaintext highlighter-rouge">FtBasic</code>构造函数的第二个参数传递。<p>这个 Web 应用程序本身被称为<code class="language-plaintext highlighter-rouge">TkApp</code>，并扩展了<code class="language-plaintext highlighter-rouge">TsWrap</code>。<p>我们会在一分钟内讨论这个 <code class="language-plaintext highlighter-rouge">TkFork</code> 类。<p>如果你正在使用 Maven，请使用以下 <code class="language-plaintext highlighter-rouge">pom.xml</code> 作为起点：<p>运行<code class="language-plaintext highlighter-rouge">mvn clean package</code>应该在<code class="language-plaintext highlighter-rouge">target</code>目录中生成一个<code class="language-plaintext highlighter-rouge">foo.jar</code>文件，并在<code class="language-plaintext highlighter-rouge">target/deps</code>目录中生成所有JAR依赖项的集合。现在你可以从命令行运行该应用程序。<p>应用程序已经准备好了，你可以将其部署到Heroku等平台。只需在存储库的根目录中创建一个<code class="language-plaintext highlighter-rouge">Procfile</code>文件，并将存储库推送到Heroku。<code class="language-plaintext highlighter-rouge">Procfile</code>文件应该如下所示：<h2 id="tkfork"><code class="language-plaintext highlighter-rouge">TkFork</code></h2><p>这个<a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/facets/fork/TkFork.html"><code class="language-plaintext highlighter-rouge">TkFork</code></a>类似乎是框架的核心元素之一。它帮助将传入的HTTP请求路由到正确的<em>take</em>。它的逻辑非常简单，在其中只有几行代码。它封装了一组“forks”，这些“forks”是<a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/facets/fork/Fork.html"><code class="language-plaintext highlighter-rouge">Fork</code></a>接口的实例：<p>它的唯一<code class="language-plaintext highlighter-rouge">route()</code>方法返回一个空迭代器或一个只有一个<code class="language-plaintext highlighter-rouge">Response</code>的迭代器。<code class="language-plaintext highlighter-rouge">TkFork</code>遍历所有的分支，调用它们的<code class="language-plaintext highlighter-rouge">route()</code>方法，直到其中一个返回一个响应。一旦这种情况发生，<code class="language-plaintext highlighter-rouge">TkFork</code>将这个响应返回给调用者，即<a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/http/FtBasic.html"><code class="language-plaintext highlighter-rouge">FtBasic</code></a>。<p>现在让我们自己创建一个简单的分支。例如，当请求<code class="language-plaintext highlighter-rouge">/status</code>的URL时，我们想要显示应用程序的状态。以下是代码：<p>我相信这里的逻辑很清楚。我们要么返回一个空的迭代器，要么返回一个包含<code class="language-plaintext highlighter-rouge">TkStatus</code>实例的迭代器。如果返回一个空的迭代器，<code class="language-plaintext highlighter-rouge">TkFork</code>将尝试在集合中找到另一个能获得<code class="language-plaintext highlighter-rouge">Response</code>实例的分支。顺便说一下，如果找不到任何东西并且所有的分支都返回空的迭代器，<code class="language-plaintext highlighter-rouge">TkFork</code>将抛出一个”页面未找到”的异常。<p>这个准确的逻辑是由一个开箱即用的叉子<code class="language-plaintext highlighter-rouge">FkRegex</code>实现的，它尝试用提供的正则表达式匹配请求的URI路径。<p>我们可以组成一个多层结构的<code class="language-plaintext highlighter-rouge">TkFork</code>类；例如：<p>再说一次，我相信这是显而易见的。<code class="language-plaintext highlighter-rouge">FkRegex</code>的实例将要求一个封装的<code class="language-plaintext highlighter-rouge">TkFork</code>实例返回一个响应，并尝试从<code class="language-plaintext highlighter-rouge">FkParams</code>封装的实例中获取它。如果HTTP查询是<code class="language-plaintext highlighter-rouge">/status?f=xml</code>，则会返回一个<code class="language-plaintext highlighter-rouge">TkStatusXML</code>的实例。<p>现在让我们讨论HTTP响应的结构及其面向对象的抽象，<a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/Response.html"><code class="language-plaintext highlighter-rouge">Response</code></a>。这是接口的外观：<p>看起来非常类似于 <a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/Request.html"><code class="language-plaintext highlighter-rouge">Request</code></a>，不是吗？嗯，它们几乎是一样的，主要是因为HTTP请求和响应的结构几乎是相同的。唯一的区别在于第一行。<p>有一系列有用的装饰器可帮助构建响应。它们是可组合的，这使它们非常方便。例如，如果你想构建一个包含HTML页面的响应，你可以像这样组合它们：<p>在这个示例中，装饰器<code class="language-plaintext highlighter-rouge">RsWithBody</code>创建了一个具有正文但没有任何标头的响应。然后，<code class="language-plaintext highlighter-rouge">RsWithType</code>为其添加了标头<code class="language-plaintext highlighter-rouge">Content-Type: text/html</code>。然后，<code class="language-plaintext highlighter-rouge">RsWithStatus</code>确保响应的第一行包含<code class="language-plaintext highlighter-rouge">HTTP/1.1 200 OK</code>。<p>您可以创建自己的装饰器，可以重用现有的装饰器。请查看<a href="https://github.com/yegor256/rultor/blob/1.50.2/src/main/java/com/rultor/web/RsPage.java"><code class="language-plaintext highlighter-rouge">RsPage</code></a>在rultor.com中的实现方式。<p>返回简单的“Hello, world”页面并不是一个大问题，我们可以看到。但是对于更复杂的输出，比如HTML页面、XML文档、JSON数据集等，情况会怎样呢？有一些方便的<code class="language-plaintext highlighter-rouge">Response</code>装饰器可以实现这一切。让我们从<a href="http://velocity.apache.org">Velocity</a>开始，它是一个简单的模板引擎。嗯，它并不是那么简单。它相当强大，但我建议只在简单的情况下使用它。它的工作原理如下：<p><a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/rs/RsVelocity.html"><code class="language-plaintext highlighter-rouge">RsVelocity</code></a> 构造函数接受一个参数，该参数必须是一个Velocity模板。然后，您调用 <code class="language-plaintext highlighter-rouge">with()</code> 方法，将数据注入到Velocity上下文中。当需要呈现HTTP响应时，<code class="language-plaintext highlighter-rouge">RsVelocity</code> 将根据配置的上下文来“评估”模板。再次强烈建议您仅在简单输出时使用这种模板化方法。<p>对于更复杂的HTML文档，我建议您使用XML/XSLT与Xembly结合使用。我在之前的几篇文章中解释了这个想法：在浏览器中使用XML+XSLT和RESTful API和Web站点在同一个URL中。这很简单且强大——Java生成XML输出，XSLT处理器将其转换为HTML文档。这是我们将表示与数据分离的方式。XSL样式表是一个“视图”，<code class="language-plaintext highlighter-rouge">TkIndex</code> 是一个“控制器”，从MVC的角度来说。<p>我很快就会写一篇关于使用Xembly和XSL进行模板化的独立文章。<p>与此同时，我们将在Takes中为<a href="http://en.wikipedia.org/wiki/Facelets">JSF/Facelets</a>和<a href="http://en.wikipedia.org/wiki/JavaServer_Pages">JSP</a>渲染创建装饰器。如果您有兴趣帮助，请fork该框架并提交您的pull request。<p>现在，一个问题是如何处理持久性实体，比如数据库、内存结构、网络连接等。我的建议是在<code class="language-plaintext highlighter-rouge">Entry</code>类中初始化它们，并将它们作为参数传递给<code class="language-plaintext highlighter-rouge">TkApp</code>构造函数。然后，<code class="language-plaintext highlighter-rouge">TkApp</code>将它们传递给自定义* takes *的构造函数。<p>例如，我们有一个包含一些表数据的PostgreSQL数据库，我们需要渲染它们。以下是我在<code class="language-plaintext highlighter-rouge">Entry</code>类中如何初始化与之的连接（我正在使用<a href="http://www.jolbox.com/">BoneCP</a>连接池）：<p>现在，<code class="language-plaintext highlighter-rouge">TkApp</code>的构造函数必须接受一个类型为<code class="language-plaintext highlighter-rouge">java.sql.Source</code>的单个参数。<p>类<code class="language-plaintext highlighter-rouge">TkIndex</code>还接受一个类<code class="language-plaintext highlighter-rouge">Source</code>的单一参数。我相信你知道在<code class="language-plaintext highlighter-rouge">TkIndex</code>内部如何处理它，以便获取SQL表格数据并将其转换为HTML。这里的重点是依赖必须在应用程序（<code class="language-plaintext highlighter-rouge">TkApp</code>类的实例）实例化的那一刻注入进去。这是一个纯净的依赖注入机制，完全不依赖容器。在《依赖注入容器是代码污染者》一文中可以了解更多。<p>由于每个类都是不可变的，并且所有的依赖关系只通过构造函数注入，因此单元测试非常容易。假设我们想要测试<code class="language-plaintext highlighter-rouge">TkStatus</code>，它应该返回一个HTML响应（我正在使用<a href="http://junit.org/">JUnit 4</a>和<a href="https://github.com/hamcrest/JavaHamcrest">Hamcrest</a>）。<p>此外，我们可以在一个测试HTTP服务器中启动整个应用程序或任何一个单独的<em>take</em>，并通过真实的TCP套接字测试其行为；例如（我正在使用<a href="http://http.jcabi.com">jcabi-http</a>发送HTTP请求并检查输出）。<p><a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/http/FtRemote.html"><code class="language-plaintext highlighter-rouge">FtRemote</code></a> 在随机TCP端口上启动一个测试Web服务器，并在提供的<code class="language-plaintext highlighter-rouge">FtRemote.Script</code>实例上调用<code class="language-plaintext highlighter-rouge">exec()</code>方法。该方法的第一个参数是刚刚启动的Web服务器主页的URI。<p>Takes框架的架构非常模块化和可组合。任何单独的<em>take</em>都可以作为独立的组件进行测试，与框架和其他<em>take</em>完全独立。<p>这是我经常听到的问题。这个想法很简单，它起源于电影业。拍摄一部电影时，摄制组会拍摄很多个“镜头”以捕捉现实并将其呈现在电影中。每个捕捉到的镜头都被称为一个“镜头”。<p>换句话说，一个“镜头”就像是现实的快照。<p>这个框架也是如此。每个<code class="language-plaintext highlighter-rouge">Take</code>实例代表了某个特定时刻的现实。这个现实随后以<code class="language-plaintext highlighter-rouge">Response</code>的形式发送给用户。<p>附注：关于身份验证也有几个词：Cookie-Based身份验证在Takes框架中的工作原理。<p>附注：还有一些真实的网络系统，你可能会对它们感兴趣。它们都使用了Takes框架，并且它们的代码是开源的：<a href="https://github.com/yegor256/rultor">rultor.com</a>, jare.io, wring.io.<p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/42 on 2023-11-17 at 14:59</article></div><div class="wrapper"><footer class="footer"><p>&copy; <span itemscope=""itemprop="copyrightHolder"itemtype="http://schema.org/Person"><span itemprop="name">Yegor Bugayenko</span> </span>2014&ndash;<span itemprop="copyrightYear">2023</span></footer></div></section><div class="wrapper unprintable"style="text-align:center;margin-top:2em"><a href="https://www.sixnines.io/h/3ba1652f"><img src="//www.sixnines.io/b/3ba1652f?style=flat"alt="sixnines availability badge"></a>&nbsp; <a href="https://github.com/yegor256/blog/stargazers"><img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square"alt="GitHub stars"></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script><script src="/js/all.js?b0f3971423a"></script><script>var disqus_shortname="yegor256"</script><script id="dsq-count-scr"src="//yegor256.disqus.com/count.js"async="async"></script><script>((e,a,t,g,n)=>{e.GoogleAnalyticsObject="ga",e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=+new Date,g=a.createElement(t),n=a.getElementsByTagName(t)[0],g.async=1,g.src="//www.google-analytics.com/analytics.js",n.parentNode.insertBefore(g,n)})(window,document,"script"),ga("create","UA-1963507-32","auto"),ga("send","pageview")</script><script>Cd=document,Cr="&"+Math.random(),Cp="&s=1",Cd.cookie="b=b",Cd.cookie&&(Cp+="&c=1"),Cp+="&t="+(new Date).getTimezoneOffset(),self!=top&&(Cp+="&f=1")</script><script>navigator.javaEnabled()&&(Cp+="&j=1")</script><script>"undefined"!=typeof screen&&(Cp+="&w="+screen.width+"&h="+screen.height+"&d="+(screen.colorDepth||screen.pixelDepth))</script><script>Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+"&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+"' border='0' width='1' height='1'/>")</script><script type="application/ld+json">{ "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] }</script>