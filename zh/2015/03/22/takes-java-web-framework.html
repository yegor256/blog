<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US" itemscope="" itemtype="http://schema.org/WebSite"> <head> <meta charset="utf-8"/> <meta name="description" content="Takes is a pure object-oriented and immutable Java web framework that turns the design and development of web applications into a pleasant and fun process." /> <meta name="keywords" content="" /> <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/> <meta name="google-site-verification" content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8" /> <meta name="author" content="Yegor Bugayenko"> <meta name="og:site_name" content="Yegor Bugayenko"/> <meta name="og:type" content="article" /> <meta name="og:locale" content="en_US" /> <meta name="twitter:account_id" content="4503599630178231" /> <meta name="twitter:creator" content="@yegor256"/> <meta name="twitter:site" content="@yegor256"/> <meta name="twitter:title" property="og:title" content="Java Web App Architecture In Takes Framework"/> <meta name="twitter:description" property="og:description" content="Takes is a pure object-oriented and immutable Java web framework that turns the design and development of web applications into a pleasant and fun process."/> <meta name="twitter:url" property="og:url" content="https://www.yegor256.com/zh/2015/03/22/takes-java-web-framework.html"/> <meta name="telegram:channel" content="AAAAAEJFMRzsRTRxM3ec6A"/> <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="yegor256" /> <link rel="shortcut icon" href="/favicon.ico?b0f3971423a"/> <link rel="apple-touch-icon" href="/favicon.ico?b0f3971423a"/> <link rel="alternate" type="application/rss+xml" title="RSS for yegor256.com" href="https://www.yegor256.com/rss.xml"/> <link rel="stylesheet" href="/css/layout.css?b0f3971423a"/> <link rel="stylesheet" href="/css/icons.css?b0f3971423a"/> <link rel="canonical" href="https://www.yegor256.com/zh/2015/03/22/takes-java-web-framework.html" /> <title>Java Web App Architecture In Takes Framework</title> </head> <body><div class="wrapper"> <aside class="header-toggle unprintable" id="header-toggle" title="Show the menu" onclick="$('#header').show();$('#header-toggle').hide();">&#9776;</aside> <header class="header" id="header"><div class="face"> <a href="/about-me.html#form" class="sub" title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html" style="position:relative;"> <img src="/images/face-256x256.jpg" class="photo" alt="Yegor Bugayenko"/> </a></div><nav><ul class="menu social notranslate"> <li><a href="https://twitter.com/intent/follow?screen_name=yegor256" rel="nofollow" title="Follow me on Twitter"><i class="icon icon-twitter notranslate" aria-hidden="true"></i></a></li> <li><a href="/rss.xml" rel="nofollow" title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://github.com/yegor256" rel="nofollow" title="My GitHub profile"><i class="icon icon-github notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="http://stackoverflow.com/users/187141/yegor256" rel="nofollow" title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.facebook.com/yegor256" rel="nofollow" title="Follow me on Facebook"><i class="icon icon-facebook notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://instagram.com/yegor256" rel="nofollow" title="Follow me on Instagram"><i class="icon icon-instagram notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.linkedin.com/in/yegor256" rel="nofollow" title="My LinkedIn profile"><i class="icon icon-linkedin notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.youtube.com/c/yegor256?sub_confirmation=1" rel="nofollow" title="My Youtube video channel"><i class="icon icon-youtube notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.pinterest.com/yegor256/" rel="nofollow" title="My Pinterest boards"><i class="icon icon-pinterest notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://angel.co/yegor256" rel="nofollow" title="My AngelList profile"><i class="icon icon-angellist notranslate" aria-hidden="true"></i></a></li> <li><a href="https://soundcloud.com/yegor256" rel="nofollow" title="My podcast"><i class="icon icon-podcast notranslate" aria-hidden="true"></i></a></li> <li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721" rel="nofollow" title="My iTunes podcast"><i class="icon icon-itunes notranslate" aria-hidden="true"></i></a></li> <li><a href="https://t.me/yegor256news" rel="nofollow" title="My Telegram public channel"><i class="icon icon-telegram notranslate" aria-hidden="true"></i></a></li> <li><a href="mailto:blog@yegor256.com" rel="nofollow" title="Email me any time"><i class="icon icon-mail notranslate" aria-hidden="true"></i></a></li></ul><ul class="menu"> <li><a href="/" title="Home page">Home</a></li> <li ><a href="/best.html" title="Best articles to read">12&#160;Best</a></li> <li ><a href="/contents.html" title="The contents of the entire blog">All&#160;390</a></li> <li ><a href="/teaching.html" title="My courses and lectures">Teaching</a></li> <li ><a href="/talks.html" title="Future and past conference talks">Talks</a></li> <li ><a href="/books.html" title="The books I wrote">Books</a></li> <li ><a href="/research.html" title="My research directions and progress">Research</a></li> <li ><a href="/pets.html" title="My loved pet projects">Pets</a></li> <li ><a href="/testimonials.html" title="What some people say about me">Testimonials</a></li> <li ><a href="/shift-m.html" title="Audio podcast about project management">Shift-M</a></li> <li ><a href="/paintings.html" title="My paintings for sale">Art</a></li> <li><a href="https://ru.yegor256.com/" title="Немного на русском языке о политике в России, Украине и мире">Политика</a></li></ul></nav><div class="search"> <form method="get" action="https://www.google.com/search" itemprop="potentialAction" itemscope="" itemtype="http://schema.org/SearchAction"> <meta itemprop="target" content="https://www.google.com/search?q={q}"/> <input name="sitesearch" value="yegor256.com" type="hidden"/> <input itemprop="query-input" type="text" id="search-query" class="field field-text" required="required" onfocus="$('.google').css('visibility', 'visible');" name="q" placeholder="Search..." autocomplete="off"/> <input type="image" src="/images/google-search-icon.svg" class="google" title="Search via Google" alt="Search via Google"/> </form></div><div class="hot"><ul></ul></div></header></div><section itemscope="" itemtype="http://schema.org/BlogPosting"><div class="wrapper"> <header><h1 itemprop="name headline mainEntityOfPage">Java Web App Architecture In Takes Framework</h1></header> <article class="main" itemprop="articleBody" style="font-family: sans-serif; font-size: 0.9em; line-height: 1.2em;"><p style="color: #C42C00;">The following text is a <em>partial</em> translation of the <a href='https://www.yegor256.com/2015/03/22/takes-java-web-framework.html'>original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:</p><p>我曾经使用Servlets、JSP、JAX-RS、Spring Framework、Play Framework、JSF with Facelets和一点Spark Framework。在我个人的观点中，所有这些解决方案都离面向对象和优雅的目标相差甚远。它们都充斥着静态方法、无法测试的数据结构和肮脏的黑科技。因此，大约一个月前，我决定创建自己的Java Web框架。我将几个基本原则融入到了它的基础中：1）不使用NULL，2）不使用公共静态方法，3）不使用可变类，4）不使用类转换、反射和<code class="language-plaintext highlighter-rouge">instanceof</code>操作符。这四个基本原则应该能够保证代码的整洁和架构的透明。这就是<a href="http://www.takes.org">Takes</a>框架的诞生方式。让我们看看它是如何被创建出来并且如何工作的。</p><p>这是我对Web应用程序架构及其组件的简单理解。</p><p>首先，要创建一个Web服务器，我们需要创建一个新的<a href="http://en.wikipedia.org/wiki/Network_socket">网络套接字</a>，它在特定的<a href="http://en.wikipedia.org/wiki/Port_%28computer_networking%29">TCP端口</a>上接受连接。通常情况下是80，但我将使用8080进行测试。在Java中，可以使用<a href="http://docs.oracle.com/javase/7/docs/api/java/net/ServerSocket.html"><code class="language-plaintext highlighter-rouge">ServerSocket</code></a>类来完成这个任务：</p><p>这就足够启动一个Web服务器了。现在，套接字已准备好，并在8080端口上进行监听。当有人在浏览器中打开<code class="language-plaintext highlighter-rouge">http://localhost:8080</code>时，连接将建立并浏览器将永远旋转等待。编译这段代码片段并尝试一下。我们刚刚构建了一个简单的Web服务器，没有使用任何框架。目前我们还没有对传入的连接进行任何操作，但我们也没有拒绝它们。所有的连接都被排列在那个<code class="language-plaintext highlighter-rouge">server</code>对象里。这是在后台线程中完成的；这就是为什么我们需要在后面放置那个<code class="language-plaintext highlighter-rouge">while(true)</code>的原因。如果没有这个无限暂停，应用程序将立即完成执行，并关闭服务器套接字。</p><p>下一步是接受传入的连接。在Java中，这通过对<code class="language-plaintext highlighter-rouge">accept()</code>方法进行阻塞调用来完成：</p><p>该方法会阻塞其线程并等待新连接的到来。一旦发生这种情况，它会返回一个<code class="language-plaintext highlighter-rouge">Socket</code>实例。为了接受下一个连接，我们应该再次调用<code class="language-plaintext highlighter-rouge">accept()</code>。所以基本上，我们的Web服务器应该按照以下方式工作：</p><p>这是一个无止境的循环，它接受一个新的连接，理解它，创建一个响应，返回响应，并再次接受新的连接。HTTP协议是无状态的，这意味着服务器不应该记住任何先前连接中发生的事情。它只关心这个特定连接中传入的HTTP请求。</p><p>HTTP请求来自于套接字的输入流，看起来像一个多行文本块。如果你读取套接字的输入流，你会看到这样的内容：</p><p>你会看到类似于这样的东西：</p><p>客户端（例如Google Chrome浏览器）将此文本传递给建立的连接。它连接到<code class="language-plaintext highlighter-rouge">localhost</code>的8080端口，一旦连接准备就绪，它立即将此文本发送到连接中，然后等待响应。</p><p>我们的任务是使用请求中获得的信息创建HTTP响应。如果我们的服务器非常简单，我们可以基本上忽略请求中的所有信息，并只返回”Hello, world!”给所有请求（为了简单起见，我使用<a href="https://commons.apache.org/proper/commons-io/javadocs/api-2.5/org/apache/commons/io/IOUtils.html"><code class="language-plaintext highlighter-rouge">IOUtils</code></a>）。</p><p>就是这样。服务器已准备好。尝试编译并运行它。将您的浏览器指向 <code class="language-plaintext highlighter-rouge">http://localhost:8080</code>，您将看到 <code class="language-plaintext highlighter-rouge">Hello, world!</code>。</p><p>这就是构建Web服务器所需的全部内容。现在让我们来讨论如何使其面向对象和可组合。让我们尝试看看<a href="http://www.takes.org">Takes</a>框架是如何构建的。</p><p>Routing/dispatching在Takes中与response printing结合在一起。您只需要创建一个实现<a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/Take.html"><code class="language-plaintext highlighter-rouge">Take</code></a>接口的单个类，就可以创建一个工作的web应用程序。</p><p>现在是时候启动服务器了：</p><p>这个 <a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/http/FtBasic.html"><code class="language-plaintext highlighter-rouge">FtBasic</code></a> 类执行了上述解释的完全相同的套接字操作。它在端口8080上启动一个服务器套接字，并通过我们传递给它的 <code class="language-plaintext highlighter-rouge">TkFoo</code> 实例来分派所有传入的连接。它通过一个 <a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/http/Exit.html"><code class="language-plaintext highlighter-rouge">Exit</code></a> 的实例在一个无限循环中进行这个分派，并每秒检查是否停止。显然，<code class="language-plaintext highlighter-rouge">Exit.NEVER</code> 总是回答说：“请不要停止。”</p><p>现在让我们看看到达<code class="language-plaintext highlighter-rouge">TkFoo</code>的HTTP请求中有什么，以及我们可以从中获得什么。这是<a href="http://www.takes.org">Takes</a>中<code class="language-plaintext highlighter-rouge">Request</code>接口的定义方式。</p><p>请求分为两部分：头部和正文。头部包含所有在正文开始的空行之前的所有行，根据HTTP规范在<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html">RFC 2616</a>中定义。框架中有许多有用的修饰符可用于<code class="language-plaintext highlighter-rouge">Request</code>。例如，<code class="language-plaintext highlighter-rouge">RqMethod</code>可以帮助您从头部的第一行获取方法名。</p><p><code class="language-plaintext highlighter-rouge">RqHref</code> will help extract the query part and parse it. For example, this is the request:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /user?id=123 HTTP/1.1
Host: www.example.com
</code></pre></div></div><p>这段代码将提取<code class="language-plaintext highlighter-rouge">123</code>：</p><p><code class="language-plaintext highlighter-rouge">RqPrint</code> can get the entire request or its body printed as a <code class="language-plaintext highlighter-rouge">String</code>:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>final String body = new RqPrint(request).printBody();
</code></pre></div></div><p>这里的想法是保持<code class="language-plaintext highlighter-rouge">Request</code>接口简单，并将此请求解析功能提供给其装饰器。这种方法有助于框架保持类小而有凝聚力。每个装饰器都非常小而坚实，只做一件事。所有这些装饰器都在<a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/rq/package-summary.html"><code class="language-plaintext highlighter-rouge">org.takes.rq</code></a>包中。正如您可能已经理解的，<code class="language-plaintext highlighter-rouge">Rq</code>前缀代表<code class="language-plaintext highlighter-rouge">Request</code>。</p><p>让我们创建我们的第一个真正的网页应用程序，它将会做一些有用的事情。我建议从一个<code class="language-plaintext highlighter-rouge">Entry</code>类开始，这是Java在命令行中启动应用程序所必需的。</p><p>这个类只包含一个<code class="language-plaintext highlighter-rouge">main()</code>静态方法，当应用程序从命令行启动时，JVM将调用该方法。正如你所见，它实例化<a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/http/FtCli.html"><code class="language-plaintext highlighter-rouge">FtCli</code></a>，给它一个<code class="language-plaintext highlighter-rouge">TkApp</code>类的实例和命令行参数。我们将在下一步创建<code class="language-plaintext highlighter-rouge">TkApp</code>类。<code class="language-plaintext highlighter-rouge">FtCli</code>（翻译为“带有命令行界面的前端”）创建了一个相同的<code class="language-plaintext highlighter-rouge">FtBasic</code>实例，并将其包装成几个有用的装饰器，并根据命令行参数进行配置。例如，<code class="language-plaintext highlighter-rouge">--port=8080</code>将被转换为<code class="language-plaintext highlighter-rouge">8080</code>端口号，并作为<code class="language-plaintext highlighter-rouge">FtBasic</code>构造函数的第二个参数传递。</p><p>这个 Web 应用程序本身被称为<code class="language-plaintext highlighter-rouge">TkApp</code>，并扩展了<code class="language-plaintext highlighter-rouge">TsWrap</code>。</p><p>我们会在一分钟内讨论这个 <code class="language-plaintext highlighter-rouge">TkFork</code> 类。</p><p>如果你正在使用 Maven，请使用以下 <code class="language-plaintext highlighter-rouge">pom.xml</code> 作为起点：</p><p>运行<code class="language-plaintext highlighter-rouge">mvn clean package</code>应该在<code class="language-plaintext highlighter-rouge">target</code>目录中生成一个<code class="language-plaintext highlighter-rouge">foo.jar</code>文件，并在<code class="language-plaintext highlighter-rouge">target/deps</code>目录中生成所有JAR依赖项的集合。现在你可以从命令行运行该应用程序。</p><p>应用程序已经准备好了，你可以将其部署到Heroku等平台。只需在存储库的根目录中创建一个<code class="language-plaintext highlighter-rouge">Procfile</code>文件，并将存储库推送到Heroku。<code class="language-plaintext highlighter-rouge">Procfile</code>文件应该如下所示：</p><h2 id="tkfork"><code class="language-plaintext highlighter-rouge">TkFork</code></h2><p>这个<a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/facets/fork/TkFork.html"><code class="language-plaintext highlighter-rouge">TkFork</code></a>类似乎是框架的核心元素之一。它帮助将传入的HTTP请求路由到正确的<em>take</em>。它的逻辑非常简单，在其中只有几行代码。它封装了一组“forks”，这些“forks”是<a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/facets/fork/Fork.html"><code class="language-plaintext highlighter-rouge">Fork</code></a>接口的实例：</p><p>它的唯一<code class="language-plaintext highlighter-rouge">route()</code>方法返回一个空迭代器或一个只有一个<code class="language-plaintext highlighter-rouge">Response</code>的迭代器。<code class="language-plaintext highlighter-rouge">TkFork</code>遍历所有的分支，调用它们的<code class="language-plaintext highlighter-rouge">route()</code>方法，直到其中一个返回一个响应。一旦这种情况发生，<code class="language-plaintext highlighter-rouge">TkFork</code>将这个响应返回给调用者，即<a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/http/FtBasic.html"><code class="language-plaintext highlighter-rouge">FtBasic</code></a>。</p><p>现在让我们自己创建一个简单的分支。例如，当请求<code class="language-plaintext highlighter-rouge">/status</code>的URL时，我们想要显示应用程序的状态。以下是代码：</p><p>我相信这里的逻辑很清楚。我们要么返回一个空的迭代器，要么返回一个包含<code class="language-plaintext highlighter-rouge">TkStatus</code>实例的迭代器。如果返回一个空的迭代器，<code class="language-plaintext highlighter-rouge">TkFork</code>将尝试在集合中找到另一个能获得<code class="language-plaintext highlighter-rouge">Response</code>实例的分支。顺便说一下，如果找不到任何东西并且所有的分支都返回空的迭代器，<code class="language-plaintext highlighter-rouge">TkFork</code>将抛出一个”页面未找到”的异常。</p><p>这个准确的逻辑是由一个开箱即用的叉子<code class="language-plaintext highlighter-rouge">FkRegex</code>实现的，它尝试用提供的正则表达式匹配请求的URI路径。</p><p>我们可以组成一个多层结构的<code class="language-plaintext highlighter-rouge">TkFork</code>类；例如：</p><p>再说一次，我相信这是显而易见的。<code class="language-plaintext highlighter-rouge">FkRegex</code>的实例将要求一个封装的<code class="language-plaintext highlighter-rouge">TkFork</code>实例返回一个响应，并尝试从<code class="language-plaintext highlighter-rouge">FkParams</code>封装的实例中获取它。如果HTTP查询是<code class="language-plaintext highlighter-rouge">/status?f=xml</code>，则会返回一个<code class="language-plaintext highlighter-rouge">TkStatusXML</code>的实例。</p><p>现在让我们讨论HTTP响应的结构及其面向对象的抽象，<a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/Response.html"><code class="language-plaintext highlighter-rouge">Response</code></a>。这是接口的外观：</p><p>看起来非常类似于 <a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/Request.html"><code class="language-plaintext highlighter-rouge">Request</code></a>，不是吗？嗯，它们几乎是一样的，主要是因为HTTP请求和响应的结构几乎是相同的。唯一的区别在于第一行。</p><p>有一系列有用的装饰器可帮助构建响应。它们是可组合的，这使它们非常方便。例如，如果你想构建一个包含HTML页面的响应，你可以像这样组合它们：</p><p>在这个示例中，装饰器<code class="language-plaintext highlighter-rouge">RsWithBody</code>创建了一个具有正文但没有任何标头的响应。然后，<code class="language-plaintext highlighter-rouge">RsWithType</code>为其添加了标头<code class="language-plaintext highlighter-rouge">Content-Type: text/html</code>。然后，<code class="language-plaintext highlighter-rouge">RsWithStatus</code>确保响应的第一行包含<code class="language-plaintext highlighter-rouge">HTTP/1.1 200 OK</code>。</p><p>您可以创建自己的装饰器，可以重用现有的装饰器。请查看<a href="https://github.com/yegor256/rultor/blob/1.50.2/src/main/java/com/rultor/web/RsPage.java"><code class="language-plaintext highlighter-rouge">RsPage</code></a>在rultor.com中的实现方式。</p><p>返回简单的“Hello, world”页面并不是一个大问题，我们可以看到。但是对于更复杂的输出，比如HTML页面、XML文档、JSON数据集等，情况会怎样呢？有一些方便的<code class="language-plaintext highlighter-rouge">Response</code>装饰器可以实现这一切。让我们从<a href="http://velocity.apache.org">Velocity</a>开始，它是一个简单的模板引擎。嗯，它并不是那么简单。它相当强大，但我建议只在简单的情况下使用它。它的工作原理如下：</p><p><a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/rs/RsVelocity.html"><code class="language-plaintext highlighter-rouge">RsVelocity</code></a> 构造函数接受一个参数，该参数必须是一个Velocity模板。然后，您调用 <code class="language-plaintext highlighter-rouge">with()</code> 方法，将数据注入到Velocity上下文中。当需要呈现HTTP响应时，<code class="language-plaintext highlighter-rouge">RsVelocity</code> 将根据配置的上下文来“评估”模板。再次强烈建议您仅在简单输出时使用这种模板化方法。</p><p>对于更复杂的HTML文档，我建议您使用XML/XSLT与Xembly结合使用。我在之前的几篇文章中解释了这个想法：在浏览器中使用XML+XSLT和RESTful API和Web站点在同一个URL中。这很简单且强大——Java生成XML输出，XSLT处理器将其转换为HTML文档。这是我们将表示与数据分离的方式。XSL样式表是一个“视图”，<code class="language-plaintext highlighter-rouge">TkIndex</code> 是一个“控制器”，从MVC的角度来说。</p><p>我很快就会写一篇关于使用Xembly和XSL进行模板化的独立文章。</p><p>与此同时，我们将在Takes中为<a href="http://en.wikipedia.org/wiki/Facelets">JSF/Facelets</a>和<a href="http://en.wikipedia.org/wiki/JavaServer_Pages">JSP</a>渲染创建装饰器。如果您有兴趣帮助，请fork该框架并提交您的pull request。</p><p>现在，一个问题是如何处理持久性实体，比如数据库、内存结构、网络连接等。我的建议是在<code class="language-plaintext highlighter-rouge">Entry</code>类中初始化它们，并将它们作为参数传递给<code class="language-plaintext highlighter-rouge">TkApp</code>构造函数。然后，<code class="language-plaintext highlighter-rouge">TkApp</code>将它们传递给自定义* takes *的构造函数。</p><p>例如，我们有一个包含一些表数据的PostgreSQL数据库，我们需要渲染它们。以下是我在<code class="language-plaintext highlighter-rouge">Entry</code>类中如何初始化与之的连接（我正在使用<a href="http://www.jolbox.com/">BoneCP</a>连接池）：</p><p>现在，<code class="language-plaintext highlighter-rouge">TkApp</code>的构造函数必须接受一个类型为<code class="language-plaintext highlighter-rouge">java.sql.Source</code>的单个参数。</p><p>类<code class="language-plaintext highlighter-rouge">TkIndex</code>还接受一个类<code class="language-plaintext highlighter-rouge">Source</code>的单一参数。我相信你知道在<code class="language-plaintext highlighter-rouge">TkIndex</code>内部如何处理它，以便获取SQL表格数据并将其转换为HTML。这里的重点是依赖必须在应用程序（<code class="language-plaintext highlighter-rouge">TkApp</code>类的实例）实例化的那一刻注入进去。这是一个纯净的依赖注入机制，完全不依赖容器。在《依赖注入容器是代码污染者》一文中可以了解更多。</p><p>由于每个类都是不可变的，并且所有的依赖关系只通过构造函数注入，因此单元测试非常容易。假设我们想要测试<code class="language-plaintext highlighter-rouge">TkStatus</code>，它应该返回一个HTML响应（我正在使用<a href="http://junit.org/">JUnit 4</a>和<a href="https://github.com/hamcrest/JavaHamcrest">Hamcrest</a>）。</p><p>此外，我们可以在一个测试HTTP服务器中启动整个应用程序或任何一个单独的<em>take</em>，并通过真实的TCP套接字测试其行为；例如（我正在使用<a href="http://http.jcabi.com">jcabi-http</a>发送HTTP请求并检查输出）。</p><p><a href="http://static.javadoc.io/org.takes/takes/1.1/org/takes/http/FtRemote.html"><code class="language-plaintext highlighter-rouge">FtRemote</code></a> 在随机TCP端口上启动一个测试Web服务器，并在提供的<code class="language-plaintext highlighter-rouge">FtRemote.Script</code>实例上调用<code class="language-plaintext highlighter-rouge">exec()</code>方法。该方法的第一个参数是刚刚启动的Web服务器主页的URI。</p><p>Takes框架的架构非常模块化和可组合。任何单独的<em>take</em>都可以作为独立的组件进行测试，与框架和其他<em>take</em>完全独立。</p><p>这是我经常听到的问题。这个想法很简单，它起源于电影业。拍摄一部电影时，摄制组会拍摄很多个“镜头”以捕捉现实并将其呈现在电影中。每个捕捉到的镜头都被称为一个“镜头”。</p><p>换句话说，一个“镜头”就像是现实的快照。</p><p>这个框架也是如此。每个<code class="language-plaintext highlighter-rouge">Take</code>实例代表了某个特定时刻的现实。这个现实随后以<code class="language-plaintext highlighter-rouge">Response</code>的形式发送给用户。</p><p>附注：关于身份验证也有几个词：Cookie-Based身份验证在Takes框架中的工作原理。</p><p>附注：还有一些真实的网络系统，你可能会对它们感兴趣。它们都使用了Takes框架，并且它们的代码是开源的：<a href="https://github.com/yegor256/rultor">rultor.com</a>, jare.io, wring.io.</p><p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/42 on 2023-11-17 at 14:59</p></article></div><div class="wrapper"> <footer class="footer"><p> &copy; <span itemscope="" itemprop="copyrightHolder" itemtype="http://schema.org/Person"> <span itemprop="name">Yegor Bugayenko</span> </span> 2014&ndash;<span itemprop="copyrightYear">2023</span></p></footer></div></section><div class="wrapper unprintable" style="text-align:center;margin-top:2em;"> <a href="https://www.sixnines.io/h/3ba1652f"> <img src="//www.sixnines.io/b/3ba1652f?style=flat" alt="sixnines availability badge" /></a> &nbsp; <a href="https://github.com/yegor256/blog/stargazers"> <img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square" alt="GitHub stars" /></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script> <script src="/js/all.js?b0f3971423a"></script> <script>var disqus_shortname = 'yegor256';</script> <script id="dsq-count-scr" src="//yegor256.disqus.com/count.js" async="async"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-1963507-32', 'auto'); ga('send', 'pageview'); </script> <script> Cd=document;Cr="&"+Math.random();Cp="&s=1"; Cd.cookie="b=b";if(Cd.cookie)Cp+="&c=1"; Cp+="&t="+(new Date()).getTimezoneOffset(); if(self!=top)Cp+="&f=1"; </script> <script> if(navigator.javaEnabled())Cp+="&j=1"; </script> <script> if(typeof(screen)!='undefined')Cp+="&w="+screen.width+"&h="+ screen.height+"&d="+(screen.colorDepth?screen.colorDepth:screen.pixelDepth); </script> <script> Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+ "&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+ "' border='0' wi"+"dth='1' he"+"ight='1'/>"); </script> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] } </script> </body> </html>
