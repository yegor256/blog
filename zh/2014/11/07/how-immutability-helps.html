<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US" itemscope="" itemtype="http://schema.org/WebSite"> <head> <meta charset="utf-8"/> <meta name="description" content="This article illustrates by example how immutability forces you to design small and cohesive objects, while mutability causes scope creep and tight coupling." /> <meta name="keywords" content="" /> <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/> <meta name="google-site-verification" content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8" /> <meta name="author" content="Yegor Bugayenko"> <meta name="og:site_name" content="Yegor Bugayenko"/> <meta name="og:type" content="article" /> <meta name="og:locale" content="en_US" /> <meta name="twitter:account_id" content="4503599630178231" /> <meta name="twitter:creator" content="@yegor256"/> <meta name="twitter:site" content="@yegor256"/> <meta name="twitter:title" property="og:title" content="How Immutability Helps"/> <meta name="twitter:description" property="og:description" content="This article illustrates by example how immutability forces you to design small and cohesive objects, while mutability causes scope creep and tight coupling."/> <meta name="twitter:url" property="og:url" content="https://www.yegor256.com/zh/2014/11/07/how-immutability-helps.html"/> <meta name="telegram:channel" content="AAAAAEJFMRzsRTRxM3ec6A"/> <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="yegor256" /> <link rel="shortcut icon" href="/favicon.ico?19fbb713f25"/> <link rel="apple-touch-icon" href="/favicon.ico?19fbb713f25"/> <link rel="alternate" type="application/rss+xml" title="RSS for yegor256.com" href="https://www.yegor256.com/rss.xml"/> <link rel="stylesheet" href="/css/layout.css?19fbb713f25"/> <link rel="stylesheet" href="/css/icons.css?19fbb713f25"/> <link rel="canonical" href="https://www.yegor256.com/zh/2014/11/07/how-immutability-helps.html" /> <title>How Immutability Helps</title> </head> <body><div class="wrapper"> <aside class="header-toggle unprintable" id="header-toggle" title="Show the menu" onclick="$('#header').show();$('#header-toggle').hide();">&#9776;</aside> <header class="header" id="header"><div class="face"> <a href="/about-me.html#form" class="sub" title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html" style="position:relative;"> <img src="/images/face-256x256.jpg" class="photo" alt="Yegor Bugayenko"/> </a></div><nav><ul class="menu social notranslate"> <li><a href="https://twitter.com/intent/follow?screen_name=yegor256" rel="nofollow" title="Follow me on Twitter"><i class="icon icon-twitter notranslate" aria-hidden="true"></i></a></li> <li><a href="/rss.xml" rel="nofollow" title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://github.com/yegor256" rel="nofollow" title="My GitHub profile"><i class="icon icon-github notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="http://stackoverflow.com/users/187141/yegor256" rel="nofollow" title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.facebook.com/yegor256" rel="nofollow" title="Follow me on Facebook"><i class="icon icon-facebook notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://instagram.com/yegor256" rel="nofollow" title="Follow me on Instagram"><i class="icon icon-instagram notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.linkedin.com/in/yegor256" rel="nofollow" title="My LinkedIn profile"><i class="icon icon-linkedin notranslate" aria-hidden="true"></i></a></li> <li><a itemprop="sameAs" href="https://www.youtube.com/c/yegor256?sub_confirmation=1" rel="nofollow" title="My Youtube video channel"><i class="icon icon-youtube notranslate" aria-hidden="true"></i></a></li> <li><a href="https://soundcloud.com/yegor256" rel="nofollow" title="My podcast"><i class="icon icon-podcast notranslate" aria-hidden="true"></i></a></li> <li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721" rel="nofollow" title="My iTunes podcast"><i class="icon icon-itunes notranslate" aria-hidden="true"></i></a></li> <li><a href="https://t.me/yegor256news" rel="nofollow" title="My Telegram public channel"><i class="icon icon-telegram notranslate" aria-hidden="true"></i></a></li> <li><a href="mailto:blog@yegor256.com" rel="nofollow" title="Email me any time"><i class="icon icon-mail notranslate" aria-hidden="true"></i></a></li></ul><ul class="menu"> <li><a href="/" title="Home page">Home</a></li> <li ><a href="/best.html" title="Best articles to read">12&#160;Best</a></li> <li ><a href="/contents.html" title="The contents of the entire blog">All&#160;392</a></li> <li ><a href="/teaching.html" title="My courses and lectures">Teaching</a></li> <li ><a href="/talks.html" title="Future and past conference talks">Talks</a></li> <li ><a href="/books.html" title="The books I wrote">Books</a></li> <li ><a href="/research.html" title="My research directions and progress">Research</a></li> <li ><a href="/pets.html" title="My loved pet projects">Pets</a></li> <li ><a href="/testimonials.html" title="What some people say about me">Testimonials</a></li> <li ><a href="/shift-m.html" title="Audio podcast about project management">Shift-M</a></li> <li ><a href="/paintings.html" title="My paintings for sale">Art</a></li> <li><a href="https://ru.yegor256.com/" title="Немного на русском языке о политике в России, Украине и мире">Политика</a></li></ul></nav><div class="search"> <form method="get" action="https://www.google.com/search" itemprop="potentialAction" itemscope="" itemtype="http://schema.org/SearchAction"> <meta itemprop="target" content="https://www.google.com/search?q={q}"/> <input name="sitesearch" value="yegor256.com" type="hidden"/> <input itemprop="query-input" type="text" id="search-query" class="field field-text" required="required" onfocus="$('.google').css('visibility', 'visible');" name="q" placeholder="Search..." autocomplete="off"/> <input type="image" src="/images/google-search-icon.svg" class="google" title="Search via Google" alt="Search via Google"/> </form></div><div class="hot"><ul></ul></div></header></div><section itemscope="" itemtype="http://schema.org/BlogPosting"><div class="wrapper"> <header><h1 itemprop="name headline mainEntityOfPage">How Immutability Helps</h1></header> <article class="main" itemprop="articleBody" style="font-family: sans-serif; font-size: 0.9em; line-height: 1.2em;"><p style="color: #C42C00;">The following text is a <em>partial</em> translation of the <a href='https://www.yegor256.com/2014/11/07/how-immutability-helps.html'>original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:</p><p>在最近的几篇文章中，包括《Getters/Setters. Evil. Period.》，《Objects Should Be Immutable》，以及《Dependency Injection Containers are Code Polluters》，我普遍将所有可变对象的“setter”（以<code class="language-plaintext highlighter-rouge">set</code>开头的对象方法）标记为邪恶的。我的论证主要基于隐喻和抽象的例子。显然，这对于你们许多人来说并不令人信服—我收到了一些要求提供更具体和实际的例子的请求。</p><p>因此，为了说明我对“通过setter进行可变性”的强烈负面态度，我拿了一个现有的<a href="http://commons.apache.org/proper/commons-email/">commons-email</a> Java库，并根据我的思路重新设计了它，不使用setter，而是考虑“对象思维”。我将我的库作为<a href="http://www.jcabi.com">jcabi</a>家族的一部分发布—<a href="http://email.jcabi.com">jcabi-email</a>。让我们看看在没有getter的“纯”面向对象和不可变方法下，我们可以得到哪些好处。</p><p>如果你使用commons-email发送电子邮件，你的代码将如下所示：</p><p>这是如何使用<a href="http://email.jcabi.com">jcabi-email</a>进行相同操作的方法。</p><p>我认为差异很明显。</p><p>在第一个例子中，你正在处理一个怪兽类，它可以为你完成一切，包括通过SMTP发送你的MIME消息，创建消息，配置其参数，添加MIME部件等等。commons-email中的<a href="http://svn.apache.org/viewvc/commons/proper/email/tags/EMAIL_1_3_3/src/main/java/org/apache/commons/mail/Email.java?revision=1609295&amp;view=co"><code class="language-plaintext highlighter-rouge">Email</code></a>类确实是一个庞大的类—有33个私有属性，一百多个方法，大约两千行代码。首先，你通过一系列的setter方法配置该类，然后要求它为你<code class="language-plaintext highlighter-rouge">send()</code>一封电子邮件。</p><p>在第二个例子中，我们通过七个<code class="language-plaintext highlighter-rouge">new</code>调用实例化了七个对象。<code class="language-plaintext highlighter-rouge">Postman</code>负责打包MIME消息；<code class="language-plaintext highlighter-rouge">SMTP</code>负责通过SMTP发送消息；邮戳（<code class="language-plaintext highlighter-rouge">StSender</code>，<code class="language-plaintext highlighter-rouge">StRecipient</code>和<code class="language-plaintext highlighter-rouge">StSubject</code>）负责在交付前配置MIME消息；附件<code class="language-plaintext highlighter-rouge">EnPlain</code>负责为我们将要发送的消息创建一个MIME部件。我们将这七个对象封装在一起，然后要求邮递员为我们<code class="language-plaintext highlighter-rouge">send()</code>信封。</p><p>从用户角度来看，几乎没有什么问题。<code class="language-plaintext highlighter-rouge">Email</code> 是一个功能强大的类，具有多个控制项—只需选择正确的控制项，工作就能完成。然而，从开发者角度来看，<code class="language-plaintext highlighter-rouge">Email</code> 类是一场噩梦。主要是因为这个类非常庞大且难以维护。</p><p><em>由于这个类太大</em>，每当你想通过引入一个新方法来扩展它时，你都会面临一个事实，即你正在使这个类变得更糟糕—更长、缺乏凝聚性、难以阅读、难以维护等等。你会感觉自己在深入挖掘一些肮脏的东西，而且永远没有希望使它变得更干净。我相信你对这种感觉很熟悉—大多数遗留应用程序都是这样的。它们有巨大的多行“类”（实际上是用 Java 编写的 COBOL 程序），这些“类”是由你之前的几代程序员继承而来的。当你开始时，你充满了活力，但是在滚动这样一个“类”的几分钟后，你会说—“算了吧，都快到周六了。”</p><p><em>由于这个类太大</em>，不再有数据隐藏或封装—33个变量可以被100多个方法访问。有什么是隐藏的吗？这个 <code class="language-plaintext highlighter-rouge">Email.java</code> 文件实际上是一个大型的过程化2000行脚本，错误地称为“类”。一旦你通过调用其中一个方法穿越了类的边界，就没有什么是隐藏的了。在那之后，你可以完全访问你可能需要的所有数据。这为什么不好？好吧，我们为什么需要封装呢？为了保护一个程序员免受另一个程序员的干扰，也就是所谓的防御性编程。当我忙于改变 MIME 消息的主题时，我希望确保我不会被其他方法的活动干扰，这些活动会错误地更改发送者并触及我的主题。封装帮助我们缩小问题的范围，而这个 <code class="language-plaintext highlighter-rouge">Email</code> 类却完全相反。</p><p><em>由于这个类太大</em>，它的单元测试比类本身还要复杂。为什么？因为它的方法和属性之间存在多重依赖关系。为了测试 <code class="language-plaintext highlighter-rouge">setCharset()</code> 方法，你必须通过调用其他几个方法来准备整个对象，然后你必须调用 <code class="language-plaintext highlighter-rouge">send()</code> 方法来确保发送的消息实际上使用了你指定的编码。因此，为了测试一个一行代码的方法 <code class="language-plaintext highlighter-rouge">setCharset()</code>，你要运行整个集成测试场景，通过 SMTP 发送一个完整的 MIME 消息。显然，如果某个方法发生了变化，几乎每个测试方法都会受到影响。换句话说，测试非常脆弱、不可靠且过于复杂。</p><p>我可以继续谈论这个“<em>由于这个类太大</em>”，但我认为一个小而凝聚的类总是比一个大类好是显而易见的。对我来说、对你来说，对任何面向对象的程序员来说都是显而易见的。但是为什么对 Apache Commons Email 的开发者来说却不是那么明显呢？我不认为他们愚蠢或者没受过教育。那么是什么原因呢？</p><p>这就是经常发生的事情。一开始，你将一个类设计成一个紧密、坚固且小型的整体。你的意图非常积极。很快你就会意识到这个类还有其他任务要完成。然后，又有其他任务。然后，还有更多任务。</p><p>让类变得越来越强大的最好方法是通过添加setter将配置参数注入类中，以便在内部进行处理，不是吗？</p><p>这就是问题的根源！问题的根本原因是我们通过配置方法（也称为”setter”）将数据插入可变对象的能力。当一个对象是可变的并且允许我们随时添加setter时，我们会毫不限制地这样做。</p><p>让我这样说——可变类倾向于变得越来越庞大，失去紧密性。</p><p>如果commons-email的作者在一开始就使这个”Email”类是不可变的，他们就无法添加那么多方法和封装那么多属性。他们也无法将其变成一个庞然大物。为什么？因为不可变对象只能通过构造函数接受状态。你能想象一个有33个参数的构造函数吗？当然不能。</p><p>当你一开始就使你的类不可变时，你被迫保持紧密、小型、坚固和稳定。因为你不能封装太多内容，也不能修改封装的内容。只需两个或三个构造函数参数，就完成了。</p><p>当我设计 <a href="https://github.com/jcabi/jcabi-email">jcabi-email</a> 时，我从一个小而简单的类开始：<a href="https://github.com/jcabi/jcabi-email/blob/1.3/src/main/java/com/jcabi/email/Postman.java"><code class="language-plaintext highlighter-rouge">Postman</code></a>。嗯，它是一个接口，因为我从不创建没有接口的类。所以，<code class="language-plaintext highlighter-rouge">Postman</code> 是……一名邮递员。他将消息递送给其他人。首先，我创建了一个默认版本（为了简洁起见，我省略了构造函数）：</p><p>不错的开始，它可以工作。现在怎么办？嗯，<a href="http://docs.oracle.com/javaee/7/api/javax/jms/Message.html"><code class="language-plaintext highlighter-rouge">Message</code></a>很难构建。它是一个复杂的JDK类，需要一些操作才能变成一个漂亮的HTML电子邮件。所以我创建了一个信封，它将为我构建这个复杂的对象（请注意，<a href="https://github.com/jcabi/jcabi-email/blob/1.3/src/main/java/com/jcabi/email/Postman.java"><code class="language-plaintext highlighter-rouge">Postman</code></a>和<a href="https://github.com/jcabi/jcabi-email/blob/1.3/src/main/java/com/jcabi/email/Envelope.java"><code class="language-plaintext highlighter-rouge">Envelope</code></a>都是不可变的，并且用<a href="http://aspects.jcabi.com/apidocs-0.20/com/jcabi/aspects/Immutable.html">@Immutable</a>注释，来自<a href="http://aspects.jcabi.com/annotation-immutable.html">jcabi-aspects</a>)。</p><p>我还重构了 <code class="language-plaintext highlighter-rouge">Postman</code>，使其接受一个信封而不是一个消息:</p><p>到目前为止，一切顺利。现在让我们尝试创建一个简单的“Envelope”实现。</p><p>它可以工作，但目前还没有任何有用的功能。它只会创建一个完全空的MIME消息并返回它。要不要给它添加一个主题，以及<code class="language-plaintext highlighter-rouge">To:</code>和<code class="language-plaintext highlighter-rouge">From:</code>地址（请注意，<a href="http://email.jcabi.com/apidocs-1.10/com/jcabi/email/Envelope.Mime.html"><code class="language-plaintext highlighter-rouge">MIME</code></a>类也是不可变的）？</p><p>看起来正确并且能工作。但还是太简陋了。<code class="language-plaintext highlighter-rouge">CC:</code>和<code class="language-plaintext highlighter-rouge">BCC:</code>怎么办？电子邮件正文呢？PDF附件怎么办？如果我想指定消息的编码方式怎么办？那<code class="language-plaintext highlighter-rouge">Reply-To</code>怎么办？</p><p>我能把所有这些参数都添加到构造函数里吗？记住，这个类是不可变的，我不能引入<code class="language-plaintext highlighter-rouge">setReplyTo()</code>方法。我必须将<code class="language-plaintext highlighter-rouge">replyTo</code>参数传递给它的构造函数。但这是不可能的，因为构造函数会有太多的参数，没有人能够使用它。</p><p>嗯，我开始思考：我们如何将“信封”的概念分解为更小的概念-这就是我发明的。就像现实中的信封一样，我的<code class="language-plaintext highlighter-rouge">MIME</code>对象将有邮票。邮票将负责配置一个<code class="language-plaintext highlighter-rouge">Message</code>对象（再次，<a href="https://github.com/jcabi/jcabi-email/blob/1.3/src/main/java/com/jcabi/email/Stamp.java"><code class="language-plaintext highlighter-rouge">Stamp</code></a>是不可变的，以及其所有的实现者）。</p><p>现在，我可以将我的<a href="https://github.com/jcabi/jcabi-email/blob/1.3/src/main/java/com/jcabi/email/Envelope.java"><code class="language-plaintext highlighter-rouge">MIME</code></a>类简化为以下内容：</p><p>现在，我将为主题、<code class="language-plaintext highlighter-rouge">To:</code>、<code class="language-plaintext highlighter-rouge">From:</code>、<code class="language-plaintext highlighter-rouge">CC:</code>、<code class="language-plaintext highlighter-rouge">BCC:</code>等创建邮戳。任意数量的邮戳。<code class="language-plaintext highlighter-rouge">MIME</code>类将保持不变——小巧、内聚性强、易读、稳定等等。</p><p>重要的是，我为什么决定在类相对较小的时候进行重构。事实上，在<code class="language-plaintext highlighter-rouge">MIME</code>类只有25行代码时，我就开始担心这些邮戳类了。</p><p>这正是本文章的重点——<em>不可变性强迫你设计小巧且内聚的对象</em>。</p><p>如果没有不可变性，我会像<code class="language-plaintext highlighter-rouge">commons-email</code>一样走相同的路。我的<code class="language-plaintext highlighter-rouge">MIME</code>类会不断增加，最终变得和<code class="language-plaintext highlighter-rouge">commons-email</code>中的<code class="language-plaintext highlighter-rouge">Email</code>类一样大。唯一阻止我这样做的是重构的必要性，因为我无法通过构造函数传递所有参数。</p><p>如果没有不可变性，我就没有这个动力，就会像Apache开发者在<code class="language-plaintext highlighter-rouge">commons-email</code>中所做的那样，使类变得臃肿，变成一个难以维护的怪兽。</p><p>那就是<a href="http://email.jcabi.com">jcabi-email</a>。希望这个例子足够说明问题，并且你将开始使用不可变对象编写更干净的代码。</p><p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/42 on 2023-11-28 at 15:35</p></article></div><div class="wrapper"> <footer class="footer"><p> &copy; <span itemscope="" itemprop="copyrightHolder" itemtype="http://schema.org/Person"> <span itemprop="name">Yegor Bugayenko</span> </span> 2014&ndash;<span itemprop="copyrightYear">2023</span></p></footer></div></section><div class="wrapper unprintable" style="text-align:center;margin-top:2em;"> <a href="https://www.sixnines.io/h/3ba1652f"> <img src="//www.sixnines.io/b/3ba1652f?style=flat" alt="sixnines availability badge" /></a> &nbsp; <a href="https://github.com/yegor256/blog/stargazers"> <img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square" alt="GitHub stars" /></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script> <script src="/js/all.js?19fbb713f25"></script> <script>var disqus_shortname = 'yegor256';</script> <script id="dsq-count-scr" src="//yegor256.disqus.com/count.js" async="async"></script> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-1963507-32', 'auto'); ga('send', 'pageview'); </script> <script> Cd=document;Cr="&"+Math.random();Cp="&s=1"; Cd.cookie="b=b";if(Cd.cookie)Cp+="&c=1"; Cp+="&t="+(new Date()).getTimezoneOffset(); if(self!=top)Cp+="&f=1"; </script> <script> if(navigator.javaEnabled())Cp+="&j=1"; </script> <script> if(typeof(screen)!='undefined')Cp+="&w="+screen.width+"&h="+ screen.height+"&d="+(screen.colorDepth?screen.colorDepth:screen.pixelDepth); </script> <script> Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+ "&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+ "' border='0' wi"+"dth='1' he"+"ight='1'/>"); </script> <script type="application/ld+json"> { "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] } </script> </body> </html>
