<!doctypehtml><html xmlns="https://www.w3.org/1999/xhtml"lang="en-US"xml:lang="en-US"itemscope=""itemtype="http://schema.org/WebSite"><meta charset="utf-8"><meta name="description"content="Reflection in object-oriented programming languages like Java is a powerful technique, but a very dangerous and harmful one."><meta name="keywords"content=""><meta name="viewport"content="width=device-width,minimum-scale=1,initial-scale=1"><meta name="google-site-verification"content="JEj_gQr2CPe2QKGw8XdMz0R7VboQIUbX3FlM-lwTq-8"><meta name="author"content="Yegor Bugayenko"><meta name="og:site_name"content="Yegor Bugayenko"><meta name="og:type"content="article"><meta name="og:locale"content="en_US"><meta name="twitter:account_id"content="4503599630178231"><meta name="twitter:creator"content="@yegor256"><meta name="twitter:site"content="@yegor256"><meta name="twitter:title"property="og:title"content="Reflection Means Hidden Coupling"><meta name="twitter:description"property="og:description"content="Reflection in object-oriented programming languages like Java is a powerful technique, but a very dangerous and harmful one."><meta name="twitter:url"property="og:url"content="https://www.yegor256.com/zh/2022/06/05/reflection-means-hidden-coupling.html"><meta name="telegram:channel"content="AAAAAEJFMRzsRTRxM3ec6A"><link rel="search"type="application/opensearchdescription+xml"href="/opensearch.xml"title="yegor256"><link rel="shortcut icon"href="/favicon.ico?ffdde63ad39"><link rel="apple-touch-icon"href="/favicon.ico?ffdde63ad39"><link rel="alternate"type="application/rss+xml"title="RSS for yegor256.com"href="https://www.yegor256.com/rss.xml"><link rel="stylesheet"href="/css/layout.css?ffdde63ad39"><link rel="stylesheet"href="/css/icons.css?ffdde63ad39"><link rel="canonical"href="https://www.yegor256.com/zh/2022/06/05/reflection-means-hidden-coupling.html"><title>Reflection Means Hidden Coupling</title><div class="wrapper"><aside class="header-toggle unprintable"id="header-toggle"title="Show the menu"onclick='$("#header").show(),$("#header-toggle").hide()'>&#9776;</aside><header class="header"id="header"><div class="face"><a href="/about-me.html#form"class="sub"title="Click to subscribe to my monthly newsletter"><span>Subscribe</span></a> <a href="/about-me.html"style="position:relative"><img src="/images/face-256x256.jpg"class="photo"alt="Yegor Bugayenko"></a></div><nav><ul class="menu social notranslate"><li><a href="https://twitter.com/intent/follow?screen_name=yegor256"rel="nofollow"title="Follow me on Twitter"><i class="icon icon-twitter notranslate"aria-hidden="true"></i></a><li><a href="/rss.xml"rel="nofollow"title="Subscribe to my RSS feed"><i class="icon icon-rss notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://github.com/yegor256"rel="nofollow"title="My GitHub profile"><i class="icon icon-github notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="http://stackoverflow.com/users/187141/yegor256"rel="nofollow"title="My Stack Overflow profile"><i class="icon icon-stackoverflow notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://www.facebook.com/yegor256"rel="nofollow"title="Follow me on Facebook"><i class="icon icon-facebook notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://instagram.com/yegor256"rel="nofollow"title="Follow me on Instagram"><i class="icon icon-instagram notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://www.linkedin.com/in/yegor256"rel="nofollow"title="My LinkedIn profile"><i class="icon icon-linkedin notranslate"aria-hidden="true"></i></a><li><a itemprop="sameAs"href="https://www.youtube.com/c/yegor256?sub_confirmation=1"rel="nofollow"title="My Youtube video channel"><i class="icon icon-youtube notranslate"aria-hidden="true"></i></a><li><a href="https://soundcloud.com/yegor256"rel="nofollow"title="My podcast"><i class="icon icon-podcast notranslate"aria-hidden="true"></i></a><li><a href="https://itunes.apple.com/us/podcast/yegor256-podcast/id1150826721"rel="nofollow"title="My iTunes podcast"><i class="icon icon-itunes notranslate"aria-hidden="true"></i></a><li><a href="https://t.me/yegor256news"rel="nofollow"title="My Telegram public channel"><i class="icon icon-telegram notranslate"aria-hidden="true"></i></a><li><a href="mailto:blog@yegor256.com"rel="nofollow"title="Email me any time"><i class="icon icon-mail notranslate"aria-hidden="true"></i></a></ul><ul class="menu"><li><a href="/"title="Home page">Home</a><li><a href="/best.html"title="Best articles to read">12&#160;Best</a><li><a href="/contents.html"title="The contents of the entire blog">All&#160;393</a><li><a href="/teaching.html"title="My courses and lectures">Teaching</a><li><a href="/talks.html"title="Future and past conference talks">Talks</a><li><a href="/books.html"title="The books I wrote">Books</a><li><a href="/research.html"title="My research directions and progress">Research</a><li><a href="/pets.html"title="My loved pet projects">Pets</a><li><a href="/testimonials.html"title="What some people say about me">Testimonials</a><li><a href="/shift-m.html"title="Audio podcast about project management">Shift-M</a><li><a href="/paintings.html"title="My paintings for sale">Art</a><li><a href="https://ru.yegor256.com/"title="Немного на русском языке о политике в России, Украине и мире">Политика</a></ul></nav><div class="search"><form action="https://www.google.com/search"itemprop="potentialAction"itemscope=""itemtype="http://schema.org/SearchAction"><meta itemprop="target"content="https://www.google.com/search?q={q}"><input name="sitesearch"value="yegor256.com"type="hidden"> <input itemprop="query-input"id="search-query"class="field field-text"required="required"onfocus='$(".google").css("visibility","visible")'name="q"placeholder="Search..."autocomplete="off"> <input type="image"src="/images/google-search-icon.svg"class="google"title="Search via Google"alt="Search via Google"></form></div><div class="hot"><ul></ul></div></header></div><section itemscope=""itemtype="http://schema.org/BlogPosting"><div class="wrapper"><header><h1 itemprop="name headline mainEntityOfPage">Reflection Means Hidden Coupling</h1></header><article class="main"itemprop="articleBody"style="font-family:sans-serif;font-size:.9em;line-height:1.2em"><p style="color:#c42c00">The following text is a <em>partial</em> translation of the <a href="https://www.yegor256.com/2022/06/05/reflection-means-hidden-coupling.html">original English article</a>, performed by <a href="https://chat.openai.com/">ChatGPT</a> (gpt-3.5-turbo) and <a href="https://github.com/yegor256/jekyll-chatgpt-translate">this Jekyll plugin</a>:<p><a href="https://en.wikipedia.org/wiki/Reflective_programming">反射式编程</a>（或反射）是指代码在运行时自身发生变化的情况。例如，当我们调用一个类的方法时，它除了其他操作外还会向该类添加一个新的方法（也称为<a href="https://en.wikipedia.org/wiki/Monkey_patch">猴子补丁</a>）。Java、Python、PHP、JavaScript等等，无一例外都拥有这个“强大”的特性。那么，这个特性有什么问题呢？嗯，它的问题在于它的<a href="https://mattwarren.org/2016/12/14/Why-is-Reflection-slow/">速度慢</a>，<a href="https://owasp.org/www-community/vulnerabilities/Unsafe_use_of_Reflection">存在风险</a>，而且很难阅读和调试。然而，所有这些与其引入到代码中的<em>耦合</em>比起来都不算什么。<p>有很多情况下反射可以“帮助”你。让我们逐个了解它们，并看看为什么它们给代码增加的耦合是不必要和有害的。<p>Here is the code:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public int sizeOf(Iterable items) {
  return ((Collection) items).size();
}
</code></pre></div></div><p>我不确定每个人都会同意这是反射，但我相信它是：我们在运行时检查类的结构，然后调用在<code class="language-plaintext highlighter-rouge">Iterable</code>中不存在的<code class="language-plaintext highlighter-rouge">size()</code>方法。这个方法只有在运行时才会“显示出来”，当我们在字节码中创建一个<a href="https://stackoverflow.com/questions/19017258">动态快捷方式</a>时。<p>除了以下几点之外，为什么这样做是不好的：1）它很<a href="https://www.buzdin.lv/2011/01/is-java-reflection-really-slow.html">慢</a>，2）它更冗长，因此<a href="https://armedia.com/blog/instanceof-avoid-in-code/">不易读</a>，3）它引入了一个新的失败点，因为对象<code class="language-plaintext highlighter-rouge">items</code>可能不是<code class="language-plaintext highlighter-rouge">Collection</code>类的实例，导致<a href="https://docs.oracle.com/javaee/5/api/javax/el/MethodNotFoundException.html"><code class="language-plaintext highlighter-rouge">MethodNotFoundException</code></a>。<p>上述代码对整个程序造成的最大问题是它与客户端之间的耦合，例如：<p>这种方法可能有效，也可能无效。这取决于<code class="language-plaintext highlighter-rouge">list</code>的实际类别。如果它是<code class="language-plaintext highlighter-rouge">Collection</code>，则调用<code class="language-plaintext highlighter-rouge">sizeOf</code>将成功。否则，将会发生运行时故障。通过查看<code class="language-plaintext highlighter-rouge">calc</code>方法，我们无法确定处理<code class="language-plaintext highlighter-rouge">list</code>以避免运行时故障的正确方法。我们需要阅读<code class="language-plaintext highlighter-rouge">sizeOf</code>的内容，然后才能将<code class="language-plaintext highlighter-rouge">calc</code>更改为类似这样的代码：<p>这段代码目前看起来还不错。然而，当 <code class="language-plaintext highlighter-rouge">sizeOf</code> 将其实现更改为类似下面这样的情况时会发生什么（我从这篇关于类型转换的文章中获取的）：<p>现在，<code class="language-plaintext highlighter-rouge">sizeOf</code> 完美地处理了任何类型的输入，无论它是 <code class="language-plaintext highlighter-rouge">Collection</code> 的实例还是其他类型。然而，<code class="language-plaintext highlighter-rouge">calc</code> 方法并不知道在 <code class="language-plaintext highlighter-rouge">sizeOf</code> 方法中所做的更改。相反，它仍然认为除了 <code class="language-plaintext highlighter-rouge">Collection</code> 之外的任何输入都会导致 <code class="language-plaintext highlighter-rouge">sizeOf</code> 失效。为了使它们保持同步，我们必须记住 <code class="language-plaintext highlighter-rouge">calc</code> 对于 <code class="language-plaintext highlighter-rouge">sizeOf</code> 的了解，并在 <code class="language-plaintext highlighter-rouge">sizeOf</code> 发生更改时进行修改。因此，可以说 <code class="language-plaintext highlighter-rouge">calc</code> 与 <code class="language-plaintext highlighter-rouge">sizeOf</code> 相互依赖，而这种依赖关系是<em>隐藏的</em>：很可能，我们会忘记在 <code class="language-plaintext highlighter-rouge">sizeOf</code> 得到更好的实现时修改 <code class="language-plaintext highlighter-rouge">calc</code>。此外，在程序中可能还有许多类似于 <code class="language-plaintext highlighter-rouge">calc</code> 的地方，我们必须记住当 <code class="language-plaintext highlighter-rouge">sizeOf</code> 方法发生变化时进行修改。显然，我们会忘记其中大部分。<p>这种依赖关系是一个很大的可维护性问题，它是由于 Java 中反射的存在而引入的。如果我们不能使用 <code class="language-plaintext highlighter-rouge">instanceof</code> 运算符和类转换（或者根本没有它们），首先就不可能存在这种依赖关系。<p>Consider this code:<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Book {
  private String author;
  private String title;
  Book(String a, String t) {
    this.author = a;
    this.title = t;
  }
  public void print() {
    System.out.println(
      "The book is: " + this.name()
    );
  }
  private String name() {
    return this.title + " by " + this.author;
  }
}
</code></pre></div></div><p>你如何为这个类及其方法<code class="language-plaintext highlighter-rouge">print()</code>编写单元测试？显然，如果不对这个类进行重构，几乎是不可能的。 <code class="language-plaintext highlighter-rouge">print</code>方法将文本发送到控制台，由于其为“静态”方法，我们无法轻松地进行模拟。正确的方式是将<code class="language-plaintext highlighter-rouge">System.out</code>作为依赖注入，但我们中的一些人<a href="https://stackoverflow.com/questions/34571">认为</a>反射是更好的选择，这将允许我们直接测试私有方法<code class="language-plaintext highlighter-rouge">name</code>，而无需首先调用<code class="language-plaintext highlighter-rouge">print</code>方法。<p>您还可以使用<a href="https://github.com/powermock/powermock">PowerMock</a> Java库来处理私有方法的许多”美丽”事情。<p>这个测试的问题在于它与它所测试的对象紧密耦合：测试过多地了解了<code class="language-plaintext highlighter-rouge">Book</code>类。测试知道这个类包含一个私有方法<code class="language-plaintext highlighter-rouge">name</code>。测试还知道方法<code class="language-plaintext highlighter-rouge">name</code>将在某个时候被方法<code class="language-plaintext highlighter-rouge">print</code>调用。测试并没有测试<code class="language-plaintext highlighter-rouge">print</code>，而是测试了它不应该了解的东西：<code class="language-plaintext highlighter-rouge">Book</code>类的内部。<p>单元测试的主要目的是为我们这些试图修改先前编写的代码或非常早期编写的代码的程序员提供一个”安全网”：如果我们破坏了任何东西，测试会及时给我们一个信号，”突出显示”代码被破坏的位置。如果没有突出显示，测试都是通过的，我就可以继续修改代码。我依赖于我的测试所提供的信息。我信任它们。<p>我拿到<code class="language-plaintext highlighter-rouge">Book</code>类并想要对它进行修改，只是将方法<code class="language-plaintext highlighter-rouge">name</code>的返回类型从<code class="language-plaintext highlighter-rouge">String</code>改为<code class="language-plaintext highlighter-rouge">StringBuilder</code>。这是一个相当无害的修改，可能是出于性能考虑的需要。在我开始做任何改动之前，我运行所有的测试（这是一个<a href="https://wiki.c2.com/?TestEveryRefactoring">良好的实践</a>）它们都通过了。然后我进行我的改动，期望没有测试失败：<p>然而，测试<code class="language-plaintext highlighter-rouge">BookTest</code>将会失败，因为它<em>期望</em>我的<code class="language-plaintext highlighter-rouge">Book</code>类有一个返回<code class="language-plaintext highlighter-rouge">String</code>的<code class="language-plaintext highlighter-rouge">name</code>方法。如果这不是我的测试，或者我很久之前就写的，我会对这个事实感到沮丧：测试要求我只能用一种特定的方式编写<em>私有</em>方法。为什么？返回<code class="language-plaintext highlighter-rouge">StringBuilder</code>有什么问题吗？我认为这背后一定有什么隐藏的原因。否则，为什么测试要求私有实现的类做任何事情？很快，经过一番调查，我会发现没有理由。这只是测试对<code class="language-plaintext highlighter-rouge">Book</code>内部的假设，这种假设除了”我们没有时间重构类并使<code class="language-plaintext highlighter-rouge">System.out</code>可注入”之外没有其他理由。<p>顺便说一下，这种测试方法被称为“Inspector”测试反模式。<p>接下来我该怎么办？我必须撤销我的更改，然后开始重构测试<em>和</em>类，以消除这种假设。然而，同时改变测试和主要代码是一种危险的做法，<a href="https://twitter.com/yegor256/status/1525758255225528320">我相信</a>，可能会引入一些新的错误。<p>对我来说，测试不再是一个“安全网”。我不能相信它们。我修改代码，我知道我没有破坏任何东西。然而，测试却给我一个红色信号。如果它在这样一个简单的场景中都会说谎，我怎么能相信它呢？<p>如果不能使用反射，单元测试<code class="language-plaintext highlighter-rouge">BookTest</code>和类<code class="language-plaintext highlighter-rouge">Book</code>之间的耦合就不会发生。如果没有人能以任何方式访问私有方法，那么在单元测试中使用Inspector反模式就是不可能的。<p>当然，如果我们也没有私有方法，生活会更好。<p>以下是典型工厂的运作方式：<p>工厂方法是<code class="language-plaintext highlighter-rouge">make</code>。它期望提供”operator”的名称，然后利用Java反射API中的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html#forName-java.lang.String-"><code class="language-plaintext highlighter-rouge">Class.forName()</code></a>构造类的名称，在<a href="https://docs.oracle.com/javase/tutorial/essential/environment/paths.html">类路径</a>中找到它，并创建一个实例。现在，假设有两个类都实现了接口<code class="language-plaintext highlighter-rouge">Operator</code>：<p>然后我们使用它们，首先通过询问我们的工厂方法来根据操作符名称创建对象：<p><code class="language-plaintext highlighter-rouge">结果</code>将为13。<p>如果没有反思，我们将无法做到这一点。我们将不得不这样做：<p>如果你问我，这段代码看起来更易读且更易维护。首先，因为在任何启用<a href="https://www.jetbrains.com/help/idea/navigating-through-the-source-code.html#go_to_declaration">代码导航</a>的IDE中，可以点击<code class="language-plaintext highlighter-rouge">OpMinus</code>或<code class="language-plaintext highlighter-rouge">OpPlus</code>并立即跳转到类的主体。其次，类查找的逻辑由JVM提供：我不需要猜测调用<code class="language-plaintext highlighter-rouge">make("Plus")</code>时会发生什么。<p>有几个原因使人们喜欢静态工厂。我不同意这些观点。这篇博文解释了原因。如果没有反射，根本无法使用静态工厂，而且代码会更好、更易维护。<p>在Java中，您可以将注释（DTO-ish接口的实例）附加到类（或类的元素，如方法或参数）。然后可以在运行时或编译时读取来自注释的信息。在现代框架（如<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/annotation/Autowired.html">Spring</a>）中，这个特性经常用于自动化对象的连线：您只需将一些注释附加到您的类上，框架将找到它们，实例化它们，将它们放入DI容器中，并分配给其他对象的属性。<p>我之前说过，这种发现对象并<em>自动</em>将它们连接在一起的机制是一种反模式。我之前也说过，注释是一种反模式。如果没有反射，依赖注入容器、自动连线和注释都不会存在。生活会更好，Java/OOP会更清晰。<p>使用带注释的对象/类的客户端与它们耦合，并且这种耦合是<em>隐藏的</em>。带注释的对象可以更改其接口或修改注释，代码仍然可以编译通过。问题只会在运行时稍后出现，当其他对象的期望无法满足时。<p>当程序员不理解面向对象的范式时，他们会制作DTO而不是正确的对象。然后，为了将DTO传输到网络上或将其保存到文件中，他们会对其进行序列化或编组。这通常由一个特殊的序列化引擎完成，该引擎接受DTO，突破所有可能的封装障碍，读取所有字段的值，并将它们打包成，比如一个JSON片段。<p>为了让序列化引擎突破封装障碍，编程语言必须具备反射功能。首先，因为DTO的某些字段可能是私有的，只能通过反射访问。其次，即使DTO设计得“正确”，具备了所有必要的获取私有字段的getter方法，仍然需要反射来了解哪些getter方法存在并可以调用。<p>序列化表达的态度和ORM非常相似。它们都不与对象交互，而是“强行”将对象拆散，拿走所需的部分，使对象陷入无意识状态。如果将来一个对象决定更改其结构、重命名某些字段或更改返回值的类型，那些通过序列化与该对象实际关联的其他对象将一无所知。他们会在运行时才注意到，当“无效数据格式”异常开始上浮时。对象的开发者将没有机会注意到他们对对象接口的更改会影响到代码库中的其他地方。<p>我们可以说，序列化是一种“完美”的耦合两个对象的方法，使得两者都不知道这种耦合的存在。<p>面向对象编程的核心思想是对象为王。只有对象自己可以决定如何处理其所封装的数据。这一原则的存在和遵守有助于避免由一个简单的情况引起的运行时错误：A使用来自B的数据，而不告诉B如何使用，然后B更改数据的格式或语义，A无法理解。<p>显然，如果没有反射，这种“滥用”式的序列化是不可能的。一种更谨慎的序列化是可能的，并且会被使用，但不是通过反射，而是通过对象实现的打印机。<p>总之，反射引入了隐藏的耦合。这是最危险的耦合类型，因为它很难跟踪、很难找到并且很难消除。如果没有反射，面向对象设计将更加清晰和稳定。但即使存在这个特性，我建议您在编程语言中永远不要使用反射。<p class="jekyll-chatgpt-translate">Translated by ChatGPT gpt-3.5-turbo/42 on 2023-12-16 at 15:54</article></div><div class="wrapper"><footer class="footer"><p>&copy; <span itemscope=""itemprop="copyrightHolder"itemtype="http://schema.org/Person"><span itemprop="name">Yegor Bugayenko</span> </span>2014&ndash;<span itemprop="copyrightYear">2023</span></footer></div></section><div class="wrapper unprintable"style="text-align:center;margin-top:2em"><a href="https://www.sixnines.io/h/3ba1652f"><img src="//www.sixnines.io/b/3ba1652f?style=flat"alt="sixnines availability badge"></a>&nbsp; <a href="https://github.com/yegor256/blog/stargazers"><img src="//img.shields.io/github/stars/yegor256/blog.svg?style=flat-square"alt="GitHub stars"></a></div><script src="//code.jquery.com/jquery-1.9.0.min.js"></script><script src="/js/all.js?ffdde63ad39"></script><script>var disqus_shortname="yegor256"</script><script id="dsq-count-scr"src="//yegor256.disqus.com/count.js"async="async"></script><script>((e,a,t,g,n,c)=>{e.GoogleAnalyticsObject=g,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=+new Date,n=a.createElement(t),c=a.getElementsByTagName(t)[0],n.async=1,n.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(n,c)})(window,document,"script","ga"),ga("create","UA-1963507-32","auto"),ga("send","pageview")</script><script>Cd=document,Cr="&"+Math.random(),Cp="&s=1",Cd.cookie="b=b",Cd.cookie&&(Cp+="&c=1"),Cp+="&t="+(new Date).getTimezoneOffset(),self!=top&&(Cp+="&f=1")</script><script>navigator.javaEnabled()&&(Cp+="&j=1")</script><script>"undefined"!=typeof screen&&(Cp+="&w="+screen.width+"&h="+screen.height+"&d="+(screen.colorDepth||screen.pixelDepth))</script><script>Cd.write("<img src='//c.hit.ua/hit?i=95870&g=0&x=2"+Cp+Cr+"&r="+escape(Cd.referrer)+"&u="+escape(window.location.href)+"' border='0' width='1' height='1'/>")</script><script type="application/ld+json">{ "@context": "http://schema.org", "@type": "Person", "name": "Yegor Bugayenko", "url": "https://www.yegor256.com", "sameAs": [ "https://www.facebook.com/yegor256", "https://instagram.com/yegor256", "https://www.linkedin.com/in/yegor256", "https://twitter.com/yegor256", "https://github.com/yegor256", "https://www.pinterest.com/yegor256/" ] }</script>